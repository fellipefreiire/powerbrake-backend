This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  pre-push
prisma/
  migrations/
    20250529214226_create_user/
      migration.sql
    20250530160155_add_manager_role/
      migration.sql
    20250602180156_map_and_avatar_url/
      migration.sql
    20250602193921_create_avatar/
      migration.sql
    20250603023156_user_avatar/
      migration.sql
    20250609231405_address_and_client/
      migration.sql
    20250611140449_audit_log/
      migration.sql
    migration_lock.toml
  schema.prisma
  seed.ts
src/
  core/
    entities/
      aggregate-root.ts
      entity.ts
      unique-entity-id.ts
      value-object.ts
      watched-list.spec.ts
      watched-list.ts
    errors/
      generic-error/
        index.ts
      not-allowed-error/
        index.ts
      resource-not-found-error/
        index.ts
      use-case-error.ts
    events/
      domain-event.ts
      domain-events.spec.ts
      domain-events.ts
      event-handler.ts
    repositories/
      pagination-params.ts
    types/
      optional.ts
    either.spec.ts
    either.ts
  domain/
    audit-log/
      application/
        repositories/
          audit-log-repository.ts
        subscribers/
          user/
            __tests__/
              on-user-active-status-changed.spec.ts
              on-user-created.spec.ts
              on-user-logged-in.spec.ts
              on-user-logged-out.spec.ts
              on-user-password-changed.spec.ts
              on-user-requested-password-reset.spec.ts
              on-user-reset-password.spec.ts
              on-user-role-changed.spec.ts
              on-user-updated.spec.ts
            on-user-active-status-changed.ts
            on-user-created.ts
            on-user-logged-in.ts
            on-user-logged-out.ts
            on-user-password-changed.ts
            on-user-requested-password-reset.ts
            on-user-reset-password.ts
            on-user-role-changed.ts
            on-user-updated.ts
        use-cases/
          __tests__/
            create-audit-log.spec.ts
            list-audit-logs.spec.ts
          create-audit-log.ts
          list-audit-logs.ts
      enterprise/
        entities/
          audit-log.ts
    user/
      application/
        repositories/
          user-address-repository.ts
          user-avatar-repository.ts
          user-repository.ts
        use-cases/
          __tests__/
            authenticate-user.spec.ts
            create-user.spec.ts
            edit-user-password.spec.ts
            edit-user-role.spec.ts
            edit-user-status.spec.ts
            edit-user.spec.ts
            find-user-by-email.spec.ts
            find-user-by-id.spec.ts
            forgot-password.spec.ts
            list-users.spec.ts
            logout-user.spec.ts
            refresh-user-token.spec.ts
            reset-password.spec.ts
            user-address-watcher.spec.ts
            user-avatar-watcher.spec.ts
          errors/
            index.ts
            invalid-role-transition-error.ts
            user-already-exists-error.ts
            user-inactive-error.ts
            user-not-found.ts
            user-unauthorized-error.ts
            wrong-credentials-error.ts
          authenticate-user.ts
          create-user.ts
          edit-user-password.ts
          edit-user-role.ts
          edit-user-status.ts
          edit-user.ts
          find-user-by-email.ts
          find-user-by-id.ts
          forgot-password.ts
          list-users.ts
          logout-user.ts
          refresh-user-token.ts
          reset-password.ts
          user-address-watcher.ts
          user-avatar-watcher.ts
      enterprise/
        entities/
          user-address-list.ts
          user-address.ts
          user-avatar.ts
          user.ts
        events/
          user-active-status-changed-event.ts
          user-created-event.ts
          user-logged-in-event.ts
          user-logged-out-event.ts
          user-password-changed-event.ts
          user-request-password-reset-event.ts
          user-reset-password-event.ts
          user-role-changed-event.ts
          user-updated-event.ts
  infra/
    auth/
      casl/
        handlers/
          user-can-read-self.handler.ts
          user-can-update-self.handler.ts
        models/
          audit-log.ts
          avatar.ts
          user.ts
        subjects/
          audit-log.ts
          avatar.ts
          user.ts
        ability.factory.ts
        casl-ability.guard.ts
        casl-ability.module.ts
        check-policies.decorator.ts
        permissions.ts
        roles.ts
      auth.module.ts
      current-user.decorator.ts
      jwt-auth.guard.ts
      jwt.strategy.ts
      public.ts
      refresh-token.repository.ts
      refresh-token.service.ts
      token-repository.ts
      token.service.ts
    cache/
      redis/
        redis-cache-repository.ts
        redis.service.ts
      cache-repository.ts
      cache.module.ts
    cryptography/
      bcrypt-hasher.ts
      cryptography.module.ts
      jwt-encrypter.ts
      jwt-verifier.ts
    database/
      prisma/
        mappers/
          audit-log/
            prisma-audit-log.mapper.ts
          avatar/
            prisma-avatar.mapper.ts
          user/
            prisma-user-address.mapper.ts
            prisma-user.mapper.ts
        repositories/
          audit-log/
            audit-log-database.module.ts
            prisma-audit-log.repository.ts
          avatar/
            avatar-database.module.ts
            prisma-avatar-repository.ts
          user/
            tests/
              prisma-user-repository.e2e-spec.ts
            prisma-user-address-repository.ts
            prisma-user-avatar-repository.ts
            prisma-users-repository.ts
            user-database.module.ts
        prisma.module.ts
        prisma.service.ts
    decorators/
      service-tag.decorator.ts
    env/
      env.module.ts
      env.service.ts
      env.ts
    events/
      user/
        __tests__/
          on-user-active-status-changed.e2e-spec.ts
          on-user-created.e2e-spec.ts
          on-user-logged-in.e2e-spec.ts
          on-user-logged-out.e2e-spec.ts
          on-user-password-changed.e2e-spec.ts
          on-user-requested-password-reset.e2e-spec.ts
          on-user-reset-password.e2e-spec.ts
          on-user-role-changed.e2e-spec.ts
          on-user-updated.e2e-spec.ts
        user-events.module.ts
      events.module.ts
    http/
      controllers/
        audit-log/
          __tests__/
            list-audit-logs.e2e-spec.ts
          audit-log-controllers.module.ts
          list-audit-logs.controller.ts
        avatar/
          __tests__/
            upload-avatar.controller.e2e-spec.ts
          avatar-controllers.module.ts
          upload-avatar.controller.ts
        user/
          __tests__/
            authenticate-user.controller.e2e-spec.ts
            create-user.controller.e2e-spec.ts
            edit-user-avatar.integration.e2e-spec.ts
            edit-user-controller.e2e-spec.ts
            edit-user-password.controller.e2e-spec.ts
            edit-user-role.controller.e2e-spec.ts
            edit-user-status.controller.e2e-spec.ts
            find-user-by-id.controller.e2e-spec.ts
            forgot-password.controller.e2e-spec.ts
            list-users.controller.e2e-spec.ts
            logout-user.controller.e2e-spec.ts
            refresh-token.controller.e2e-spec.ts
            reset-password.controller.e2e-spec.ts
            reset-password.integration.e2e-spec.ts
          authenticate-user.controller.ts
          create-user.controller.ts
          edit-user-password.controller.ts
          edit-user-role.controller.ts
          edit-user-status.controller.ts
          edit-user.controller.ts
          find-user-by-id.controller.ts
          forgot-password.controller.ts
          list-users.controller.ts
          logout-user.controller.ts
          refresh-token.controller.ts
          reset-password.controller.ts
          user-controllers.module.ts
        health.controller.ts
      dtos/
        common/
          health-check-response.dto.ts
          index.ts
          pagination-meta.dto.ts
        error/
          avatar/
            avatar-forbidden.dto.ts
            avatar-upload-failed.dto.ts
            index.ts
          generic/
            bad-request.dto.ts
            conflict.dto.ts
            forbidden.dto.ts
            index.ts
            internal-server.dto.ts
            not-found.dto.ts
            too-many-requests.dto.ts
            unauthorized.dto.ts
            unprocessable-entity.dto.ts
            validation.dto.ts
          user/
            index.ts
            invalid-role-transition.dto.ts
            user-already-exists.dto.ts
            user-forbidden.dto.ts
            user-inactive.dto.ts
            user-not-found.dto.ts
            user-unauthorized.dto.ts
            wrong-credentials.dto.ts
        requests/
          avatar/
            index.ts
            upload-avatar-request.dto.ts
          user/
            authenticate-request.dto.ts
            create-user-request.dto.ts
            edit-user-password-request.dto.ts
            edit-user-request.dto.ts
            edit-user-role-request.dto.ts
            forgot-password-request.dto.ts
            index.ts
            reset-password-request.dto.ts
        response/
          audit-log/
            audit-log-list-response.dto.ts
            index.ts
          avatar/
            index.ts
            upload-avatar-response.dto.ts
          user/
            authenticate-response.dto.ts
            index.ts
            refresh-token-response.dto.ts
            user-list-response.dto.ts
            user-response.dto.ts
      filters/
        app-error.filter.ts
        audit-log-error.filter.ts
        avatar-error.filter.ts
        user-error.filter.ts
      indicators/
        mailer-health.indicator.ts
        prisma-health.indicator.ts
        redis-health.indicator.ts
        s3-health.indicator.ts
      pipes/
        index.ts
        parse-uuid.pipe.ts
        zod-validation.pipe.ts
      presenters/
        __tests__/
          audit-log.presenter.spec.ts
          user.presenter.spec.ts
        audit-log.presenter.ts
        user.presenter.ts
      http.module.ts
    logger/
      winston/
        logger.interceptor.ts
        logger.interface.ts
        logger.service.ts
        winston.config.ts
        winston.provider.ts
        winston.token.ts
      logger.module.ts
    mail/
      resend/
        resend-maile.spec.ts
        resend-mailer.ts
      mail-repository.ts
      mailer.module.ts
    storage/
      r2/
        r2-storage.ts
      storage.module.ts
    app.module.ts
    main.ts
  shared/
    address/
      enterprise/
        entities/
          address.ts
    avatar/
      application/
        repositories/
          avatar-repository.ts
        use-cases/
          __tests__/
            upload-and-create-avatar.spec.ts
          errors/
            avatar-upload-failed-error.ts
            invalid-avatar-type-error.ts
          upload-and-create-avatar.ts
      enterprise/
        entities/
          avatar.ts
    cryptography/
      encrypter.ts
      hash-comparer.ts
      hash-generator.ts
      token-verifier.ts
    rate-limit/
      rate-limit.decorator.ts
      rate-limit.guard.ts
      rate-limit.module.ts
      rate-limit.service.ts
    storage/
      uploader.ts
    utils/
      __tests__/
        circuit-breaker.spec.ts
      circuit-breaker.ts
      retry-with-backoff.ts
      with-timeout.ts
test/
  cache/
    fake-cache.ts
  cryptography/
    fake-encrypter.ts
    fake-hasher.ts
    fake-refresh-token.ts
    fake-token-verifier.ts
    fake-token.ts
  e2e/
    helmet.e2e-spec.ts
  factories/
    make-address.ts
    make-audit-log.ts
    make-avatar.ts
    make-user.ts
  infra/
    fake-circuit-breaker.ts
    fake-env.ts
    fake-logger.ts
  mail/
    fake-mailer.ts
  repositories/
    audit-log/
      in-memory-audit-log.repository.ts
    avatar/
      in-memory-avatar-repository.ts
    user/
      in-memory-user-address-repository.ts
      in-memory-user-avatar-repository.ts
      in-memory-users-repository.ts
  storage/
    fake-uploader.ts
  utils/
    wait-for.ts
  setup-e2e.ts
.env.example
.env.test.example
.eslintrc.json
.gitignore
.prettierrc
docker-compose.yml
nest-cli.json
package.json
README.md
ROADMAP.md
tsconfig.build.json
tsconfig.eslint.json
tsconfig.json
vitest.config.e2e.mjs
vitest.config.mjs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/infra/logger/winston/logger.interface.ts">
export interface LoggerPort {
  info(msg: string, meta?: Record<string, unknown>): void
  warn(msg: string, meta?: Record<string, unknown>): void
  error(msg: string, meta?: Record<string, unknown>): void
  debug(msg: string, meta?: Record<string, unknown>): void
}
</file>

<file path="src/infra/mail/resend/resend-maile.spec.ts">
import { ResendMailer } from '@/infra/mail/resend/resend-mailer'
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { FakeLogger } from 'test/infra/fake-logger'
import { Resend } from 'resend'
import { makeFakeEnvService } from 'test/infra/fake-env'

describe('ResendMailer (circuit breaker)', () => {
  const logger = new FakeLogger()
  const env = makeFakeEnvService()

  let sendMock: ReturnType<typeof vi.fn>

  beforeEach(() => {
    sendMock = vi.fn()

    // CORRE√á√ÉO:
    // O erro de tipo ocorre porque a classe `Emails` da biblioteca `resend` tem
    // membros privados. Ao fazer o mock, n√£o precisamos replicar a classe inteira.
    // Em vez disso, criamos um objeto simples contendo apenas o m√©todo `send` que
    // o nosso c√≥digo utiliza e o convertemos para `any`. Isso instrui o TypeScript
    // a ignorar a incompatibilidade de tipos, resolvendo o problema.
    vi.spyOn(Resend.prototype, 'emails', 'get').mockReturnValue({
      send: sendMock,
    } as any)
  })

  afterEach(() => {
    // Garante que os mocks sejam restaurados ap√≥s cada teste
    vi.restoreAllMocks()
  })

  it('should send email using Resend', async () => {
    // Simula uma resposta de sucesso da API
    sendMock.mockResolvedValueOnce({ data: { id: 'email_id' }, error: null })

    const sut = new ResendMailer(env, logger)

    await sut.send({
      to: 'john@example.com',
      subject: 'Test',
      html: '<p>Hello</p>',
    })

    // A asser√ß√£o foi atualizada para incluir o campo 'from',
    // que √© definido de forma fixa dentro da implementa√ß√£o de `ResendMailer`.
    expect(sendMock).toHaveBeenCalledWith({
      from: 'onboarding@resend.dev',
      to: 'john@example.com',
      subject: 'Test',
      html: '<p>Hello</p>',
    })
  })

  it('should throw if resend fails', async () => {
    // Simula uma falha na chamada da API
    sendMock.mockRejectedValueOnce(new Error('resend failure'))

    const sut = new ResendMailer(env, logger)

    // Verifica se o erro da API √© propagado corretamente
    await expect(() =>
      sut.send({
        to: 'fail@example.com',
        subject: 'Failure',
        html: '<p>Oops</p>',
      }),
    ).rejects.toThrowError('resend failure')
  })
})
</file>

<file path="test/infra/fake-env.ts">
import type { Env } from '@/infra/env/env'
import { EnvService } from '@/infra/env/env.service'
import type { ConfigService } from '@nestjs/config'

const fakeValues: Env = {
  NODE_ENV: 'test',
  APP_PORT: 3333,
  DATABASE_URL: 'postgres://user:pass@localhost:5432/db',
  DATABASE_HOST: 'localhost',
  DATABASE_PORT: '5432',
  DATABASE_USERNAME: 'user',
  DATABASE_PASSWORD: 'pass',
  DATABASE_NAME: 'app_db',
  REDIS_HOST: '127.0.0.1',
  REDIS_PORT: 6379,
  REDIS_DB: 0,
  REDIS_COMMAND_TIMEOUT: 1000,
  RATE_LIMIT_POINTS: 10,
  RATE_LIMIT_DURATION: 60,
  CLOUDFLARE_ACCOUNT_ID: 'fake-cloudflare-id',
  AWS_ACCESS_KEY_ID: 'fake-aws-key',
  AWS_SECRET_ACCESS_KEY: 'fake-aws-secret',
  AWS_BUCKET_NAME: 'fake-bucket',
  STORAGE_RETRY_ATTEMPTS: 3,
  STORAGE_RETRY_BACKOFF: 100,
  STORAGE_TIMEOUT: 2000,
  RESEND_API_KEY: 'fake-resend-api-key',
  RESET_PASSWORD_URL: 'https://example.com/reset',
  EMAIL_RETRY_ATTEMPTS: 3,
  EMAIL_RETRY_BACKOFF: 100,
  EMAIL_SEND_TIMEOUT: 3000,
  JWT_PRIVATE_KEY: 'private-key',
  JWT_PUBLIC_KEY: 'public-key',
}

const fakeConfigService = {
  get: <T extends keyof Env>(key: T) => fakeValues[key],
} as ConfigService<Env, true>

export const makeFakeEnvService = () => {
  return new EnvService(fakeConfigService)
}
</file>

<file path=".husky/pre-push">
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

echo "üîç Verificando testes e exclus√µes..."

# Executa os testes unit√°rios
npm run test || exit 1

# Executa os testes e2e
npm run test:e2e || exit 1

# Verifica se h√° testes com .only (test.only ou describe.only)
if grep -r --include="*.ts" --exclude-dir="node_modules" -E "test\.only|describe\.only" src/; then
  echo "‚ùå 'test.only' ou 'describe.only' encontrado. Remova antes de fazer push."
  exit 1
fi

echo "‚úÖ Pre-push finalizado com sucesso."
</file>

<file path="prisma/migrations/20250529214226_create_user/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('ADMIN', 'OPERATOR', 'SUPERVISOR');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'OPERATOR',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");
</file>

<file path="prisma/migrations/20250530160155_add_manager_role/migration.sql">
-- AlterEnum
ALTER TYPE "Role" ADD VALUE 'MANAGER';
</file>

<file path="prisma/migrations/20250602180156_map_and_avatar_url/migration.sql">
/*
  Warnings:

  - You are about to drop the column `createdAt` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `isActive` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `passwordHash` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `users` table. All the data in the column will be lost.
  - Added the required column `password_hash` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updated_at` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "users" DROP COLUMN "createdAt",
DROP COLUMN "isActive",
DROP COLUMN "passwordHash",
DROP COLUMN "updatedAt",
ADD COLUMN     "avatar_url" TEXT,
ADD COLUMN     "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "is_active" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "password_hash" TEXT NOT NULL,
ADD COLUMN     "updated_at" TIMESTAMP(3) NOT NULL;
</file>

<file path="prisma/migrations/20250602193921_create_avatar/migration.sql">
/*
  Warnings:

  - You are about to drop the column `avatar_url` on the `users` table. All the data in the column will be lost.
  - A unique constraint covering the columns `[avatar_id]` on the table `users` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "users" DROP COLUMN "avatar_url",
ADD COLUMN     "avatar_id" TEXT;

-- CreateTable
CREATE TABLE "avatars" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "url" TEXT NOT NULL,

    CONSTRAINT "avatars_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_avatar_id_key" ON "users"("avatar_id");

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_avatar_id_fkey" FOREIGN KEY ("avatar_id") REFERENCES "avatars"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250603023156_user_avatar/migration.sql">
-- AlterTable
ALTER TABLE "avatars" ADD COLUMN     "user_id" TEXT;
</file>

<file path="prisma/migrations/20250609231405_address_and_client/migration.sql">
-- AlterTable
ALTER TABLE "avatars" ADD COLUMN     "client_id" TEXT;

-- CreateTable
CREATE TABLE "Address" (
    "id" TEXT NOT NULL,
    "street" TEXT NOT NULL,
    "number" TEXT NOT NULL,
    "complement" TEXT,
    "neighborhood" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "zip_code" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "user_id" TEXT,
    "client_id" TEXT,

    CONSTRAINT "Address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Client" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "avatar_id" TEXT,

    CONSTRAINT "Client_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Client_email_key" ON "Client"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Client_avatar_id_key" ON "Client"("avatar_id");

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "Client"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Client" ADD CONSTRAINT "Client_avatar_id_fkey" FOREIGN KEY ("avatar_id") REFERENCES "avatars"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250611140449_audit_log/migration.sql">
/*
  Warnings:

  - You are about to drop the `Address` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Client` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "ActorType" AS ENUM ('USER', 'CLIENT');

-- DropForeignKey
ALTER TABLE "Address" DROP CONSTRAINT "Address_client_id_fkey";

-- DropForeignKey
ALTER TABLE "Address" DROP CONSTRAINT "Address_user_id_fkey";

-- DropForeignKey
ALTER TABLE "Client" DROP CONSTRAINT "Client_avatar_id_fkey";

-- DropTable
DROP TABLE "Address";

-- DropTable
DROP TABLE "Client";

-- CreateTable
CREATE TABLE "address" (
    "id" TEXT NOT NULL,
    "street" TEXT NOT NULL,
    "number" TEXT NOT NULL,
    "complement" TEXT,
    "neighborhood" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "zip_code" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "user_id" TEXT,
    "client_id" TEXT,

    CONSTRAINT "address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "clients" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "avatar_id" TEXT,

    CONSTRAINT "clients_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "audit_logs" (
    "id" TEXT NOT NULL,
    "actor_id" TEXT NOT NULL,
    "actor_type" "ActorType" NOT NULL,
    "action" TEXT NOT NULL,
    "entity" TEXT NOT NULL,
    "entity_id" TEXT NOT NULL,
    "changes" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "clients_email_key" ON "clients"("email");

-- CreateIndex
CREATE UNIQUE INDEX "clients_avatar_id_key" ON "clients"("avatar_id");

-- CreateIndex
CREATE INDEX "audit_logs_actor_id_idx" ON "audit_logs"("actor_id");

-- CreateIndex
CREATE INDEX "audit_logs_entity_entity_id_idx" ON "audit_logs"("entity", "entity_id");

-- AddForeignKey
ALTER TABLE "address" ADD CONSTRAINT "address_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "address" ADD CONSTRAINT "address_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "clients"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "clients" ADD CONSTRAINT "clients_avatar_id_fkey" FOREIGN KEY ("avatar_id") REFERENCES "avatars"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/seed.ts">
import { PrismaClient } from "@prisma/client"
import { hash } from "bcryptjs"

const prisma = new PrismaClient()

async function main() {
  const adminEmail = 'fellipefreiire3@gmail.com'

  const existing = await prisma.user.findUnique({
    where: { email: adminEmail }
  })

  if (existing) {
    console.log('Admin user already exists.')
    return
  }

  const passwordHash = await hash('123456', 8)

  await prisma.user.create({
    data: {
      name: 'Felipe Freire',
      email: adminEmail,
      passwordHash,
      role: 'ADMIN',
      isActive: true,
    }
  })

  console.log('‚úÖ Admin user created.')
}

main()
  .catch(e => {
    console.error(e)
    process.exit(1)
  })
  .finally(() => {
    prisma.$disconnect()
  })
</file>

<file path="src/core/entities/aggregate-root.ts">
import { DomainEvent } from '../events/domain-event'
import { DomainEvents } from '../events/domain-events'
import { Entity } from './entity'

export abstract class AggregateRoot<Props> extends Entity<Props> {
  private _domainEvents: DomainEvent[] = []

  get domainEvents(): DomainEvent[] {
    return this._domainEvents
  }

  protected addDomainEvent(domainEvent: DomainEvent): void {
    this._domainEvents.push(domainEvent)
    DomainEvents.markAggregateForDispatch(this)
  }

  public clearEvents(): void {
    this._domainEvents = []
  }
}
</file>

<file path="src/core/entities/entity.ts">
import { UniqueEntityID } from './unique-entity-id'

export abstract class Entity<Props> {
  private _id: UniqueEntityID
  protected props: Props

  get id() {
    return this._id
  }

  protected constructor(props: Props, id?: UniqueEntityID) {
    this.props = props
    this._id = id ?? new UniqueEntityID()
  }

  public equals(entity: Entity<unknown>) {
    if (entity === this) {
      return true
    }

    if (entity.id === this._id) {
      return true
    }

    return false
  }
}
</file>

<file path="src/core/entities/unique-entity-id.ts">
import { randomUUID } from 'crypto'

export class UniqueEntityID {
  private value: string

  toString() {
    return this.value
  }

  toValue() {
    return this.value
  }

  constructor(value?: string) {
    this.value = value ?? randomUUID()
  }

  public equals(id: UniqueEntityID) {
    return id.toValue() === this.value
  }
}
</file>

<file path="src/core/entities/value-object.ts">
export abstract class ValueObject<Props> {
  protected props: Props

  protected constructor(props: Props) {
    this.props = props
  }

  public equals(vo: ValueObject<unknown>) {
    if (vo === null || vo === undefined) {
      return false
    }

    if (vo.props === undefined) {
      return false
    }

    return JSON.stringify(vo.props) === JSON.stringify(this.props)
  }
}
</file>

<file path="src/core/entities/watched-list.spec.ts">
import { WatchedList } from '@/core/entities/watched-list'

class NumberWatchedList extends WatchedList<number> {
  compareItems(a: number, b: number): boolean {
    return a === b
  }
}

describe('watched list', () => {
  it('should be able to create a watched list with initial items', () => {
    const list = new NumberWatchedList([1, 2, 3])

    expect(list.currentItems).toHaveLength(3)
  })

  it('should be able to add new items to the list', () => {
    const list = new NumberWatchedList([1, 2, 3])

    list.add(4)

    expect(list.currentItems).toHaveLength(4)
    expect(list.getNewItems()).toEqual([4])
  })

  it('should be able to remove items from the list', () => {
    const list = new NumberWatchedList([1, 2, 3])

    list.remove(2)

    expect(list.currentItems).toHaveLength(2)
    expect(list.getRemovedItems()).toEqual([2])
  })

  it('should be able to add an item even if it was removed before', () => {
    const list = new NumberWatchedList([1, 2, 3])

    list.remove(2)
    list.add(2)

    expect(list.currentItems).toHaveLength(3)

    expect(list.getRemovedItems()).toEqual([])
    expect(list.getNewItems()).toEqual([])
  })

  it('should be able to remove an item even if it was added before', () => {
    const list = new NumberWatchedList([1, 2, 3])

    list.add(4)
    list.remove(4)

    expect(list.currentItems).toHaveLength(3)

    expect(list.getRemovedItems()).toEqual([])
    expect(list.getNewItems()).toEqual([])
  })

  it('should be able to update watched list items', () => {
    const list = new NumberWatchedList([1, 2, 3])

    list.update([1, 3, 5])

    expect(list.getRemovedItems()).toEqual([2])
    expect(list.getNewItems()).toEqual([5])
  })
})
</file>

<file path="src/core/errors/generic-error/index.ts">
import { BaseError } from '../use-case-error'

export class GenericUseCaseError extends BaseError {
  constructor(message = 'An unexpected error occurred') {
    super(message, 'GenericUseCaseError')
  }
}
</file>

<file path="src/core/errors/not-allowed-error/index.ts">
import { BaseError } from '../use-case-error'

export class NotAllowedError extends BaseError {
  constructor(message = 'Not allowed') {
    super(message, 'NotAllowedError')
  }
}
</file>

<file path="src/core/errors/resource-not-found-error/index.ts">
import { BaseError } from '../use-case-error'

export class ResourceNotFoundError extends BaseError {
  constructor(message = 'Resource not found') {
    super(message, 'ResourceNotFoundError')
  }
}
</file>

<file path="src/core/errors/use-case-error.ts">
export interface UseCaseError {
  name: string
  message: string
}

export abstract class BaseError extends Error implements UseCaseError {
  constructor(message: string, name: string) {
    super(message)
    this.name = name
  }
}
</file>

<file path="src/core/events/domain-events.ts">
import { AggregateRoot } from '../entities/aggregate-root'
import { UniqueEntityID } from '../entities/unique-entity-id'
import { DomainEvent } from './domain-event'

type DomainEventCallback = (event: unknown) => void

export class DomainEvents {
  private static handlersMap: Record<string, DomainEventCallback[]> = {}
  private static markedAggregates: AggregateRoot<unknown>[] = []

  public static shouldRun = true

  public static markAggregateForDispatch(aggregate: AggregateRoot<unknown>) {
    const aggregateFound = !!this.findMarkedAggregateByID(aggregate.id)

    if (!aggregateFound) {
      this.markedAggregates.push(aggregate)
    }
  }

  private static dispatchAggregateEvents(aggregate: AggregateRoot<unknown>) {
    aggregate.domainEvents.forEach((event: DomainEvent) => this.dispatch(event))
  }

  private static removeAggregateFromMarkedDispatchList(
    aggregate: AggregateRoot<unknown>,
  ) {
    const index = this.markedAggregates.findIndex((a) => a.equals(aggregate))

    this.markedAggregates.splice(index, 1)
  }

  private static findMarkedAggregateByID(
    id: UniqueEntityID,
  ): AggregateRoot<unknown> | undefined {
    return this.markedAggregates.find((aggregate) => aggregate.id.equals(id))
  }

  public static dispatchEventsForAggregate(id: UniqueEntityID) {
    const aggregate = this.findMarkedAggregateByID(id)

    if (aggregate) {
      this.dispatchAggregateEvents(aggregate)
      aggregate.clearEvents()
      this.removeAggregateFromMarkedDispatchList(aggregate)
    }
  }

  public static register(
    callback: DomainEventCallback,
    eventClassName: string,
  ) {
    const wasEventRegisteredBefore = eventClassName in this.handlersMap

    if (!wasEventRegisteredBefore) {
      this.handlersMap[eventClassName] = []
    }

    this.handlersMap[eventClassName].push(callback)
  }

  public static clearHandlers() {
    this.handlersMap = {}
  }

  public static clearMarkedAggregates() {
    this.markedAggregates = []
  }

  private static dispatch(event: DomainEvent) {
    const eventClassName: string = event.constructor.name

    const isEventRegistered = eventClassName in this.handlersMap

    if (!this.shouldRun) {
      return
    }

    if (isEventRegistered) {
      const handlers = this.handlersMap[eventClassName]

      for (const handler of handlers) {
        handler(event)
      }
    }
  }
}
</file>

<file path="src/core/events/event-handler.ts">
export interface EventHandler {
  setupSubscriptions(): void
}
</file>

<file path="src/core/types/optional.ts">
/**
 * Make some property optional on type
 *
 * @example
 * ```typescript
 * type Post {
 *  id: string
 *  name: string
 *  email: string
 * }
 *
 * Optional<Post, 'id' | 'email'>
 * ```
 **/

export type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>
</file>

<file path="src/core/either.spec.ts">
import { Either, left, right } from './either'

function doSomething(shouldSuccess: boolean): Either<string, number> {
  if (shouldSuccess) {
    return right(10)
  }
  return left('error')
}

test('success', () => {
  const result = doSomething(true)

  if (result.isRight()) {
    console.log(result.value)
  }

  expect(result.isRight()).toBe(true)
  expect(result.isLeft()).toBe(false)
})

test('error', () => {
  const result = doSomething(false)

  expect(result.isRight()).toBe(false)
  expect(result.isLeft()).toBe(true)
})
</file>

<file path="src/core/either.ts">
// Error
export class Left<L, R> {
  readonly value: L
  constructor(value: L) {
    this.value = value
  }

  isRight(): this is Right<L, R> {
    return false
  }

  isLeft(): this is Left<L, R> {
    return true
  }
}

// Success
export class Right<L, R> {
  readonly value: R
  constructor(value: R) {
    this.value = value
  }

  isRight(): this is Right<L, R> {
    return true
  }

  isLeft(): this is Left<L, R> {
    return false
  }
}

export type Either<L, R> = Left<L, R> | Right<L, R>

export const left = <L, R>(value: L): Either<L, R> => {
  return new Left(value)
}

export const right = <L, R>(value: R): Either<L, R> => {
  return new Right(value)
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-active-status-changed.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { OnUserActiveStatusChanged } from '@/domain/audit-log/application/subscribers/user/on-user-active-status-changed'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Active Status Changed (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserActiveStatusChanged(createAuditLogUseCase)
  })

  it('should create audit log when user active status is changed', async () => {
    const actorId = new UniqueEntityID('admin-id')
    const user = makeUser({ isActive: true }, new UniqueEntityID('user-id'))

    inMemoryUsersRepository.create(user)

    user.toggleActive(actorId.toString())
    inMemoryUsersRepository.save(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: 'admin-id',
        action: 'user:active_status_updated',
        entityId: 'user-id',
        changes: {
          isActive: {
            before: true,
            after: false,
          },
        },
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-created.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { OnUserCreated } from '@/domain/audit-log/application/subscribers/user/on-user-created'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Created (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserCreated(createAuditLogUseCase)
  })

  it('should create audit log when user is created', async () => {
    const user = makeUser(
      {
        name: 'John Doe',
        email: 'john@example.com',
        role: 'MANAGER',
      },
      undefined,
      new UniqueEntityID('creator-id'),
    )

    inMemoryUsersRepository.create(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: 'creator-id',
        action: 'user:created',
        entityId: user.id.toString(),
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-logged-out.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { OnUserLoggedOut } from '@/domain/audit-log/application/subscribers/user/on-user-logged-out'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Logged Out (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserLoggedOut(createAuditLogUseCase)
  })

  it('should create audit log when user logs out', async () => {
    const user = makeUser()
    inMemoryUsersRepository.create(user)

    user.logout()
    inMemoryUsersRepository.dispatchEvent(user.id)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:logged_out',
        entity: 'USER',
        entityId: user.id.toString(),
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-reset-password.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { OnUserResetPassword } from '@/domain/audit-log/application/subscribers/user/on-user-reset-password'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Reset Password (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserResetPassword(createAuditLogUseCase)
  })

  it('should create audit log when user resets password', async () => {
    const user = makeUser()
    inMemoryUsersRepository.create(user)

    user.resetPassword('password-hashed')
    inMemoryUsersRepository.save(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:reset_password',
        entity: 'USER',
        entityId: user.id.toString(),
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-role-changed.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { OnUserRoleChanged } from '@/domain/audit-log/application/subscribers/user/on-user-role-changed'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Role Changed (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserRoleChanged(createAuditLogUseCase)
  })

  it('should create audit log when user role is changed', async () => {
    const adminUser = makeUser({ role: 'ADMIN' })
    const user = makeUser({ role: 'OPERATOR' })

    inMemoryUsersRepository.create(user)

    user.updateRole('MANAGER', adminUser.id.toString())
    inMemoryUsersRepository.save(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: adminUser.id.toString(),
        action: 'user:role_updated',
        changes: {
          role: {
            before: 'OPERATOR',
            after: 'MANAGER',
          },
        },
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-updated.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { OnUserUpdated } from '@/domain/audit-log/application/subscribers/user/on-user-updated'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Address } from '@/shared/address/enterprise/entities/address'
import { UserAddressList } from '@/domain/user/enterprise/entities/user-address-list'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Updated (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserUpdated(createAuditLogUseCase)
  })

  it('should create audit log when user is updated', async () => {
    const userId = new UniqueEntityID('user-id')

    const user = makeUser(
      {
        name: 'Old Name',
        avatarId: new UniqueEntityID('old-avatar'),
        addresses: [
          Address.create({
            street: 'Rua Antiga',
            number: '999',
            complement: null,
            neighborhood: 'Bairro Antigo',
            city: 'Cidade Velha',
            state: 'RJ',
            zipCode: '00000-000',
            userId,
          }),
        ],
      },
      userId,
    )

    inMemoryUsersRepository.create(user)

    user.update({
      name: 'New Name',
      avatarId: new UniqueEntityID('new-avatar'),
      addresses: new UserAddressList([
        Address.create({
          street: 'Rua Nova',
          number: '123',
          complement: null,
          neighborhood: 'Centro',
          city: 'S√£o Paulo',
          state: 'SP',
          zipCode: '12345-678',
          userId,
        }),
      ]),
    })

    inMemoryUsersRepository.save(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: 'user-id',
        action: 'user:updated',
        entityId: 'user-id',
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-active-status-changed.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserActiveStatusChangedEvent } from '@/domain/user/enterprise/events/user-active-status-changed-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserActiveStatusChanged implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(
      this.handle.bind(this),
      UserActiveStatusChangedEvent.name,
    )
  }

  async handle(event: UserActiveStatusChangedEvent): Promise<void> {
    const { user, previousIsActive, actorId } = event

    await this.createAuditLog.execute({
      actorId,
      actorType: 'USER',
      action: 'user:active_status_updated',
      entity: 'USER',
      entityId: user.id.toString(),
      changes: {
        isActive: {
          before: previousIsActive,
          after: user.isActive,
        },
      },
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-logged-out.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserLoggedOutEvent } from '@/domain/user/enterprise/events/user-logged-out-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserLoggedOut implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserLoggedOutEvent.name)
  }

  async handle(event: UserLoggedOutEvent): Promise<void> {
    const user = event.user

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:logged_out',
      entity: 'USER',
      entityId: user.id.toString(),
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-requested-password-reset.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { UserRequestedPasswordResetEvent } from '@/domain/user/enterprise/events/user-request-password-reset-event'

@Injectable()
export class OnUserRequestedPasswordReset implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(
      this.handle.bind(this),
      UserRequestedPasswordResetEvent.name,
    )
  }

  async handle(event: UserRequestedPasswordResetEvent): Promise<void> {
    const user = event.user

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:requested_password_reset',
      entity: 'USER',
      entityId: user.id.toString(),
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-reset-password.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserResetPasswordEvent } from '@/domain/user/enterprise/events/user-reset-password-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserResetPassword implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserResetPasswordEvent.name)
  }

  async handle(event: UserResetPasswordEvent): Promise<void> {
    const user = event.user

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:reset_password',
      entity: 'USER',
      entityId: user.id.toString(),
    })
  }
}
</file>

<file path="src/domain/audit-log/application/use-cases/__tests__/create-audit-log.spec.ts">
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { beforeEach, describe, expect, it } from 'vitest'
import { CreateAuditLogUseCase } from '../create-audit-log'

let sut: CreateAuditLogUseCase
let auditLogRepository: InMemoryAuditLogRepository

describe('Create Audit Log Use Case', () => {
  beforeEach(() => {
    auditLogRepository = new InMemoryAuditLogRepository()
    sut = new CreateAuditLogUseCase(auditLogRepository)
  })

  it('should create a new audit log entry', async () => {
    const result = await sut.execute({
      actorId: 'user-1',
      actorType: 'USER',
      action: 'user:password_changed',
      entity: 'USER',
      entityId: 'user-1',
      changes: { passwordChanged: true },
    })

    expect(result.isRight()).toBe(true)
    expect(auditLogRepository.items).toHaveLength(1)
    expect(auditLogRepository.items[0].action).toBe('user:password_changed')
    expect(auditLogRepository.items[0].changes).toEqual({
      passwordChanged: true,
    })
  })
})
</file>

<file path="src/domain/audit-log/application/use-cases/__tests__/list-audit-logs.spec.ts">
import { ListAuditLogsUseCase } from '@/domain/audit-log/application/use-cases/list-audit-logs'
import { makeAuditLog } from 'test/factories/make-audit-log'
import { makeUser } from 'test/factories/make-user'
import { ActorType } from '@prisma/client'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'

describe('List Audit Logs Use Case', () => {
  let auditLogRepository: InMemoryAuditLogRepository
  let usersRepository: InMemoryUsersRepository
  let sut: ListAuditLogsUseCase

  beforeEach(() => {
    usersRepository = new InMemoryUsersRepository()
    auditLogRepository = new InMemoryAuditLogRepository(usersRepository)
    sut = new ListAuditLogsUseCase(auditLogRepository, usersRepository)
  })

  it('should list audit logs by actorType', async () => {
    const user = makeUser({ role: 'ADMIN' })
    await usersRepository.create(user)

    const log1 = makeAuditLog({
      actorId: user.id.toString(),
      actorType: ActorType.USER,
    })
    const log2 = makeAuditLog({
      actorId: user.id.toString(),
      actorType: ActorType.USER,
    })
    const logOther = makeAuditLog({
      actorId: 'some-id',
      actorType: ActorType.CLIENT,
    })

    await auditLogRepository.create(log1)
    await auditLogRepository.create(log2)
    await auditLogRepository.create(logOther)

    const result = await sut.execute({
      params: { actorType: ActorType.USER },
      cursorParams: { limit: 10 },
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      const { data, meta } = result.value

      expect(data).toHaveLength(2)
      expect(meta.count).toBe(2)

      expect(data.every((log) => log.actorName === user.name)).toBe(true)
      expect(data.every((log) => log.actorEmail === user.email)).toBe(true)
      expect(data.every((log) => log.actorType === ActorType.USER)).toBe(true)
    }
  })

  it('should return empty array if actorEmail does not resolve to any user', async () => {
    const user = makeUser({ email: 'existent@example.com' })
    await usersRepository.create(user)

    const log = makeAuditLog({
      actorId: user.id.toString(),
      actorType: ActorType.USER,
    })

    await auditLogRepository.create(log)

    const result = await sut.execute({
      params: {
        actorType: ActorType.USER,
        actorEmail: 'nonexistent@example.com',
      },
      cursorParams: {
        limit: 10,
      },
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      const { data, meta } = result.value

      expect(data).toHaveLength(0)
      expect(meta.count).toBe(0)
      expect(meta.hasNextPage).toBe(false)
    }
  })

  it('should resolve actorEmail into actorId and return correct logs', async () => {
    const user = makeUser({ email: 'admin@email.com' })
    await usersRepository.create(user)

    const log = makeAuditLog({
      actorId: user.id.toString(),
      actorType: ActorType.USER,
    })
    await auditLogRepository.create(log)

    const result = await sut.execute({
      params: {
        actorType: ActorType.USER,
        actorEmail: user.email,
      },
      cursorParams: {
        limit: 10,
      },
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      const { data, meta } = result.value

      expect(data).toHaveLength(1)
      expect(meta.count).toBe(1)

      expect(data[0].actorEmail).toBe(user.email)
      expect(data[0].actorName).toBe(user.name)
    }
  })
})
</file>

<file path="src/domain/audit-log/application/use-cases/list-audit-logs.ts">
import { Injectable } from '@nestjs/common'
import { type Either, right } from '@/core/either'
import type {
  CursorPaginationParams,
  CursorPaginationMeta,
} from '@/core/repositories/pagination-params'
import { AuditLog } from '../../enterprise/entities/audit-log'
import {
  AuditLogRepository,
  ListAuditLogsFilters,
} from '../repositories/audit-log-repository'
import { ActorType } from '@prisma/client'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'

type ListAuditLogsUseCaseRequest = {
  params: ListAuditLogsFilters
  cursorParams: CursorPaginationParams
}

type AuditLogWithActorInfo = AuditLog & {
  actorName: string
  actorEmail: string
}

type ListAuditLogsUseCaseResponse = Either<
  null,
  {
    data: AuditLogWithActorInfo[]
    meta: CursorPaginationMeta
  }
>

@Injectable()
export class ListAuditLogsUseCase {
  constructor(
    private auditLogsRepository: AuditLogRepository,
    private usersRepository: UsersRepository,
    // private clientsRepository: ClientsRepository,
  ) {}

  async execute({
    params,
    cursorParams,
  }: ListAuditLogsUseCaseRequest): Promise<ListAuditLogsUseCaseResponse> {
    const {
      actorType,
      actorId: filterActorId,
      actorEmail,
      entity,
      action,
      entityId,
      startDate,
      endDate,
    } = params

    let actorId = filterActorId

    if (!actorId && actorEmail) {
      actorId = await this.auditLogsRepository.resolveActorIdByEmail(
        actorType,
        actorEmail,
      )

      if (!actorId) {
        return right({
          data: [],
          meta: {
            count: 0,
            hasNextPage: false,
            nextCursor: null,
          },
        })
      }
    }

    const [logs, hasNextPage] = await this.auditLogsRepository.findMany(
      {
        actorType,
        actorId,
        entity,
        action,
        entityId,
        startDate,
        endDate,
      },
      cursorParams,
    )

    const userIds = logs
      .filter((log) => log.actorType === ActorType.USER)
      .map((log) => log.actorId)

    const uniqueUserIds = [...new Set(userIds)]
    const users = await this.usersRepository.findManyByIds(uniqueUserIds)
    const usersMap = new Map(users.map((user) => [user.id.toString(), user]))

    const logsWithActors: AuditLogWithActorInfo[] = logs.map((log) => {
      let actorName = '[unknown]'
      let actorEmail = '[unknown]'

      if (log.actorType === ActorType.USER) {
        const user = usersMap.get(log.actorId)
        if (user) {
          actorName = user.name
          actorEmail = user.email
        }
      }

      // se no futuro quiser CLIENT, basta expandir aqui

      const extended = Object.assign(
        Object.create(Object.getPrototypeOf(log)),
        log,
      ) as AuditLogWithActorInfo

      extended.actorName = actorName
      extended.actorEmail = actorEmail

      return extended
    })

    return right({
      data: logsWithActors,
      meta: {
        count: logs.length,
        hasNextPage,
        nextCursor: hasNextPage ? logs[logs.length - 1].id.toString() : null,
      },
    })
  }
}
</file>

<file path="src/domain/audit-log/enterprise/entities/audit-log.ts">
import { Entity } from '@/core/entities/entity'
import { Optional } from '@/core/types/optional'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export type ActorType = 'USER' | 'CLIENT'

export interface AuditLogProps {
  actorId: string
  actorType: ActorType
  action: string
  entity: string
  entityId: string
  changes?: Record<string, unknown> | null
  createdAt: Date
}

export class AuditLog extends Entity<AuditLogProps> {
  get actorId() {
    return this.props.actorId
  }

  get actorType() {
    return this.props.actorType
  }

  get action() {
    return this.props.action
  }

  get entity() {
    return this.props.entity
  }

  get entityId() {
    return this.props.entityId
  }

  get changes() {
    return this.props.changes
  }

  get createdAt() {
    return this.props.createdAt
  }

  static create(
    props: Optional<AuditLogProps, 'createdAt'>,
    id?: UniqueEntityID,
  ) {
    return new AuditLog(
      {
        ...props,
        createdAt: props.createdAt ?? new Date(),
      },
      id,
    )
  }
}
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user-status.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserStatusUseCase } from '../edit-user-status'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: EditUserStatusUseCase

describe('Activate User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new EditUserStatusUseCase(inMemoryUsersRepository)
  })

  it('should be able to activate a user', async () => {
    const user = makeUser(
      {
        email: 'johndoe@example.com',
        isActive: true,
      },
      new UniqueEntityID('user-1'),
    )

    const isActive = !user.isActive

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: user.id.toString(),
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        isActive,
      }),
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/find-user-by-id.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { FindUserByIdUseCase } from '../find-user-by-id'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserNotFoundError } from '../errors/user-not-found'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: FindUserByIdUseCase

describe('Find User By Id', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new FindUserByIdUseCase(inMemoryUsersRepository)
  })

  it('should be able to find a user by id', async () => {
    const user = makeUser({}, new UniqueEntityID('user-1'))

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: 'user-1',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        name: user.name,
        email: user.email,
      }),
    })
  })

  it('should not be able to find a non-existing user', async () => {
    const result = await sut.execute({
      id: 'user-2',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/errors/index.ts">
export * from './user-already-exists-error'
export * from './user-not-found'
</file>

<file path="src/domain/user/application/use-cases/errors/invalid-role-transition-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class InvalidRoleTransitionError extends BaseError {
  constructor(message = 'You cannot change roles') {
    super(message, 'InvalidRoleTransitionError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-already-exists-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserAlreadyExistsError extends BaseError {
  constructor(identifier: string) {
    super(`User ${identifier} already exists`, 'UserAlreadyExistsError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-inactive-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserInactiveError extends BaseError {
  constructor(message = 'User inactive') {
    super(message, 'UserInactiveError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-not-found.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserNotFoundError extends BaseError {
  constructor(message = 'User not found') {
    super(message, 'UserNotFoundError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-unauthorized-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserUnauthorizedError extends BaseError {
  constructor(message = 'Unauthorized') {
    super(message, 'UserUnauthorizedError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/wrong-credentials-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class WrongCredentialsError extends BaseError {
  constructor(message = 'Credentials are not valid.') {
    super(message, 'WrongCredentialsError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/find-user-by-email.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'
import { UserNotFoundError } from './errors/user-not-found'

type FindUserByEmailUseCaseRequest = {
  email: string
}

type FindUserByEmailUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class FindUserByEmailUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    email,
  }: FindUserByEmailUseCaseRequest): Promise<FindUserByEmailUseCaseResponse> {
    const user = await this.usersRepository.findByEmail(email)

    if (!user) {
      return left(new UserNotFoundError())
    }

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/find-user-by-id.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'
import { UserNotFoundError } from './errors/user-not-found'

type FindUserByIdUseCaseRequest = {
  id: string
}

type FindUserByIdUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class FindUserByIdUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
  }: FindUserByIdUseCaseRequest): Promise<FindUserByIdUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/user-avatar-watcher.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserAvatarWatcher {
  private current: UniqueEntityID | null
  private updated: UniqueEntityID | null

  constructor(current: UniqueEntityID | null) {
    this.current = current
    this.updated = current
  }

  update(newAvatarId: UniqueEntityID | null): void {
    this.updated = newAvatarId
  }

  hasChanged(): boolean {
    return this.current?.toString() !== this.updated?.toString()
  }

  getUpdatedId(): UniqueEntityID | null {
    return this.updated
  }
}
</file>

<file path="src/domain/user/enterprise/entities/user-address.ts">
import { Entity } from '@/core/entities/entity'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export interface UserAddressProps {
  userId: UniqueEntityID
  addressId: UniqueEntityID
}

export class UserAddress extends Entity<UserAddressProps> {
  get userId() {
    return this.props.userId
  }

  get addressId() {
    return this.props.addressId
  }

  static create(props: UserAddressProps, id?: UniqueEntityID) {
    const userAddress = new UserAddress(props, id)

    return userAddress
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-logged-in-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import { User } from '../entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserLoggedInEvent implements DomainEvent {
  public occurredAt: Date
  public user: User

  constructor(user: User) {
    this.user = user
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-logged-out-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import { User } from '../entities/user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserLoggedOutEvent implements DomainEvent {
  public occurredAt: Date
  public user: User

  constructor(user: User) {
    this.user = user
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-request-password-reset-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import { User } from '../entities/user'
import { type UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserRequestedPasswordResetEvent implements DomainEvent {
  public occurredAt: Date
  public user: User

  constructor(user: User) {
    this.user = user
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-reset-password-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import { User } from '../entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserResetPasswordEvent implements DomainEvent {
  public occurredAt: Date
  public user: User

  constructor(user: User) {
    this.user = user
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/infra/auth/casl/handlers/user-can-read-self.handler.ts">
import type { ExecutionContext } from '@nestjs/common'
import type { Role } from '@prisma/client'
import type { PolicyHandler } from '../check-policies.decorator'

export const userCanReadSelfHandler: PolicyHandler = (
  ability,
  context: ExecutionContext,
) => {
  const req = context.switchToHttp().getRequest()

  const targetUserId = req.params.id as string

  const subject = {
    sub: targetUserId,
    role: '' as Role,
    __typename: 'User' as const,
  }

  return ability.can('read', subject)
}
</file>

<file path="src/infra/auth/casl/handlers/user-can-update-self.handler.ts">
import type { ExecutionContext } from '@nestjs/common'
import type { Role } from '@prisma/client'
import type { PolicyHandler } from '../check-policies.decorator'

export const userCanUpdateSelfHandler: PolicyHandler = (
  ability,
  context: ExecutionContext,
) => {
  const req = context.switchToHttp().getRequest()

  const targetUserId = req.params.id as string

  const subject = {
    sub: targetUserId,
    role: '' as Role,
    __typename: 'User' as const,
  }

  return ability.can('update', subject)
}
</file>

<file path="src/infra/auth/casl/models/audit-log.ts">
import { z } from 'zod'

import { roleSchema } from '../roles'

export const auditLogSchema = z.object({
  sub: z.string(),
  role: roleSchema,
  __typename: z.literal('AuditLog').default('AuditLog'),
})

export type AuditLog = z.infer<typeof auditLogSchema>
</file>

<file path="src/infra/auth/casl/subjects/audit-log.ts">
import { z } from 'zod'
import { auditLogSchema } from '../models/audit-log'

export const auditLogSubject = z.tuple([
  z.union([z.literal('manage'), z.literal('list')]),
  z.union([z.literal('AuditLog'), auditLogSchema]),
])

export type AuditLogSubject = z.infer<typeof auditLogSubject>
</file>

<file path="src/infra/auth/casl/subjects/avatar.ts">
import { z } from 'zod'
import { avatarSchema } from '../models/avatar'

export const avatarSubject = z.tuple([
  z.union([z.literal('manage'), z.literal('create')]),
  z.union([z.literal('Avatar'), avatarSchema]),
])

export type AvatarSubject = z.infer<typeof avatarSubject>
</file>

<file path="src/infra/auth/casl/casl-ability.module.ts">
import { Module } from '@nestjs/common'
import { CaslAbilityFactory } from './ability.factory'

@Module({
  providers: [CaslAbilityFactory],
  exports: [CaslAbilityFactory],
})
export class CaslAbilityModule {}
</file>

<file path="src/infra/auth/casl/roles.ts">
import { z } from 'zod'

export const roleSchema = z.union([
  z.literal('ADMIN'),
  z.literal('MANAGER'),
  z.literal('SUPERVISOR'),
  z.literal('OPERATOR'),
])

export type Role = z.infer<typeof roleSchema>
</file>

<file path="src/infra/auth/current-user.decorator.ts">
import { ExecutionContext, createParamDecorator } from '@nestjs/common'
import { UserPayload } from './jwt.strategy'

export const CurrentUser = createParamDecorator(
  (_: never, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest()

    return request.user as UserPayload
  },
)
</file>

<file path="src/infra/auth/jwt-auth.guard.ts">
import { Injectable, type ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { AuthGuard } from '@nestjs/passport'
import { IS_PUBLIC_KEY } from './public'

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super()
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    if (isPublic) {
      return true
    }

    return super.canActivate(context)
  }
}
</file>

<file path="src/infra/auth/public.ts">
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)
</file>

<file path="src/infra/cryptography/bcrypt-hasher.ts">
import { HashComparer } from '@/shared/cryptography/hash-comparer'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import { hash, compare } from 'bcryptjs'

export class BcryptHasher implements HashGenerator, HashComparer {
  private HASH_SALT_LENGTH = 8

  hash(plain: string): Promise<string> {
    return hash(plain, this.HASH_SALT_LENGTH)
  }

  compare(plain: string, hash: string): Promise<boolean> {
    return compare(plain, hash)
  }
}
</file>

<file path="src/infra/cryptography/jwt-verifier.ts">
import { Injectable } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { TokenVerifier } from '@/shared/cryptography/token-verifier'

@Injectable()
export class JwtVerifier implements TokenVerifier {
  constructor(private jwt: JwtService) {}

  verify<T extends object = Record<string, unknown>>(token: string): T {
    return this.jwt.verify<T>(token)
  }
}
</file>

<file path="src/infra/database/prisma/mappers/avatar/prisma-avatar.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'
import { Avatar as PrismaAvatar, Prisma } from '@prisma/client'

export class PrismaAvatarMapper {
  static toDomain(raw: PrismaAvatar): Avatar {
    return Avatar.create(
      {
        title: raw.title,
        url: raw.url,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(avatar: Avatar): Prisma.AvatarCreateInput {
    return {
      id: avatar.id.toString(),
      title: avatar.title,
      url: avatar.url,
    }
  }
}
</file>

<file path="src/infra/database/prisma/repositories/audit-log/audit-log-database.module.ts">
import { Module } from '@nestjs/common'
import { PrismaAuditLogRepository } from './prisma-audit-log.repository'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { AuditLogRepository } from '@/domain/audit-log/application/repositories/audit-log-repository'

@Module({
  providers: [
    PrismaService,
    {
      provide: AuditLogRepository,
      useClass: PrismaAuditLogRepository,
    },
  ],
  exports: [PrismaService, AuditLogRepository],
})
export class AuditLogDatabaseModule {}
</file>

<file path="src/infra/database/prisma/repositories/avatar/avatar-database.module.ts">
import { Module } from '@nestjs/common'
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { PrismaAvatarRepository } from './prisma-avatar-repository'
import { PrismaService } from '../../prisma.service'

@Module({
  providers: [
    PrismaService,
    {
      provide: AvatarRepository,
      useClass: PrismaAvatarRepository,
    },
  ],
  exports: [PrismaService, AvatarRepository],
})
export class AvatarDatabaseModule {}
</file>

<file path="src/infra/database/prisma/repositories/avatar/prisma-avatar-repository.ts">
import { Injectable } from '@nestjs/common'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { PrismaService } from '../../prisma.service'
import { PrismaAvatarMapper } from '../../mappers/avatar/prisma-avatar.mapper'

@Injectable()
export class PrismaAvatarRepository implements AvatarRepository {
  constructor(private prisma: PrismaService) {}

  async findById(id: string) {
    const data = await this.prisma.avatar.findUnique({
      where: { id },
    })

    if (!data) {
      return null
    }

    return PrismaAvatarMapper.toDomain(data)
  }

  async create(avatar: Avatar) {
    const data = PrismaAvatarMapper.toPrisma(avatar)

    await this.prisma.avatar.create({
      data,
    })
  }

  async delete(id: string) {
    await this.prisma.avatar.delete({
      where: {
        id,
      },
    })
  }
}
</file>

<file path="src/infra/database/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common'
import { PrismaService } from './prisma.service'

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
</file>

<file path="src/infra/database/prisma/prisma.service.ts">
import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { PrismaClient } from '@prisma/client'

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    super({
      log: ['warn', 'error'],
    })
  }

  onModuleInit() {
    return this.$connect()
  }

  onModuleDestroy() {
    return this.$disconnect()
  }
}
</file>

<file path="src/infra/decorators/service-tag.decorator.ts">
// src/infra/decorators/service-tag.decorator.ts
import { SetMetadata } from '@nestjs/common'
export const SERVICE_TAG = 'SERVICE_TAG'
export const ServiceTag = (tag: string) => SetMetadata(SERVICE_TAG, tag)
</file>

<file path="src/infra/env/env.module.ts">
import { Module } from '@nestjs/common'
import { EnvService } from './env.service'

@Module({
  providers: [EnvService],
  exports: [EnvService],
})
export class EnvModule {}
</file>

<file path="src/infra/env/env.service.ts">
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import type { Env } from './env'

@Injectable()
export class EnvService {
  constructor(private configService: ConfigService<Env, true>) {}

  get<T extends keyof Env>(key: T) {
    return this.configService.get(key, { infer: true })
  }
}
</file>

<file path="src/infra/events/user/__tests__/on-user-active-status-changed.e2e-spec.ts">
import { DomainEvents } from '@/core/events/domain-events'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { TokenService } from '@/infra/auth/token.service'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import { randomUUID } from 'node:crypto'
import request from 'supertest'
import { waitFor } from 'test/utils/wait-for'

describe('On user active status changed (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user active status is updated', async () => {
    const admin = await userFactory.makePrismaUser({ role: 'ADMIN' })
    const targetUser = await userFactory.makePrismaUser({ isActive: true })

    const accessToken = await tokenService.generateAccessToken({
      sub: admin.id.toString(),
      role: admin.role,
      jti: randomUUID(),
    })

    const response = await request(app.getHttpServer())
      .patch(`/v1/users/${targetUser.id.toString()}/status`)
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send({ isActive: false })

    expect(response.statusCode).toBe(200)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: admin.id.toString(),
          action: 'user:active_status_updated',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: admin.id.toString(),
        actorType: 'USER',
        entity: 'USER',
        entityId: targetUser.id.toString(),
        action: 'user:active_status_updated',
      })

      expect(
        typeof auditLog!.changes === 'string'
          ? JSON.parse(auditLog!.changes)
          : auditLog!.changes,
      ).toEqual({
        isActive: {
          before: true,
          after: false,
        },
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-logged-in.e2e-spec.ts">
import { DomainEvents } from '@/core/events/domain-events'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import { hash } from 'bcryptjs'
import { waitFor } from 'test/utils/wait-for'

describe('On user logged in (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user logs in', async () => {
    const password = '123456'
    const user = await userFactory.makePrismaUser({
      passwordHash: await hash(password, 8),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users/login')
      .send({
        email: user.email,
        password,
      })

    expect(response.statusCode).toBe(200)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:logged_in',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:logged_in',
        entity: 'USER',
        entityId: user.id.toString(),
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-logged-out.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { TokenService } from '@/infra/auth/token.service'
import { UserFactory } from 'test/factories/make-user'
import { waitFor } from 'test/utils/wait-for'
import { DomainEvents } from '@/core/events/domain-events'
import { randomUUID } from 'node:crypto'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('On User Logged Out (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let tokenService: TokenService
  let userFactory: UserFactory

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    tokenService = moduleRef.get(TokenService)
    userFactory = moduleRef.get(UserFactory)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user logs out', async () => {
    const user = await userFactory.makePrismaUser()

    const accessToken = await tokenService.generateAccessToken({
      sub: user.id.toString(),
      role: user.role,
      jti: randomUUID(),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users/logout')
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send()

    expect(response.statusCode).toBe(204)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:logged_out',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:logged_out',
        entity: 'USER',
        entityId: user.id.toString(),
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-requested-password-reset.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserFactory } from 'test/factories/make-user'
import { waitFor } from 'test/utils/wait-for'
import { DomainEvents } from '@/core/events/domain-events'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('On User Requested Password Reset (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user requests password reset', async () => {
    const user = await userFactory.makePrismaUser()

    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({
        email: user.email,
      })

    expect(response.statusCode).toBe(204)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:requested_password_reset',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:requested_password_reset',
        entity: 'USER',
        entityId: user.id.toString(),
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-reset-password.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserFactory } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { waitFor } from 'test/utils/wait-for'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { TokenService } from '@/infra/auth/token.service'

describe('On User Reset Password (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user resets password', async () => {
    const user = await userFactory.makePrismaUser({
      email: 'email@example.com',
    })

    const token = await tokenService.generate({
      sub: user.id.toString(),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({
        token,
        password: 'new-password',
      })

    expect(response.statusCode).toBe(204)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:reset_password',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:reset_password',
        entity: 'USER',
        entityId: user.id.toString(),
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-role-changed.e2e-spec.ts">
import { DomainEvents } from '@/core/events/domain-events'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { TokenService } from '@/infra/auth/token.service'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import { randomUUID } from 'node:crypto'
import request from 'supertest'
import { waitFor } from 'test/utils/wait-for'

describe('On user role changed (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user role is updated', async () => {
    const admin = await userFactory.makePrismaUser({ role: 'ADMIN' })
    const targetUser = await userFactory.makePrismaUser({ role: 'OPERATOR' })

    const accessToken = await tokenService.generateAccessToken({
      sub: admin.id.toString(),
      role: admin.role,
      jti: randomUUID(),
    })

    const response = await request(app.getHttpServer())
      .patch(`/v1/users/${targetUser.id.toString()}/role`)
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send({ role: 'MANAGER' })

    expect(response.statusCode).toBe(200)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: admin.id.toString(),
          action: 'user:role_updated',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: admin.id.toString(),
        actorType: 'USER',
        entity: 'USER',
        entityId: targetUser.id.toString(),
        action: 'user:role_updated',
      })

      expect(
        typeof auditLog!.changes === 'string'
          ? JSON.parse(auditLog!.changes)
          : auditLog!.changes,
      ).toEqual({
        role: {
          before: 'OPERATOR',
          after: 'MANAGER',
        },
      })
    })
  })
})
</file>

<file path="src/infra/events/user/__tests__/on-user-updated.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { TokenService } from '@/infra/auth/token.service'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'
import { DomainEvents } from '@/core/events/domain-events'
import { waitFor } from 'test/utils/wait-for'

describe('On user updated (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user is updated', async () => {
    const user = await userFactory.makePrismaUser()
    const accessToken = await tokenService.generateAccessToken({
      sub: user.id.toString(),
      role: user.role,
      jti: randomUUID(),
    })

    const payload = {
      name: 'Updated Name',
      addresses: [
        {
          street: 'Rua Nova',
          number: '123',
          neighborhood: 'Centro',
          city: 'S√£o Paulo',
          state: 'SP',
          zipCode: '12345-678',
        },
      ],
    }

    await request(app.getHttpServer())
      .patch(`/v1/users/${user.id.toString()}`)
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send(payload)
      .expect(200)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:updated',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:updated',
        entity: 'USER',
        entityId: user.id.toString(),
      })
    })
  })
})
</file>

<file path="src/infra/events/events.module.ts">
import { Module } from '@nestjs/common'
import { UserEventsModule } from './user/user-events.module'

@Module({
  imports: [UserEventsModule],
})
export class EventsModule {}
</file>

<file path="src/infra/http/controllers/audit-log/__tests__/list-audit-logs.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { AuditLogRepository } from '@/domain/audit-log/application/repositories/audit-log-repository'
import { AuditLogDatabaseModule } from '@/infra/database/prisma/repositories/audit-log/audit-log-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import request from 'supertest'
import { ActorType } from '@prisma/client'
import { makeAuditLog } from 'test/factories/make-audit-log'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import type { User } from '@/domain/user/enterprise/entities/user'
import { randomUUID } from 'node:crypto'

describe('List Audit Logs (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let auditLogRepository: AuditLogRepository
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        AppModule,
        AuditLogDatabaseModule,
        UserDatabaseModule,
        CryptographyModule,
      ],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    token = moduleRef.get(TokenService)
    userFactory = moduleRef.get(UserFactory)
    auditLogRepository = moduleRef.get(AuditLogRepository)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
  })
  it('[200] OK ‚Üí should list audit logs with correct actor info', async () => {
    const log = makeAuditLog({
      actorId: adminUser.id.toString(),
      actorType: ActorType.USER,
    })
    await auditLogRepository.create(log)

    const response = await request(app.getHttpServer())
      .get('/v1/audit-logs')
      .set('Authorization', `Bearer ${adminAccessToken.token}`)
      .query({
        actorType: 'USER',
        actorEmail: adminUser.email,
      })

    expect(response.statusCode).toBe(200)
    expect(response.body.data).toHaveLength(1)
    expect(response.body.data[0].actor.name).toBe(adminUser.name)
    expect(response.body.data[0].actor.email).toBe(adminUser.email)
  })

  it('[400] Bad Request ‚Üí should return 400 if actorType is missing', async () => {
    const response = await request(app.getHttpServer())
      .get('/v1/audit-logs')
      .set('Authorization', `Bearer ${adminAccessToken.token}`)

    expect(response.statusCode).toBe(400)
  })

  it('[401] Unauthorized ‚Üí should return 401 if no token is provided', async () => {
    const response = await request(app.getHttpServer())
      .get('/v1/audit-logs')
      .query({
        actorType: 'USER',
      })

    expect(response.statusCode).toBe(401)
  })

  it('[403] Forbidden ‚Üí should return 403 if user does not have permission', async () => {
    const normalUser = await userFactory.makePrismaUser({
      email: 'user@empresa.com',
      role: 'OPERATOR',
    })

    const accessToken = await token.generateAccessToken({
      sub: normalUser.id.toString(),
      role: normalUser.role,
      jti: randomUUID(),
    })

    const response = await request(app.getHttpServer())
      .get('/v1/audit-logs')
      .set('Authorization', `Bearer ${accessToken.token}`)
      .query({
        actorType: 'USER',
      })

    expect(response.statusCode).toBe(403)
  })

  it('[422] Unprocessable Entity ‚Üí should return 422 if invalid date format is provided', async () => {
    const response = await request(app.getHttpServer())
      .get('/v1/audit-logs')
      .set('Authorization', `Bearer ${adminAccessToken.token}`)
      .query({
        actorType: 'USER',
        startDate: 'invalid-date',
      })

    expect(response.statusCode).toBe(422)
  })
})
</file>

<file path="src/infra/http/controllers/audit-log/audit-log-controllers.module.ts">
import { Module } from '@nestjs/common'
import { CaslAbilityModule } from '@/infra/auth/casl/casl-ability.module'
import { StorageModule } from '@/infra/storage/storage.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { ListAuditLogsController } from './list-audit-logs.controller'
import { ListAuditLogsUseCase } from '@/domain/audit-log/application/use-cases/list-audit-logs'
import { AuditLogDatabaseModule } from '@/infra/database/prisma/repositories/audit-log/audit-log-database.module'

@Module({
  imports: [
    AuditLogDatabaseModule,
    UserDatabaseModule,
    CaslAbilityModule,
    StorageModule,
  ],
  controllers: [ListAuditLogsController],
  providers: [ListAuditLogsUseCase],
})
export class AuditLogControllersModule {}
</file>

<file path="src/infra/http/controllers/audit-log/list-audit-logs.controller.ts">
import {
  Controller,
  Get,
  HttpCode,
  Query,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiOperation,
  ApiQuery,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { AuditLogPresenter } from '../../presenters/audit-log.presenter'
import {
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'

import { z } from 'zod'
import { ActorType } from '@prisma/client'
import { ListAuditLogsUseCase } from '@/domain/audit-log/application/use-cases/list-audit-logs'
import { ZodValidationPipe } from '../../pipes'
import { AuditLogListResponseDto } from '../../dtos/response/audit-log'
import { AuditLogErrorFilter } from '../../filters/audit-log-error.filter'

export const listAuditLogsQuerySchema = z.object({
  actorType: z.nativeEnum(ActorType),
  actorEmail: z.string().email().optional(),
  entity: z.string().optional(),
  action: z.string().optional(),
  entityId: z.string().optional(),
  startDate: z.coerce.date().optional(),
  endDate: z.coerce.date().optional(),
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).optional().default(20),
})

export type ListAuditLogsQuerySchema = z.infer<typeof listAuditLogsQuerySchema>

@UseFilters(AuditLogErrorFilter)
@ApiTags('Audit Logs')
@ServiceTag('audit-log')
@Controller({ path: 'audit-logs', version: '1' })
export class ListAuditLogsController {
  constructor(private listAuditLogsUseCase: ListAuditLogsUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('list', 'AuditLog'))
  @Get()
  @HttpCode(200)
  @ApiOperation({ summary: 'List audit logs with filters and pagination' })
  @ApiQuery({
    name: 'actorType',
    enum: ActorType,
    required: true,
    example: ActorType.USER,
  })
  @ApiQuery({
    name: 'actorEmail',
    required: false,
    example: 'admin@empresa.com',
  })
  @ApiQuery({ name: 'entity', required: false, example: 'User' })
  @ApiQuery({ name: 'action', required: false, example: 'update-password' })
  @ApiQuery({ name: 'entityId', required: false, example: 'usr_1234567890' })
  @ApiQuery({
    name: 'startDate',
    required: false,
    example: '2024-06-01T00:00:00.000Z',
  })
  @ApiQuery({
    name: 'endDate',
    required: false,
    example: '2024-06-30T23:59:59.000Z',
  })
  @ApiQuery({ name: 'cursor', required: false, example: 'log_abcdef123456' })
  @ApiQuery({ name: 'limit', required: false, example: 20 })
  @ApiOkResponse({ type: AuditLogListResponseDto })
  @ApiUnauthorizedResponse({ description: 'Unauthorized.' })
  @ApiForbiddenResponse({ description: 'Forbidden.' })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @Query(new ZodValidationPipe(listAuditLogsQuerySchema))
    query: ListAuditLogsQuerySchema,
  ) {
    const {
      actorType,
      actorEmail,
      entity,
      action,
      entityId,
      startDate,
      endDate,
      cursor,
      limit,
    } = query

    const result = await this.listAuditLogsUseCase.execute({
      params: {
        actorType,
        actorEmail,
        entity,
        action,
        entityId,
        startDate,
        endDate,
      },
      cursorParams: {
        cursor,
        limit,
      },
    })

    if (result.isRight()) {
      const { data, meta } = result.value

      return {
        data: data.map(AuditLogPresenter.toHTTP),
        meta,
      }
    }

    throw result.value
  }
}
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-password.controller.e2e-spec.ts">
import request from 'supertest'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { TokenService } from '@/infra/auth/token.service'
import { CacheRepository } from '@/infra/cache/cache-repository'
import { randomUUID } from 'crypto'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { hash } from 'bcryptjs'

describe('Edit User Password (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService
  let cache: CacheRepository

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })
    await app.init()

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)
    cache = moduleRef.get(CacheRepository)
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    const keys = await cache.keys('refresh_token:*')
    if (keys.length > 0) await cache.del(keys)
  })

  it('[204] Success ‚Üí should update password and revoke other sessions', async () => {
    const password = '123456'
    const user = await userFactory.makePrismaUser({
      passwordHash: await hash(password, 8),
    })

    const jti1 = randomUUID()
    const jti2 = randomUUID()

    const token2 = await tokenService.generate({
      sub: user.id.toString(),
      role: user.role,
      jti: jti2,
    })

    await cache.set(`refresh_token:${jti1}`, user.id.toString())
    await cache.set(`refresh_token:${jti2}`, user.id.toString())

    await request(app.getHttpServer())
      .patch(`/v1/users/${user.id.toString()}/password`)
      .set('Authorization', `Bearer ${token2}`)
      .send({
        currentPassword: password,
        newPassword: 'new-password',
      })
      .expect(204)

    const keys = await cache.keys('refresh_token:*')

    expect(keys).toContain(`refresh_token:${jti2}`)
    expect(keys).not.toContain(`refresh_token:${jti1}`)
  })
})
</file>

<file path="src/infra/http/controllers/user/edit-user-password.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Patch,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiInternalServerErrorResponse,
  ApiNoContentResponse,
  ApiNotFoundResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { z } from 'zod'

import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { EditUserPasswordUseCase } from '@/domain/user/application/use-cases/edit-user-password'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'

import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { WrongCredentialsDto, UserNotFoundDto } from '../../dtos/error/user'
import { CurrentUser } from '@/infra/auth/current-user.decorator'
import { EditUserPasswordRequestDto } from '../../dtos/requests/user'
import type { UserPayload } from '@/infra/auth/jwt.strategy'
import { userCanUpdateSelfHandler } from '@/infra/auth/casl/handlers/user-can-update-self.handler'

const editUserPasswordBodySchema = z.object({
  currentPassword: z.string().min(6),
  newPassword: z.string().min(6),
})

type EditUserPasswordBody = z.infer<typeof editUserPasswordBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class EditUserPasswordController {
  constructor(private editUserPasswordUseCase: EditUserPasswordUseCase) {}

  @Patch(':id/password')
  @UseGuards(CaslAbilityGuard)
  @CheckPolicies(userCanUpdateSelfHandler)
  @HttpCode(204)
  @ApiOperation({ summary: 'Edit own password' })
  @ApiBody({ type: EditUserPasswordRequestDto })
  @ApiNoContentResponse({ description: 'Password updated successfully' })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @CurrentUser() user: UserPayload,
    @Body(new ZodValidationPipe(editUserPasswordBodySchema))
    body: EditUserPasswordBody,
  ) {
    const { currentPassword, newPassword } = body

    const result = await this.editUserPasswordUseCase.execute({
      userId: user.sub,
      currentPassword,
      newPassword,
      currentJti: user.jti,
    })

    if (result.isLeft()) {
      throw result.value
    }
  }
}
</file>

<file path="src/infra/http/dtos/common/health-check-response.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger'

export class HealthDetailDto {
  @ApiProperty({
    example: 'up',
    enum: ['up', 'down'],
    description: 'Status do componente verificado.',
  })
  status: 'up' | 'down'

  @ApiPropertyOptional({
    example: 'Servi√ßo est√° operacional',
    description: 'Mensagem adicional sobre o status (opcional).',
  })
  message?: string
}

export class HealthComponentsDto {
  @ApiProperty({
    type: () => HealthDetailDto,
    description: 'Status do banco de dados.',
  }) // Usar arrow function para evitar problemas de refer√™ncia circular/inicializa√ß√£o
  database: HealthDetailDto

  @ApiProperty({ type: () => HealthDetailDto, description: 'Status do Redis.' })
  redis: HealthDetailDto

  @ApiProperty({
    type: () => HealthDetailDto,
    description: 'Status do S3 (armazenamento de objetos).',
  })
  s3: HealthDetailDto
}

export class HealthCheckResponseDto {
  @ApiProperty({
    example: 'ok',
    enum: ['ok', 'error'],
    description: 'Status geral do health check.',
  })
  status: 'ok' | 'error'

  @ApiPropertyOptional({
    type: () => HealthComponentsDto,
    description:
      'Informa√ß√µes detalhadas dos componentes quando o status geral √© "ok".',
  })
  info?: HealthComponentsDto

  @ApiPropertyOptional({
    type: () => HealthComponentsDto,
    description:
      'Informa√ß√µes detalhadas dos componentes quando o status geral √© "error".',
  })
  error?: HealthComponentsDto

  @ApiProperty({
    type: () => HealthComponentsDto,
    description: 'Detalhes brutos de todos os componentes verificados.',
  })
  details: HealthComponentsDto
}
</file>

<file path="src/infra/http/dtos/common/index.ts">
export * from './pagination-meta.dto'
</file>

<file path="src/infra/http/dtos/common/pagination-meta.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class PaginationMetaDto {
  @ApiProperty({ example: 25 })
  total!: number

  @ApiProperty({ example: 10 })
  count!: number

  @ApiProperty({ example: 10 })
  perPage!: number

  @ApiProperty({ example: 3 })
  totalPages!: number

  @ApiProperty({ example: 2 })
  currentPage!: number

  @ApiProperty({ example: 3, nullable: true })
  nextPage!: number | null

  @ApiProperty({ example: 1, nullable: true })
  previousPage!: number | null
}
</file>

<file path="src/infra/http/dtos/error/avatar/avatar-forbidden.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic'

export class AvatarForbiddenDto extends ForbiddenDto {
  @ApiProperty({ example: 'You are not allowed to perform this action.' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/avatar/avatar-upload-failed.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { InternalServerErrorDto } from '../generic'

export class AvatarUploadFailedDto extends InternalServerErrorDto {
  @ApiProperty({ example: 'Failed to upload avatar' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/avatar/index.ts">
export * from './avatar-forbidden.dto'
export * from './avatar-upload-failed.dto'
</file>

<file path="src/infra/http/dtos/error/generic/bad-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class BadRequestDto {
  @ApiProperty({ example: 400 })
  declare statusCode: number

  @ApiProperty({ example: 'Bad Request' })
  declare error: string

  @ApiProperty({ example: 'Invalid parameters' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/conflict.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ConflictDto {
  @ApiProperty({ example: 409 })
  declare statusCode: number

  @ApiProperty({ example: 'Conflict' })
  declare error: string

  @ApiProperty({ example: 'E-mail already in use' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/forbidden.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ForbiddenDto {
  @ApiProperty({ example: 403 })
  declare statusCode: number

  @ApiProperty({ example: 'Forbidden' })
  declare error: string

  @ApiProperty({ example: 'You do not have permission to perform this action' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/index.ts">
export * from './bad-request.dto'
export * from './unauthorized.dto'
export * from './forbidden.dto'
export * from './not-found.dto'
export * from './conflict.dto'
export * from './too-many-requests.dto'
export * from './validation.dto'
export * from './internal-server.dto'
export * from './unprocessable-entity.dto'
</file>

<file path="src/infra/http/dtos/error/generic/internal-server.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class InternalServerErrorDto {
  @ApiProperty({ example: 500 })
  declare statusCode: number

  @ApiProperty({ example: 'Internal server error' })
  declare error: string

  @ApiProperty({ example: 'Internal server error' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/not-found.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class NotFoundDto {
  @ApiProperty({ example: 404 })
  declare statusCode: number

  @ApiProperty({ example: 'Not Found' })
  declare error: string

  @ApiProperty({ example: 'Resource not found' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/too-many-requests.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class TooManyRequestsDto {
  @ApiProperty({ example: 429 })
  declare statusCode: number

  @ApiProperty({ example: 'Too Many Requests' })
  declare error: string

  @ApiProperty({ example: 'Rate limit exceeded' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/unauthorized.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UnauthorizedDto {
  @ApiProperty({ example: 401 })
  declare statusCode: number

  @ApiProperty({ example: 'Unauthorized' })
  declare error: string

  @ApiProperty({ example: 'Invalid credentials' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/unprocessable-entity.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UnprocessableEntityDto {
  @ApiProperty({ example: 422 })
  declare statusCode: number

  @ApiProperty({ example: 'Unprocessable Entity' })
  declare error: string

  @ApiProperty({ example: [{ path: 'email', message: 'Invalid e-mail' }] })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/validation.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ValidationErrorDto {
  @ApiProperty({ example: 400 })
  declare statusCode: number

  @ApiProperty({ example: 'BadRequest' })
  declare error: string

  @ApiProperty({
    example: [
      { path: 'email', message: 'E-mail must be valid' },
      { path: 'password', message: 'Minimum length is 6' },
    ],
  })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/user/invalid-role-transition.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic/forbidden.dto'

export class InvalidRoleTransitionDto extends ForbiddenDto {
  @ApiProperty({ example: 'Cannot change role from OPERATOR to ADMIN' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-already-exists.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ConflictDto } from '../generic/conflict.dto'

export class UserAlreadyExistsDto extends ConflictDto {
  @ApiProperty({ example: 'User already exists.' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-forbidden.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic'

export class UserForbiddenDto extends ForbiddenDto {
  @ApiProperty({ example: 'Access Denied' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-not-found.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { NotFoundDto } from '../generic/not-found.dto'

export class UserNotFoundDto extends NotFoundDto {
  @ApiProperty({ example: 'User not found' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-unauthorized.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UserUnauthorizedDto {
  @ApiProperty({
    example: 'UNAUTHORIZED',
    description: 'Error code',
  })
  code: string

  @ApiProperty({
    example: 'You must be logged in to access this resource.',
    description: 'Error message for unauthorized access',
  })
  message: string
}
</file>

<file path="src/infra/http/dtos/error/user/wrong-credentials.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { UnauthorizedDto } from '../generic'

export class WrongCredentialsDto extends UnauthorizedDto {
  @ApiProperty({ example: 'Credentials are not valid.' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/requests/avatar/index.ts">
export * from './upload-avatar-request.dto'
</file>

<file path="src/infra/http/dtos/requests/avatar/upload-avatar-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UploadAvatarRequestDto {
  @ApiProperty({
    type: 'string',
    format: 'binary',
    description: 'Avatar image file (JPG, PNG, JPEG)',
  })
  file: Express.Multer.File
}
</file>

<file path="src/infra/http/dtos/requests/user/authenticate-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class AuthenticateUserRequestDto {
  @ApiProperty({ example: 'john@email.com' })
  email!: string

  @ApiProperty({ example: 'mySecurePass123' })
  password!: string
}
</file>

<file path="src/infra/http/dtos/requests/user/create-user-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class CreateUserRequestDto {
  @ApiProperty({ example: 'John Doe' })
  name!: string

  @ApiProperty({ example: 'john.doe@email.com' })
  email!: string

  @ApiProperty({ example: 'MySecurePass123!' })
  password!: string

  @ApiProperty({ enum: Role, example: Role.ADMIN })
  role!: Role
}
</file>

<file path="src/infra/http/dtos/requests/user/edit-user-password-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { IsString, MinLength } from 'class-validator'

export class EditUserPasswordRequestDto {
  @ApiProperty({
    example: 'current-password123',
    description: 'The current password of the user',
    minLength: 6,
  })
  @IsString()
  @MinLength(6)
  currentPassword: string

  @ApiProperty({
    example: 'new-password456',
    description: 'The new password to be set',
    minLength: 6,
  })
  @IsString()
  @MinLength(6)
  newPassword: string
}
</file>

<file path="src/infra/http/dtos/requests/user/edit-user-request.dto.ts">
// edit-user-request.dto.ts
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger'

export class EditUserRequestDto {
  @ApiProperty({ example: 'John Updated' })
  name!: string

  @ApiPropertyOptional({
    example: '6be7aab9-30a7-4fc8-b22a-4a25e3d7d4b4',
    description: 'Avatar ID existente',
  })
  avatarId?: string
}
</file>

<file path="src/infra/http/dtos/requests/user/edit-user-role-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class EditUserRoleRequestDto {
  @ApiProperty({
    enum: Role,
    example: Role.ADMIN,
    description: 'Novo cargo do usu√°rio',
  })
  role!: Role
}
</file>

<file path="src/infra/http/dtos/requests/user/forgot-password-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ForgotPasswordRequestDto {
  @ApiProperty({
    type: String,
    example: 'user@example.com',
    description: 'E-mail do usu√°rio para recuperar a senha',
  })
  email!: string
}
</file>

<file path="src/infra/http/dtos/requests/user/reset-password-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ResetPasswordRequestDto {
  @ApiProperty({
    type: String,
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
    description: 'Token enviado por e-mail para resetar a senha',
  })
  token!: string

  @ApiProperty({
    type: String,
    minLength: 8,
    example: 'NovaSenhaSegura123',
    description: 'Nova senha do usu√°rio',
  })
  password!: string
}
</file>

<file path="src/infra/http/dtos/response/audit-log/audit-log-list-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ActorType } from '@prisma/client'

class AuditLogActorDto {
  @ApiProperty({ example: 'usr_123456' })
  id: string

  @ApiProperty({ enum: ActorType, example: ActorType.USER })
  type: ActorType

  @ApiProperty({ example: 'Jo√£o Silva' })
  name: string

  @ApiProperty({ example: 'joao@empresa.com' })
  email: string
}

class AuditLogDto {
  @ApiProperty({ example: 'log_abc123' })
  id: string

  @ApiProperty({ type: () => AuditLogActorDto })
  actor: AuditLogActorDto

  @ApiProperty({ example: 'edit' })
  action: string

  @ApiProperty({ example: 'User' })
  entity: string

  @ApiProperty({ example: 'usr_789456' })
  entityId: string

  @ApiProperty({
    example: { name: ['Jo√£o', 'Jo√£o Silva'] },
    nullable: true,
  })
  changes: Record<string, unknown> | null

  @ApiProperty({ example: '2025-06-11T19:00:00.000Z' })
  createdAt: Date
}

class PaginationMetaDto {
  @ApiProperty({ example: 20 })
  count: number

  @ApiProperty({ example: true })
  hasNextPage: boolean

  @ApiProperty({ example: 'log_abcdef123456', nullable: true })
  nextCursor?: string | null
}

export class AuditLogListResponseDto {
  @ApiProperty({ type: () => [AuditLogDto] })
  data: AuditLogDto[]

  @ApiProperty({ type: () => PaginationMetaDto })
  meta: PaginationMetaDto
}
</file>

<file path="src/infra/http/dtos/response/audit-log/index.ts">
export * from './audit-log-list-response.dto'
</file>

<file path="src/infra/http/dtos/response/avatar/index.ts">
export * from './upload-avatar-response.dto'
</file>

<file path="src/infra/http/dtos/response/avatar/upload-avatar-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UploadAvatarResponseDto {
  @ApiProperty({
    example: 'avatar-uuid-123',
    description: 'ID of the uploaded avatar',
  })
  data: string
}
</file>

<file path="src/infra/http/dtos/response/user/authenticate-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class AuthenticateUserResponseDto {
  @ApiProperty({ example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6...' })
  access_token!: string

  @ApiProperty({ example: 3600 })
  expiresIn!: number
}
</file>

<file path="src/infra/http/dtos/response/user/refresh-token-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

class TokenDataDto {
  @ApiProperty({
    example: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',
    description: 'JWT v√°lido para autentica√ß√£o.',
  })
  token: string

  @ApiProperty({
    example: 1723487384,
    description: 'Data de expira√ß√£o do token (timestamp UNIX).',
  })
  expiresIn: number
}

export class RefreshTokenResponseDto {
  @ApiProperty({ type: () => TokenDataDto })
  access_token: TokenDataDto

  @ApiProperty({ type: () => TokenDataDto })
  refresh_token: TokenDataDto

  @ApiProperty({
    example: 1723487384,
    description: 'Timestamp da expira√ß√£o do access token (redundante).',
  })
  expiresIn: number
}
</file>

<file path="src/infra/http/dtos/response/user/user-list-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { UserResponseDto } from './user-response.dto'
import { PaginationMetaDto } from '../../common'

export class UserListResponseDto {
  @ApiProperty({ type: [UserResponseDto] })
  data!: UserResponseDto[]

  @ApiProperty({ type: PaginationMetaDto })
  meta!: PaginationMetaDto
}
</file>

<file path="src/infra/http/dtos/response/user/user-response.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class UserResponseDto {
  @ApiProperty({ example: '855c4f19-38e5-4b73-932e-9e3fb6eafe30' })
  id!: string

  @ApiProperty({ example: 'John Doe' })
  name!: string

  @ApiProperty({ example: 'john.doe@email.com' })
  email!: string

  @ApiProperty({ enum: Role, example: Role.ADMIN })
  role!: Role

  @ApiProperty({ example: true })
  isActive!: boolean

  @ApiPropertyOptional({
    example: 'https://cdn.powerbrake.io/avatars/855c4f19.png',
  })
  avatarUrl?: string | null

  @ApiProperty({ example: '2025-06-04T01:42:11.123Z' })
  createdAt!: string

  @ApiPropertyOptional({ example: '2025-06-04T01:42:11.123Z' })
  updatedAt?: string | null
}
</file>

<file path="src/infra/http/filters/audit-log-error.filter.ts">
import { Catch } from '@nestjs/common'
import { AppErrorFilter } from './app-error.filter'

@Catch()
export class AuditLogErrorFilter extends AppErrorFilter {
  protected override mapDomainErrorToStatus(name: string): number {
    switch (name) {
      default:
        return super.mapDomainErrorToStatus(name)
    }
  }
}
</file>

<file path="src/infra/http/indicators/mailer-health.indicator.ts">
import { Injectable } from '@nestjs/common'
import { type HealthIndicatorResult } from '@nestjs/terminus'
import { MailRepository } from '@/infra/mail/mail-repository'

@Injectable()
export class MailHealthIndicator {
  constructor(private readonly mailer: MailRepository) {}

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    try {
      await this.mailer.verify()
      return {
        [key]: { status: 'up' },
      }
    } catch (error) {
      console.error('Mail Health Check failed:', error)
      return {
        [key]: { status: 'down' },
      }
    }
  }
}
</file>

<file path="src/infra/http/indicators/prisma-health.indicator.ts">
import { Injectable } from '@nestjs/common'
import { type HealthIndicatorResult } from '@nestjs/terminus'
import { PrismaService } from '@/infra/database/prisma/prisma.service'

@Injectable()
export class PrismaHealthIndicator {
  constructor(private prisma: PrismaService) {}

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    try {
      await this.prisma.$queryRawUnsafe('SELECT 1')
      return {
        [key]: {
          status: 'up',
        },
      }
    } catch {
      return {
        [key]: {
          status: 'down',
        },
      }
    }
  }
}
</file>

<file path="src/infra/http/indicators/redis-health.indicator.ts">
import { RedisService } from '@/infra/cache/redis/redis.service'
import { Injectable } from '@nestjs/common'
import { HealthIndicatorResult } from '@nestjs/terminus'

@Injectable()
export class RedisHealthIndicator {
  constructor(private readonly redisService: RedisService) {}

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    try {
      await this.redisService.ping()
      return {
        [key]: { status: 'up' },
      }
    } catch {
      return {
        [key]: { status: 'down' },
      }
    }
  }
}
</file>

<file path="src/infra/http/pipes/index.ts">
export * from './parse-uuid.pipe'
export * from './zod-validation.pipe'
</file>

<file path="src/infra/http/pipes/parse-uuid.pipe.ts">
import {
  PipeTransform,
  Injectable,
  BadRequestException,
  ArgumentMetadata,
} from '@nestjs/common'
import { isUUID } from 'class-validator'

@Injectable()
export class ParseUuidPipe implements PipeTransform<string> {
  transform(value: string, meta: ArgumentMetadata) {
    if (!isUUID(value, '4')) {
      throw new BadRequestException({
        statusCode: 400,
        error: 'Bad Request',
        message: `Param ${meta.data ?? 'id'} must be a valid UUID`,
      })
    }
    return value
  }
}
</file>

<file path="src/infra/http/pipes/zod-validation.pipe.ts">
import {
  PipeTransform,
  BadRequestException,
  UnprocessableEntityException,
} from '@nestjs/common'
import { ZodError, ZodSchema } from 'zod'
import { fromZodError } from 'zod-validation-error'

export class ZodValidationPipe implements PipeTransform {
  constructor(private readonly schema: ZodSchema) {}

  transform(value: unknown) {
    try {
      return this.schema.parse(value)
    } catch (error) {
      if (error instanceof ZodError) {
        const issues = error.errors

        const hasMissing = issues.some(
          (i) => i.code === 'invalid_type' && i.received === 'undefined',
        )

        const formatted = fromZodError(error)

        if (hasMissing) {
          throw new BadRequestException({
            statusCode: 400,
            message: 'Missing required fields',
            errors: formatted,
          })
        }

        throw new UnprocessableEntityException({
          statusCode: 422,
          message: 'Validation failed',
          errors: formatted,
        })
      }

      throw new BadRequestException('Validation failed')
    }
  }
}
</file>

<file path="src/infra/http/presenters/__tests__/audit-log.presenter.spec.ts">
import { AuditLogPresenter } from '../audit-log.presenter'
import { makeAuditLog } from 'test/factories/make-audit-log'
import { ActorType } from '@prisma/client'

describe('AuditLogPresenter', () => {
  it('should present AuditLog with actor name and email', () => {
    const auditLog = makeAuditLog({
      actorId: 'actor-id-123',
      actorType: ActorType.USER,
    })

    const auditLogWithActorInfo = Object.assign(
      Object.create(Object.getPrototypeOf(auditLog)),
      auditLog,
    ) as typeof auditLog & {
      actorName: string
      actorEmail: string
    }

    auditLogWithActorInfo.actorName = 'John Doe'
    auditLogWithActorInfo.actorEmail = 'john@example.com'

    const result = AuditLogPresenter.toHTTP(auditLogWithActorInfo)

    expect(result).toEqual({
      id: auditLog.id.toString(),
      actor: {
        id: auditLog.actorId,
        type: auditLog.actorType,
        name: 'John Doe',
        email: 'john@example.com',
      },
      action: auditLog.action,
      entity: auditLog.entity,
      entityId: auditLog.entityId,
      changes: auditLog.changes ?? null,
      createdAt: auditLog.createdAt,
    })
  })
})
</file>

<file path="src/infra/http/presenters/__tests__/user.presenter.spec.ts">
import { UserPresenter } from '../user.presenter'
import { makeUser } from 'test/factories/make-user'

describe('UserPresenter', () => {
  it('should present a user correctly to HTTP', () => {
    const user = makeUser({
      name: 'Alice Smith',
      email: 'alice@example.com',
      role: 'ADMIN',
    })

    const result = UserPresenter.toHTTP(user)

    expect(result).toEqual({
      id: user.id.toString(),
      name: 'Alice Smith',
      email: 'alice@example.com',
      role: 'ADMIN',
      isActive: true,
      addresses: [],
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    })
  })
})
</file>

<file path="src/infra/http/presenters/audit-log.presenter.ts">
import { AuditLog } from '@/domain/audit-log/enterprise/entities/audit-log'
import { ActorType } from '@prisma/client'

type AuditLogWithActorInfo = AuditLog & {
  actorName: string
  actorEmail: string
}

export class AuditLogPresenter {
  static toHTTP(auditLog: AuditLogWithActorInfo) {
    return {
      id: auditLog.id.toString(),
      actor: {
        id: auditLog.actorId,
        type: auditLog.actorType as ActorType,
        name: auditLog.actorName,
        email: auditLog.actorEmail,
      },
      action: auditLog.action,
      entity: auditLog.entity,
      entityId: auditLog.entityId,
      changes: auditLog.changes ?? null,
      createdAt: auditLog.createdAt,
    }
  }
}
</file>

<file path="src/infra/logger/winston/winston.config.ts">
import { createLogger, format, transports } from 'winston'
import kleur from 'kleur'

const isDev = process.env.NODE_ENV === 'production'

function colorTime(time: number) {
  if (typeof time !== 'number' || isNaN(time)) return kleur.yellow(`${time}ms`)
  if (time < 300) return kleur.yellow(`${time}ms`)
  if (time < 1000) return kleur.yellow().bold(`${time}ms`)
  return kleur.red().bold(`${time}ms`)
}

function colorLevel(level: string) {
  switch (level.toLowerCase()) {
    case 'info':
      return kleur.blue(level.toUpperCase())
    case 'warn':
      return kleur.yellow(level.toUpperCase())
    case 'error':
      return kleur.red(level.toUpperCase())
    case 'debug':
      return kleur.magenta(level.toUpperCase())
    default:
      return level.toUpperCase()
  }
}

function formatDate(dateISO: string): string {
  if (!dateISO) return ''
  const date = new Date(dateISO)
  if (isNaN(date.getTime())) return ''
  return date.toLocaleString('pt-BR', {
    timeZone: 'UTC',
    year: '2-digit',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

const coloredProdFormat = format.combine(
  format.timestamp(),
  format.printf((info) => {
    try {
      const timestamp = typeof info.timestamp === 'string' ? info.timestamp : ''
      const dateTime = formatDate(timestamp)
      const service = kleur.yellow(String(info.service ?? ''))
      const level = colorLevel(String(info.level ?? 'info'))
      const route = kleur.green(
        `{${String(info.route ?? '')}, ${String(info.httpMethod ?? '')}} route`,
      )
      const message = kleur.yellow(String(info.message ?? ''))
      const time =
        typeof info.timeToComplete === 'number'
          ? colorTime(info.timeToComplete)
          : kleur.yellow(String(info.timeToComplete ?? '') + 'ms')
      return `${dateTime} - service: ${service} - [${level}] - ${route} - ${message}: ${time}`
    } catch (err) {
      return `[LOGGER ERROR] ${err}\nRAW: ${JSON.stringify(info)}`
    }
  }),
)

const devFormat = format.combine(
  format.colorize(),
  format.timestamp(),
  format.printf(({ timestamp, level, message, ...meta }) =>
    [
      `[${timestamp}]`,
      level,
      message,
      Object.keys(meta).length ? JSON.stringify(meta, null, 2) : '',
    ]
      .filter(Boolean)
      .join(' '),
  ),
)

export function createDomainLogger(service: string) {
  return createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: isDev ? devFormat : coloredProdFormat,
    defaultMeta: { service },
    transports: [new transports.Console()],
  })
}
</file>

<file path="src/infra/logger/winston/winston.provider.ts">
import { Provider } from '@nestjs/common'
import { createDomainLogger } from './winston.config'
import { WINSTON_LOGGER } from './winston.token'

export const WinstonLoggerProvider: Provider = {
  provide: WINSTON_LOGGER,
  useFactory: () => createDomainLogger('api'),
}
</file>

<file path="src/infra/logger/winston/winston.token.ts">
export const WINSTON_LOGGER = Symbol('WINSTON_LOGGER')
</file>

<file path="src/shared/address/enterprise/entities/address.ts">
import { Entity } from '@/core/entities/entity'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { Optional } from '@/core/types/optional'

export interface AddressProps {
  street: string
  number: string
  complement?: string | null
  neighborhood: string
  city: string
  state: string
  zipCode: string
  createdAt: Date
  updatedAt?: Date
  userId?: UniqueEntityID
  clientId?: UniqueEntityID
}

export class Address extends Entity<AddressProps> {
  get street() {
    return this.props.street
  }

  get number() {
    return this.props.number
  }

  get complement() {
    return this.props.complement
  }

  get neighborhood() {
    return this.props.neighborhood
  }

  get city() {
    return this.props.city
  }

  get state() {
    return this.props.state
  }

  get zipCode() {
    return this.props.zipCode
  }

  get userId() {
    return this.props.userId
  }

  get clientId() {
    return this.props.clientId
  }

  get createdAt() {
    return this.props.createdAt
  }

  get updatedAt() {
    return this.props.updatedAt
  }

  static create(
    props: Optional<AddressProps, 'createdAt'>,
    id?: UniqueEntityID,
  ) {
    const now = new Date()
    return new Address(
      {
        ...props,
        createdAt: props.createdAt ?? now,
        updatedAt: props.updatedAt ?? now,
      },
      id,
    )
  }
}
</file>

<file path="src/shared/avatar/application/repositories/avatar-repository.ts">
import type { Avatar } from '../../enterprise/entities/avatar'

export abstract class AvatarRepository {
  abstract findById(id: string): Promise<Avatar | null>
  abstract create(avatar: Avatar): Promise<void>
  abstract delete(id: string): Promise<void>
}
</file>

<file path="src/shared/avatar/application/use-cases/__tests__/upload-and-create-avatar.spec.ts">
import { InMemoryAvatarRepository } from 'test/repositories/avatar/in-memory-avatar-repository'
import { UploadAndCreateAvatarUseCase } from '../upload-and-create-avatar'
import { FakeUploader } from 'test/storage/fake-uploader'
import { AvatarUploadFailedError } from '../errors/avatar-upload-failed-error'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'

let inMemoryAvatarRepository: InMemoryAvatarRepository
let fakeUploader: FakeUploader
let sut: UploadAndCreateAvatarUseCase

describe('Upload and Create Avatar', () => {
  beforeEach(() => {
    inMemoryAvatarRepository = new InMemoryAvatarRepository()
    fakeUploader = new FakeUploader()

    sut = new UploadAndCreateAvatarUseCase(
      inMemoryAvatarRepository,
      fakeUploader,
    )
  })

  it('should upload avatar and persist it', async () => {
    const result = await sut.execute({
      fileName: 'avatar.png',
      fileType: 'image/png',
      body: Buffer.from('fake'),
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      expect(result.value.data).toBeInstanceOf(Avatar)
      expect(result.value.data.url).toEqual(fakeUploader.uploads[0].url)
    }
  })

  it('should return UploadAvatarFailedError when upload fails', async () => {
    vi.spyOn(fakeUploader, 'upload').mockResolvedValueOnce({
      url: null as unknown as string,
    })

    const result = await sut.execute({
      fileName: 'avatar.png',
      fileType: 'image/png',
      body: Buffer.from('fake'),
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(AvatarUploadFailedError)
  })
})
</file>

<file path="src/shared/avatar/application/use-cases/errors/avatar-upload-failed-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class AvatarUploadFailedError extends BaseError {
  constructor(message = 'Failed to upload avatar') {
    super(message, 'AvatarUploadFailedError')
  }
}
</file>

<file path="src/shared/avatar/application/use-cases/errors/invalid-avatar-type-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class InvalidAvatarTypeError extends BaseError {
  constructor(type: string) {
    super(`File type "${type}" is not valid.`, 'InvalidAvatarTypeError')
  }
}
</file>

<file path="src/shared/avatar/enterprise/entities/avatar.ts">
import { Entity } from '@/core/entities/entity'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export interface AvatarProps {
  title: string
  url: string
}

export class Avatar extends Entity<AvatarProps> {
  get title() {
    return this.props.title
  }

  get url() {
    return this.props.url
  }

  static create(props: AvatarProps, id?: UniqueEntityID) {
    const avatar = new Avatar(props, id)

    return avatar
  }
}
</file>

<file path="src/shared/cryptography/hash-comparer.ts">
export abstract class HashComparer {
  abstract compare(plain: string, hash: string): Promise<boolean>
}
</file>

<file path="src/shared/cryptography/hash-generator.ts">
export abstract class HashGenerator {
  abstract hash(plain: string): Promise<string>
}
</file>

<file path="src/shared/cryptography/token-verifier.ts">
export abstract class TokenVerifier {
  abstract verify<T extends object = Record<string, unknown>>(token: string): T
}
</file>

<file path="src/shared/rate-limit/rate-limit.decorator.ts">
import { SetMetadata } from '@nestjs/common'

export interface RateLimitOptions {
  points: number
  duration: number // in seconds
}

export function RateLimit(points: number, duration: number) {
  return SetMetadata('rateLimitOptions', {
    points,
    duration,
  } as RateLimitOptions)
}
</file>

<file path="src/shared/rate-limit/rate-limit.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { Request, Response } from 'express'
import { RateLimitService } from './rate-limit.service'
import { Reflector } from '@nestjs/core'
import type { RateLimitOptions } from './rate-limit.decorator'

@Injectable()
export class RateLimitGuard implements CanActivate {
  constructor(
    private readonly rateLimitService: RateLimitService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>()
    const res = context.switchToHttp().getResponse<Response>()
    const ip: string = req.ip ?? 'unknown'

    const rateLimitOptions = this.reflector.get<RateLimitOptions>(
      'rateLimitOptions',
      context.getHandler(),
    )

    const points =
      rateLimitOptions && typeof rateLimitOptions.points === 'number'
        ? rateLimitOptions.points
        : undefined

    const duration =
      rateLimitOptions && typeof rateLimitOptions.duration === 'number'
        ? rateLimitOptions.duration
        : undefined

    try {
      const result = await this.rateLimitService.consume(ip, points, duration)

      if (!result.allowed) {
        const retryAfterSec = Math.ceil(result.retryAfter / 1000) || 1
        res.setHeader('Retry-After', retryAfterSec)
        throw new HttpException(
          'Too many requests',
          HttpStatus.TOO_MANY_REQUESTS,
        )
      }

      return true
    } catch {
      res.setHeader('Retry-After', 60)
      throw new HttpException('Too many requests', HttpStatus.TOO_MANY_REQUESTS)
    }
  }
}
</file>

<file path="src/shared/rate-limit/rate-limit.module.ts">
import { Module } from '@nestjs/common'
import { RateLimitService } from './rate-limit.service'
import { CacheModule } from '@/infra/cache/cache.module'
import { EnvModule } from '@/infra/env/env.module'

@Module({
  imports: [CacheModule, EnvModule],
  providers: [RateLimitService, CacheModule],
  exports: [RateLimitService],
})
export class RateLimitModule {}
</file>

<file path="src/shared/rate-limit/rate-limit.service.ts">
import { Injectable, Logger } from '@nestjs/common'
import { EnvService } from '@/infra/env/env.service'
import {
  RateLimiterRedis,
  RateLimiterMemory,
  RateLimiterAbstract,
  RateLimiterRes,
} from 'rate-limiter-flexible'
import { RedisService } from '@/infra/cache/redis/redis.service'

type ConsumeResult =
  | { allowed: true; retryAfter?: undefined; source: 'redis' | 'memory' }
  | { allowed: false; retryAfter: number; source: 'redis' | 'memory' }

@Injectable()
export class RateLimitService {
  private limiter: RateLimiterAbstract
  private logger = new Logger(RateLimitService.name)
  private customLimiters = new Map<string, RateLimiterAbstract>()
  private readonly defaultPoints: number
  private readonly defaultDuration: number

  constructor(
    private readonly envService: EnvService,
    private readonly redisService: RedisService,
  ) {
    this.defaultPoints = Number(this.envService.get('RATE_LIMIT_POINTS')) || 100
    this.defaultDuration =
      Number(this.envService.get('RATE_LIMIT_DURATION')) || 60

    if (this.redisService && this.redisService.status === 'ready') {
      this.logger.log('Usando rate limit com Redis')
      this.limiter = new RateLimiterRedis({
        storeClient: this.redisService,
        keyPrefix: 'rate-limit',
        points: this.defaultPoints,
        duration: this.defaultDuration,
        insuranceLimiter: new RateLimiterMemory({
          points: this.defaultPoints,
          duration: this.defaultDuration,
          keyPrefix: 'rate-limit',
        }),
      })
    } else {
      this.logger.warn(
        'Redis n√£o est√° pronto. Usando rate limit em mem√≥ria (modo degradado)',
      )
      this.limiter = new RateLimiterMemory({
        points: this.defaultPoints,
        duration: this.defaultDuration,
        keyPrefix: 'rate-limit',
      })
    }
  }

  async consume(
    key: string,
    points?: number,
    duration?: number,
  ): Promise<ConsumeResult> {
    // Se houver configura√ß√£o customizada, use (ou crie) limiter custom
    if (points !== undefined || duration !== undefined) {
      const customPoints = points ?? this.defaultPoints
      const customDuration = duration ?? this.defaultDuration
      const limiterKey = `custom-${customPoints}-${customDuration}`

      let limiter = this.customLimiters.get(limiterKey)
      if (!limiter) {
        if (this.limiter instanceof RateLimiterRedis) {
          limiter = new RateLimiterRedis({
            storeClient: this.redisService,
            keyPrefix: limiterKey,
            points: customPoints,
            duration: customDuration,
            insuranceLimiter: new RateLimiterMemory({
              points: customPoints,
              duration: customDuration,
              keyPrefix: limiterKey,
            }),
          })
        } else {
          limiter = new RateLimiterMemory({
            points: customPoints,
            duration: customDuration,
            keyPrefix: limiterKey,
          })
        }
        this.customLimiters.set(limiterKey, limiter)
      }
      return this._consumeLimiter(limiter, key, 1)
    }

    // Caso padr√£o: usa limiter global
    return this._consumeLimiter(this.limiter, key, 1)
  }

  private async _consumeLimiter(
    limiter: RateLimiterAbstract,
    key: string,
    points: number,
  ): Promise<ConsumeResult> {
    try {
      await limiter.consume(key, points)
      return {
        allowed: true,
        source: limiter instanceof RateLimiterRedis ? 'redis' : 'memory',
      }
    } catch (err: unknown) {
      if (
        typeof err === 'object' &&
        err !== null &&
        'msBeforeNext' in err &&
        typeof (err as RateLimiterRes).msBeforeNext === 'number'
      ) {
        return {
          allowed: false,
          retryAfter: (err as RateLimiterRes).msBeforeNext,
          source: limiter instanceof RateLimiterRedis ? 'redis' : 'memory',
        }
      }
      this.logger.error('Erro inesperado no rate limit:', err)
      throw err
    }
  }

  clearAll(): void {
    if ('_memoryStorage' in this.limiter) {
      this.limiter._memoryStorage = {}
    }
    this.customLimiters.clear()
  }
}
</file>

<file path="src/shared/storage/uploader.ts">
export interface UploadParams {
  fileName: string
  fileType: string
  body: Buffer
}

export abstract class Uploader {
  abstract upload(params: UploadParams): Promise<{ url: string }>
  abstract delete(fileName: string): Promise<void>
}
</file>

<file path="src/shared/utils/__tests__/circuit-breaker.spec.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { BrokenCircuitError } from 'cockatiel'
import { createCircuitBreaker } from '../circuit-breaker'
import { FakeLogger } from 'test/infra/fake-logger'

const alwaysFail = vi.fn().mockRejectedValue(new Error('external fail'))

describe('createCircuitBreaker', () => {
  let breaker: ReturnType<typeof createCircuitBreaker>
  let fakeLogger: FakeLogger

  beforeEach(() => {
    fakeLogger = new FakeLogger()
    breaker = createCircuitBreaker('test-breaker', fakeLogger)
    alwaysFail.mockClear()
    fakeLogger.clear()
  })

  it('should execute normally before the failure threshold', async () => {
    await expect(breaker.execute(() => Promise.resolve('ok'))).resolves.toBe(
      'ok',
    )
    await expect(breaker.execute(() => Promise.resolve('ok2'))).resolves.toBe(
      'ok2',
    )
    expect(fakeLogger.warnings.length).toBe(0)
    expect(fakeLogger.errors.length).toBe(0)
  })

  it('should open the breaker after reaching the failure threshold', async () => {
    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')

    await expect(breaker.execute(alwaysFail)).rejects.toThrow(
      BrokenCircuitError,
    )
    expect(fakeLogger.warnings.some((msg) => msg.includes('opened'))).toBe(true)
  })

  it('should reset after halfOpenAfter time', async () => {
    vi.useFakeTimers()

    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow(
      BrokenCircuitError,
    )

    vi.advanceTimersByTime(10_000)

    await expect(breaker.execute(alwaysFail)).rejects.toThrow('external fail')
    await expect(breaker.execute(alwaysFail)).rejects.toThrow(
      BrokenCircuitError,
    )

    const alwaysOk = vi.fn().mockResolvedValue('ok')
    vi.advanceTimersByTime(10_000)
    await expect(breaker.execute(alwaysOk)).resolves.toBe('ok')
    await expect(breaker.execute(alwaysOk)).resolves.toBe('ok')

    expect(fakeLogger.warnings.some((msg) => msg.includes('closed'))).toBe(true)

    vi.useRealTimers()
  })
})
</file>

<file path="src/shared/utils/circuit-breaker.ts">
import { circuitBreaker, handleAll, ConsecutiveBreaker } from 'cockatiel'

export function createCircuitBreaker(
  name: string,
  logger: { warn: (msg: string) => void },
) {
  const breaker = circuitBreaker(handleAll, {
    halfOpenAfter: 10_000,
    breaker: new ConsecutiveBreaker(3),
  })

  breaker.onBreak(() => logger.warn(`[CB] ${name} opened (tripped)`))
  breaker.onHalfOpen(() => logger.warn(`[CB] ${name} half-open (testing)`))
  breaker.onReset(() => logger.warn(`[CB] ${name} closed (healthy)`))

  return breaker
}
</file>

<file path="src/shared/utils/retry-with-backoff.ts">
/**
 * retryWithBackoff - Executa uma fun√ß√£o ass√≠ncrona com tentativas autom√°ticas e backoff exponencial.
 *
 * @param fn        Fun√ß√£o que retorna uma Promise<T> (ex: chamada HTTP, email, storage)
 * @param options   retries: n√∫mero de tentativas
 *                  initialDelayMs: delay inicial (em ms)
 *                  factor: fator de multiplica√ß√£o do delay (default 2)
 *                  onRetry: callback a cada tentativa falha
 * @returns         Resultado da Promise, ou lan√ßa erro ap√≥s esgotar tentativas
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options?: {
    retries?: number
    initialDelayMs?: number
    factor?: number
    onRetry?: (err: unknown, attempt: number) => void
  },
): Promise<T> {
  const retries = options?.retries ?? 3
  const factor = options?.factor ?? 2
  let delay = options?.initialDelayMs ?? 300
  let attempt = 0

  while (attempt < retries) {
    try {
      return await fn()
    } catch (err) {
      attempt++
      if (attempt >= retries) throw err
      if (options?.onRetry) options.onRetry(err, attempt)
      await new Promise((resolve) => setTimeout(resolve, delay))
      delay *= factor
    }
  }
  throw new Error('retryWithBackoff: unexpected exit')
}
</file>

<file path="src/shared/utils/with-timeout.ts">
export async function withTimeout<T>(
  promise: Promise<T>,
  ms: number,
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_resolve, reject) =>
      setTimeout(() => reject(new Error('Timeout')), ms),
    ),
  ])
}
</file>

<file path="test/cryptography/fake-hasher.ts">
import type { HashComparer } from '@/shared/cryptography/hash-comparer'
import type { HashGenerator } from '@/shared/cryptography/hash-generator'

export class FakeHasher implements HashGenerator, HashComparer {
  async hash(plain: string): Promise<string> {
    return plain.concat('-hashed')
  }

  async compare(plain: string, hash: string): Promise<boolean> {
    return plain.concat('-hashed') === hash
  }
}
</file>

<file path="test/cryptography/fake-token-verifier.ts">
import type { TokenVerifier } from '@/shared/cryptography/token-verifier'

export class FakeTokenVerifier implements TokenVerifier {
  private tokenToPayloadMap = new Map<string, unknown>()

  setTokenPayload(token: string, payload: unknown): void {
    this.tokenToPayloadMap.set(token, payload)
  }

  verify<T = unknown>(token: string): T {
    const payload = this.tokenToPayloadMap.get(token)

    if (!payload) {
      throw new Error(`Invalid token: ${token}`)
    }

    return payload as T
  }
}
</file>

<file path="test/cryptography/fake-token.ts">
import { TokenRepository } from '@/infra/auth/token-repository'

export class FakeTokenService implements TokenRepository {
  async generateAccessToken(payload: { sub: string; role: string }) {
    const now = Math.floor(Date.now() / 1000)
    const exp = now + 60 * 60 // 1 hour

    const token = JSON.stringify({
      ...payload,
      iat: now,
      exp,
      typ: 'access',
    })

    return { token, expiresIn: exp }
  }

  async generateRefreshToken(payload: {
    sub: string
    role: string
    jti: string
  }) {
    const now = Math.floor(Date.now() / 1000)
    const exp = now + 60 * 60 * 24 * 7 // 7 days

    const token = JSON.stringify({
      ...payload,
      iat: now,
      exp,
      typ: 'refresh',
    })

    return { token, expiresIn: exp }
  }

  async generate(payload: Record<string, unknown>) {
    return JSON.stringify(payload)
  }
}
</file>

<file path="test/e2e/helmet.e2e-spec.ts">
import request from 'supertest'
import { INestApplication } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import helmet from 'helmet'

describe('Helmet Middleware (E2E)', () => {
  let app: INestApplication

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile()

    app = moduleRef.createNestApplication()
    app.use(helmet())
    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  it('should apply security headers via Helmet', async () => {
    const response = await request(app.getHttpServer()).get('/health')

    expect(response.statusCode).toBe(200)
    expect(response.headers['x-content-type-options']).toBe('nosniff')
    expect(response.headers['x-frame-options']).toBe('SAMEORIGIN')
    expect(response.headers['strict-transport-security']).toContain('max-age=')
    expect(response.headers['content-security-policy']).toContain('default-src')
  })
})
</file>

<file path="test/factories/make-audit-log.ts">
import { faker } from '@faker-js/faker'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import {
  AuditLog,
  type AuditLogProps,
} from '@/domain/audit-log/enterprise/entities/audit-log'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaAuditLogMapper } from '@/infra/database/prisma/mappers/audit-log/prisma-audit-log.mapper'

export function makeAuditLog(
  override: Partial<AuditLogProps> = {},
  id?: UniqueEntityID,
) {
  const auditLog = AuditLog.create(
    {
      actorId: faker.string.uuid(),
      actorType: 'USER',
      action: 'create',
      entity: 'User',
      entityId: faker.string.uuid(),
      changes: { name: 'new name' },
      ...override,
    },
    id,
  )

  return auditLog
}

@Injectable()
export class AuditLogFactory {
  constructor(private prisma: PrismaService) {}

  async makePrismaAuditLog(
    data: Partial<AuditLogProps> = {},
  ): Promise<AuditLog> {
    const auditLog = makeAuditLog(data)

    await this.prisma.auditLog.create({
      data: PrismaAuditLogMapper.toPrisma(auditLog),
    })

    return auditLog
  }
}
</file>

<file path="test/factories/make-avatar.ts">
import { faker } from '@faker-js/faker'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaAvatarMapper } from '@/infra/database/prisma/mappers/avatar/prisma-avatar.mapper'
import {
  Avatar,
  type AvatarProps,
} from '@/shared/avatar/enterprise/entities/avatar'

export function makeAvatar(
  override: Partial<AvatarProps> = {},
  id?: UniqueEntityID,
) {
  const avatar = Avatar.create(
    {
      title: faker.lorem.word(),
      url: faker.image.url(),
      ...override,
    },
    id,
  )

  return avatar
}

@Injectable()
export class AvatarFactory {
  constructor(private prisma: PrismaService) {}

  async makePrismaAvatar(data: Partial<AvatarProps> = {}): Promise<Avatar> {
    const avatar = makeAvatar(data)

    await this.prisma.avatar.create({
      data: PrismaAvatarMapper.toPrisma(avatar),
    })

    return avatar
  }
}
</file>

<file path="test/infra/fake-circuit-breaker.ts">
type ExecuteFn<T> = () => Promise<T> | T

export class FakeCircuitBreaker {
  private shouldFail = false
  private failWithError: unknown = new Error('Circuit open')
  private calls: number = 0

  setOpen(error?: unknown) {
    this.shouldFail = true
    if (error) this.failWithError = error
  }

  reset() {
    this.shouldFail = false
    this.failWithError = new Error('Circuit open')
  }

  getCalls() {
    return this.calls
  }

  async execute<T>(fn: ExecuteFn<T>): Promise<T> {
    this.calls++
    if (this.shouldFail) {
      throw this.failWithError
    }
    return await fn()
  }
}
</file>

<file path="test/infra/fake-logger.ts">
import type { LoggerPort } from '@/infra/logger/winston/logger.interface'

export class FakeLogger implements LoggerPort {
  public logs: string[] = []
  public warnings: string[] = []
  public errors: string[] = []
  public debugs: string[] = []

  info(message: string) {
    this.logger('info', message)
  }

  warn(message: string) {
    this.logger('warn', message)
  }

  error(message: string) {
    this.logger('error', message)
  }

  debug(message: string) {
    this.logger('debug', message)
  }

  private logger(level: 'info' | 'warn' | 'error' | 'debug', message: string) {
    switch (level) {
      case 'info':
        this.logs.push(message)
        break
      case 'warn':
        this.warnings.push(message)
        break
      case 'error':
        this.errors.push(message)
        break
      case 'debug':
        this.debugs.push(message)
        break
    }
  }

  clear() {
    this.logs = []
    this.warnings = []
    this.errors = []
    this.debugs = []
  }
}
</file>

<file path="test/utils/wait-for.ts">
/**
 * This function loops through a function rerunning all assertions
 * inside of it until it gets a truthy result.
 *
 * If the maximum duration is reached, it then rejects.
 *
 * @param expectations A function containing all tests assertions
 * @param maxDuration Maximum wait time before rejecting
 */
export async function waitFor(
  assertions: () => void,
  maxDuration = 1000,
): Promise<void> {
  return new Promise((resolve, reject) => {
    let elapsedTime = 0

    const interval = setInterval(() => {
      elapsedTime += 10

      try {
        assertions()
        clearInterval(interval)
        resolve()
      } catch (err) {
        if (elapsedTime >= maxDuration) {
          reject(err)
        }
      }
    }, 10)
  })
}
</file>

<file path="test/setup-e2e.ts">
import { config } from 'dotenv'

import { PrismaClient } from '@prisma/client'
import { randomUUID } from 'node:crypto'
import { execSync } from 'node:child_process'
import { DomainEvents } from '@/core/events/domain-events'
import { Redis } from 'ioredis'
import { envSchema } from '@/infra/env/env'

config({ path: '.env', override: true })
config({ path: '.env.test', override: true })

const env = envSchema.parse(process.env)

const prisma = new PrismaClient()
const redis = new Redis({
  host: env.REDIS_HOST,
  port: env.REDIS_PORT,
  db: env.REDIS_DB,
})

function generateUniqueDatabaseURL(schemaId: string) {
  if (!env.DATABASE_URL) {
    throw new Error('Please provider a DATABASE_URL environment variable')
  }

  const url = new URL(env.DATABASE_URL)

  url.searchParams.set('schema', schemaId)

  return url.toString()
}

const schemaId = randomUUID()

beforeAll(async () => {
  const databaseURL = generateUniqueDatabaseURL(schemaId)

  process.env.DATABASE_URL = databaseURL

  DomainEvents.shouldRun = false

  await redis.flushdb()

  execSync('npx prisma migrate deploy')
})

afterAll(async () => {
  await prisma.$executeRawUnsafe(`DROP SCHEMA IF EXISTS "${schemaId}" CASCADE`)
  await prisma.$disconnect()
})
</file>

<file path=".env.test.example">
AWS_BUCKET_NAME="bucket-test"
REDIS_DB=1
</file>

<file path=".eslintrc.json">
{
  "extends": "@rocketseat/eslint-config/node",
  "parserOptions": {
    "project": "./tsconfig.eslint.json"
  },
  "rules": {
    "no-useless-constructor": "off",
    "no-new": "off",
    "dot-notation": "off"
  },
  "settings": {
    "import/resolver": {
      "typescript": {
        "project": "./tsconfig.json"
      }
    }
  }
}
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local
.env.test

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma

private_key.pem
public_key.pem
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  database:
    image: postgres:latest
    container_name: powerbrake-database
    environment:
      POSTGRES_USER: ${DATABASE_USERNAME}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
    ports:
      - '5432:5432'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U $${POSTGRES_USER}']
      interval: 5s
      retries: 5

  redis:
    image: redis:7.2-alpine
    container_name: powerbrake-redis
    ports:
      - '6379:6379'
    command: ['redis-server', '--appendonly', 'yes']
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 3s
      retries: 5
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "entryFile": "infra/main",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# powerbrake-backend
</file>

<file path="ROADMAP.md">
# üß≠ Projeto Backend ‚Äî Roadmap T√©cnico

Este roadmap define todas as etapas de implementa√ß√£o, testes, automa√ß√µes e boas pr√°ticas previstas para que o projeto alcance alta robustez, performance e escalabilidade.

---

## ‚úÖ Implementado

- [x] Autentica√ß√£o com access/refresh token
- [x] Auditoria baseada em eventos de dom√≠nio
- [x] M√≥dulo de avatar com upload
- [x] M√≥dulo de endere√ßos reutiliz√°vel (`shared/address`)
- [x] CASL para RBAC
- [x] Testes unit√°rios e e2e com cobertura s√≥lida
- [x] Parallel Routes no frontend
- [x] DTOs com Swagger e exemplos

---

## üß™ Testes

### üîπ Qualidade de C√≥digo

- [x] Static analysis (TypeScript estrito, ESLint)
- [x] Mutation testing

### üîπ Testes Automatizados

- [x] Unit√°rios com InMemory
- [x] E2E com banco real e truncamento
- [ ] [ ] Teste de troca de senha via token
- [ ] [ ] Testes e2e para exporta√ß√£o de logs
- [ ] [ ] Testes e2e para auditoria com pagina√ß√£o

### üîπ Performance

- [ ] Smoke test
- [ ] Load test
- [ ] Stress test
- [ ] Spike test
- [ ] Soak test

### üîπ Seguran√ßa

- [ ] Inje√ß√£o SQL
- [ ] XSS
- [ ] Rate limit com bypass
- [ ] Testes com tokens inv√°lidos/expirados

### üîπ Recupera√ß√£o

- [ ] Chaos test (banco indispon√≠vel, Redis fora do ar)
- [ ] Circuit breaker test

---

## üê≥ Docker & Ambientes

- [ ] Docker Compose para local simulando Railway (512MB RAM, 1vCPU)
- [ ] Configs de Docker separadas para:
  - [x] `local`
  - [ ] `dev`
  - [ ] `staging`
  - [ ] `prod`
- [ ] Seeders autom√°ticos por ambiente
- [ ] Script para desligar ambiente inativo por mais de 1 hora

---

## üìà Observabilidade & Monitoramento

- [ ] Prometheus para m√©tricas
- [ ] Loki para logs
- [ ] OpenTelemetry para tracing
- [ ] Grafana para dashboards
- [ ] Health check completo (Redis, banco, email, storage, etc.)
- [ ] Alertas autom√°ticos para:
  - Lat√™ncia
  - Falha de login
  - Falhas 5xx por rota

---

## üîê Seguran√ßa Avan√ßada

- [ ] Headers seguros via `helmet`
- [ ] CSP configurado
- [ ] Rate limiting por IP + rota
- [ ] CSRF token (caso frontend full SSR ou SPA com cookies)
- [ ] Logs de acesso indevido
- [ ] Detectar comportamentos an√¥malos

---

## ‚öôÔ∏è CI/CD & Automa√ß√£o

- [ ] GitHub Actions:
  - [x] Teste unit√°rio
  - [x] Lint
  - [ ] Threshold de coverage (ex: 80%)
  - [ ] Smoke test no deploy
- [ ] Pr√©-commit hooks (lint, test, format)
- [ ] Rollback autom√°tico de migration
- [ ] Script para:
  - [ ] Rodar seeds por ambiente
  - [ ] Rodar rollback
  - [ ] Desligar dev/staging se ocioso

---

## ‚ú® Extra

- [ ] Exporta√ß√£o de audit logs (CSV/JSON)
- [ ] Fila para eventos ass√≠ncronos (BullMQ, Redis Streams)
- [ ] Previews autom√°ticos por PR
- [ ] CLI personalizado (`pnpm cli`)
- [ ] Feature Flags (ex: `enableNewPasswordFlow`)
- [ ] Versionamento por rota: `/v1/version` retornando git hash + data

---

## üìö Documenta√ß√£o & Organiza√ß√£o

- [ ] `docs/architecture.md` com:
  - Estrutura de m√≥dulos
  - Regras de dom√≠nio
  - Padr√µes de testes
- [ ] `docs/scripts.md` com:
  - Como rodar rollback, seeds, stress test
- [ ] `docs/contributing.md` com:
  - Checklist para revis√£o de PR
  - Estrutura de commits e branches
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.eslint.json">
{
  "extends": "./tsconfig.json",
  "include": [
    "src/**/*.ts",
    "test/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "esModuleInterop": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false,
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "types": [
      "vitest/globals",
      "multer"
    ]
  }
}
</file>

<file path="vitest.config.e2e.mjs">
import swc from 'unplugin-swc'
import { defineConfig, configDefaults } from 'vitest/config'
import tsConfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  test: {
    include: ['**/*.e2e-spec.ts'],
    globals: true,
    root: './',
    exclude: [...configDefaults.exclude, '**/data/pg/**'],
    setupFiles: ['./test/setup-e2e.ts'],
  },
  plugins: [
    tsConfigPaths(),
    swc.vite({
      module: { type: 'es6' },
    }),
  ],
})
</file>

<file path="vitest.config.mjs">
import swc from 'unplugin-swc'
import { defineConfig } from 'vitest/config'
import tsConfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  test: {
    globals: true,
    root: './',
  },
  plugins: [
    tsConfigPaths(),
    swc.vite({
      module: { type: 'es6' },
    }),
  ],
})
</file>

<file path="src/core/entities/watched-list.ts">
export abstract class WatchedList<T> {
  public currentItems: T[]
  private initial: T[]
  private new: T[]
  private removed: T[]

  constructor(initialItems?: T[]) {
    this.currentItems = initialItems || []
    this.initial = initialItems || []
    this.new = []
    this.removed = []
  }

  abstract compareItems(a: T, b: T): boolean

  public getItems(): T[] {
    return this.currentItems
  }

  public getNewItems(): T[] {
    return this.new
  }

  public getRemovedItems(): T[] {
    return this.removed
  }

  private isCurrentItem(item: T): boolean {
    return (
      this.currentItems.filter((v: T) => this.compareItems(item, v)).length !==
      0
    )
  }

  private isNewItem(item: T): boolean {
    return this.new.filter((v: T) => this.compareItems(item, v)).length !== 0
  }

  private isRemovedItem(item: T): boolean {
    return (
      this.removed.filter((v: T) => this.compareItems(item, v)).length !== 0
    )
  }

  private removeFromNew(item: T): void {
    this.new = this.new.filter((v) => !this.compareItems(v, item))
  }

  private removeFromCurrent(item: T): void {
    this.currentItems = this.currentItems.filter(
      (v) => !this.compareItems(item, v),
    )
  }

  private removeFromRemoved(item: T): void {
    this.removed = this.removed.filter((v) => !this.compareItems(item, v))
  }

  private wasAddedInitially(item: T): boolean {
    return (
      this.initial.filter((v: T) => this.compareItems(item, v)).length !== 0
    )
  }

  public exists(item: T): boolean {
    return this.isCurrentItem(item)
  }

  public add(item: T): void {
    if (this.isRemovedItem(item)) {
      this.removeFromRemoved(item)
    }

    if (!this.isNewItem(item) && !this.wasAddedInitially(item)) {
      this.new.push(item)
    }

    if (!this.isCurrentItem(item)) {
      this.currentItems.push(item)
    }
  }

  public remove(item: T): void {
    this.removeFromCurrent(item)

    if (this.isNewItem(item)) {
      this.removeFromNew(item)

      return
    }

    if (!this.isRemovedItem(item)) {
      this.removed.push(item)
    }
  }

  public update(items: T[]): void {
    const newItems = items.filter((a) => {
      return !this.getItems().some((b) => this.compareItems(a, b))
    })

    const removedItems = this.getItems().filter((a) => {
      return !items.some((b) => this.compareItems(a, b))
    })

    this.currentItems = items
    this.new = newItems
    this.removed = removedItems
  }

  public equals(other: WatchedList<T>): boolean {
    const a = this.getItems()
    const b = other.getItems()

    if (a.length !== b.length) return false

    return a.every((itemA) =>
      b.some((itemB) => this.compareItems(itemA, itemB)),
    )
  }
}
</file>

<file path="src/core/events/domain-event.ts">
import { UniqueEntityID } from '../entities/unique-entity-id'

export interface DomainEvent {
  occurredAt: Date
  getAggregateId(): UniqueEntityID
}
</file>

<file path="src/core/events/domain-events.spec.ts">
import { DomainEvent } from '../events/domain-event'
import { UniqueEntityID } from '../entities/unique-entity-id'
import { AggregateRoot } from '../entities/aggregate-root'
import { DomainEvents } from '@/core/events/domain-events'
import { vi } from 'vitest'

class CustomAggregateCreated implements DomainEvent {
  public occurredAt: Date
  private aggregate: CustomAggregate // eslint-disable-line

  constructor(aggregate: CustomAggregate) {
    this.aggregate = aggregate
    this.occurredAt = new Date()
  }

  public getAggregateId(): UniqueEntityID {
    return this.aggregate.id
  }
}

class CustomAggregate extends AggregateRoot<null> {
  static create() {
    const aggregate = new CustomAggregate(null)

    aggregate.addDomainEvent(new CustomAggregateCreated(aggregate))

    return aggregate
  }
}

describe('domain events', () => {
  it('should be able to dispatch and listen to events', async () => {
    const callbackSpy = vi.fn()

    // Subscriber cadastrado (ouvindo o evento de "resposta criada")
    DomainEvents.register(callbackSpy, CustomAggregateCreated.name)

    // Estou criando uma resposta por√©m SEM salvar no banco
    const aggregate = CustomAggregate.create()

    // Estou assegurando que o evento foi criado por√©m N√ÉO foi disparado
    expect(aggregate.domainEvents).toHaveLength(1)

    // Estou salvando a resposta no banco de dados e assim disparando o evento
    DomainEvents.dispatchEventsForAggregate(aggregate.id)

    // O subscriber ouve o evento e faz o que precisa ser feito com o dado
    expect(callbackSpy).toHaveBeenCalled()

    expect(aggregate.domainEvents).toHaveLength(0)
  })
})
</file>

<file path="src/domain/audit-log/application/repositories/audit-log-repository.ts">
import type { CursorPaginationParams } from '@/core/repositories/pagination-params'
import { AuditLog, type ActorType } from '../../enterprise/entities/audit-log'

export type ListAuditLogsFilters = {
  actorType: ActorType
  actorEmail?: string
  actorId?: string
  entity?: string
  action?: string
  entityId?: string
  startDate?: Date
  endDate?: Date
}

export abstract class AuditLogRepository {
  abstract create(auditLog: AuditLog): Promise<void>
  abstract findMany(
    filters: ListAuditLogsFilters,
    pagination: CursorPaginationParams,
  ): Promise<[AuditLog[], hasNextPage: boolean]>

  abstract resolveActorIdByEmail(
    actorType: ActorType,
    email: string,
  ): Promise<string | undefined>
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-logged-in.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { OnUserLoggedIn } from '@/domain/audit-log/application/subscribers/user/on-user-logged-in'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Logged In (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserLoggedIn(createAuditLogUseCase)
  })

  it('should create audit log when user logs in', async () => {
    const user = makeUser()
    inMemoryUsersRepository.create(user)

    user.login()
    inMemoryUsersRepository.dispatchEvent(user.id)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:logged_in',
        entity: 'USER',
        entityId: user.id.toString(),
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-password-changed.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { OnUserPasswordChanged } from '@/domain/audit-log/application/subscribers/user/on-user-password-changed'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { makeUser } from 'test/factories/make-user'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { DomainEvents } from '@/core/events/domain-events'

let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let inMemoryUsersRepository: InMemoryUsersRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Password Changed (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserPasswordChanged(createAuditLogUseCase)
  })

  it('should create audit log when user password is changed', async () => {
    const user = makeUser()

    inMemoryUsersRepository.create(user)

    user.updatePassword('new-password')

    inMemoryUsersRepository.save(user)

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: user.id.toString(),
        action: 'user:password_changed',
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/__tests__/on-user-requested-password-reset.spec.ts">
import { vi } from 'vitest'
import { waitFor } from 'test/utils/wait-for'
import { makeUser } from 'test/factories/make-user'
import { DomainEvents } from '@/core/events/domain-events'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { InMemoryAuditLogRepository } from 'test/repositories/audit-log/in-memory-audit-log.repository'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { OnUserRequestedPasswordReset } from '@/domain/audit-log/application/subscribers/user/on-user-requested-password-reset'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAuditLogRepository: InMemoryAuditLogRepository
let createAuditLogUseCase: CreateAuditLogUseCase
let createAuditLogSpy: ReturnType<typeof vi.spyOn>

describe('On User Requested Password Reset (subscriber)', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryAuditLogRepository = new InMemoryAuditLogRepository(
      inMemoryUsersRepository,
    )
    createAuditLogUseCase = new CreateAuditLogUseCase(
      inMemoryAuditLogRepository,
    )
    createAuditLogSpy = vi.spyOn(createAuditLogUseCase, 'execute')

    new OnUserRequestedPasswordReset(createAuditLogUseCase)
  })

  it('should create audit log when user requests password reset', async () => {
    const user = makeUser()
    inMemoryUsersRepository.create(user)

    user.requestPasswordReset()

    DomainEvents.dispatchEventsForAggregate(user.id)

    await waitFor(() => {
      expect(createAuditLogSpy).toHaveBeenCalled()
    })

    expect(inMemoryAuditLogRepository.items).toHaveLength(1)
    expect(inMemoryAuditLogRepository.items[0]).toEqual(
      expect.objectContaining({
        actorId: user.id.toString(),
        actorType: 'USER',
        action: 'user:requested_password_reset',
        entity: 'USER',
        entityId: user.id.toString(),
      }),
    )
  })
})
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-logged-in.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserLoggedInEvent } from '@/domain/user/enterprise/events/user-logged-in-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserLoggedIn implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserLoggedInEvent.name)
  }

  async handle(event: UserLoggedInEvent): Promise<void> {
    const user = event.user

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:logged_in',
      entity: 'USER',
      entityId: user.id.toString(),
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-password-changed.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserPasswordChangedEvent } from '@/domain/user/enterprise/events/user-password-changed-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserPasswordChanged implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserPasswordChangedEvent.name)
  }

  private async handle(event: UserPasswordChangedEvent): Promise<void> {
    const { user } = event

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:password_changed',
      entity: 'USER',
      entityId: user.id.toString(),
      changes: {
        passwordChanged: true,
      },
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-role-changed.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserRoleChangedEvent } from '@/domain/user/enterprise/events/user-role-changed-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserRoleChanged implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserRoleChangedEvent.name)
  }

  async handle(event: UserRoleChangedEvent): Promise<void> {
    const { user, actorId, previousRole } = event

    await this.createAuditLog.execute({
      actorId,
      actorType: 'USER',
      action: 'user:role_updated',
      entity: 'USER',
      entityId: user.id.toString(),
      changes: {
        role: {
          before: previousRole,
          after: user.role,
        },
      },
    })
  }
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-updated.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserUpdatedEvent } from '@/domain/user/enterprise/events/user-updated-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

type UserUpdatedChanges = {
  name: {
    before: string
    after: string
  }
  avatarId: {
    before: string | null | undefined
    after: string | null | undefined
  }
  addresses: {
    before: unknown
    after: unknown
  }
}

@Injectable()
export class OnUserUpdated implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserUpdatedEvent.name)
  }

  async handle(event: UserUpdatedEvent): Promise<void> {
    const { user, previousData } = event

    const changes: UserUpdatedChanges = {
      name: {
        before: previousData.name,
        after: user.name,
      },
      avatarId: {
        before: previousData.avatarId?.toString(),
        after: user.avatarId?.toString(),
      },
      addresses: {
        before: previousData.addresses,
        after: user.addresses,
      },
    }

    await this.createAuditLog.execute({
      actorId: user.id.toString(),
      actorType: 'USER',
      action: 'user:updated',
      entity: 'USER',
      entityId: user.id.toString(),
      changes,
    })
  }
}
</file>

<file path="src/domain/user/application/repositories/user-address-repository.ts">
import type { Address } from '@/shared/address/enterprise/entities/address'

export abstract class UserAddressRepository {
  abstract findManyByUserId(userId: string): Promise<Address[]>
  abstract upsertManyForUser(
    userId: string,
    addresses: Address[],
  ): Promise<void>
}
</file>

<file path="src/domain/user/application/repositories/user-avatar-repository.ts">
export abstract class UserAvatarRepository {
  abstract attachAvatarToUser(userId: string, avatarId: string): Promise<void>
}
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user-password.spec.ts">
import { describe, it, expect, beforeEach } from 'vitest'
import { EditUserPasswordUseCase } from '../edit-user-password'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { FakeHasher } from 'test/cryptography/fake-hasher'
import { UserNotFoundError } from '../errors'
import { UserUnauthorizedError } from '../errors/user-unauthorized-error'
import { FakeRefreshTokenService } from 'test/cryptography/fake-refresh-token'
import { FakeCacheService } from 'test/cache/fake-cache'

let usersRepository: InMemoryUsersRepository
let hashComparer: FakeHasher
let hashGenerator: FakeHasher
let fakeCacheService: FakeCacheService
let refreshTokenService: FakeRefreshTokenService
let sut: EditUserPasswordUseCase

describe('Edit User Password', () => {
  beforeEach(() => {
    usersRepository = new InMemoryUsersRepository()
    hashComparer = new FakeHasher()
    hashGenerator = new FakeHasher()
    fakeCacheService = new FakeCacheService()
    refreshTokenService = new FakeRefreshTokenService(fakeCacheService)

    sut = new EditUserPasswordUseCase(
      usersRepository,
      hashComparer,
      hashGenerator,
      refreshTokenService,
    )
  })

  it('should update the password and revoke other sessions', async () => {
    const user = makeUser({
      passwordHash: await hashGenerator.hash('old-pass'),
    })
    await usersRepository.create(user)

    const result = await sut.execute({
      userId: user.id.toString(),
      currentPassword: 'old-pass',
      newPassword: 'new-pass',
      currentJti: 'current-jti',
    })

    expect(result.isRight()).toBe(true)

    const updated = await usersRepository.findById(user.id.toString())
    const passwordMatch = await hashComparer.compare(
      'new-pass',
      updated!.passwordHash,
    )

    expect(passwordMatch).toBe(true)
  })

  it('should return UserNotFoundError if user does not exist', async () => {
    const result = await sut.execute({
      userId: 'non-existent-id',
      currentPassword: 'any-password',
      newPassword: 'new-password',
      currentJti: 'current-jti',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })

  it('should return UserUnauthorizedError if current password is invalid', async () => {
    const user = makeUser({
      passwordHash: await hashGenerator.hash('correct-password'),
    })
    await usersRepository.create(user)

    hashComparer.compare = vi.fn().mockResolvedValue(false)

    const result = await sut.execute({
      userId: user.id.toString(),
      currentPassword: 'wrong-password',
      newPassword: 'new-password',
      currentJti: 'current-jti',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserUnauthorizedError)
  })

  it('should revoke all other sessions except current', async () => {
    const user = makeUser({
      passwordHash: await hashGenerator.hash('old-pass'),
    })
    await usersRepository.create(user)

    await fakeCacheService.set('refresh_token:abc', user.id.toString())
    await fakeCacheService.set('refresh_token:def', user.id.toString())
    await fakeCacheService.set('refresh_token:ghi', 'another-user-id')

    const result = await sut.execute({
      userId: user.id.toString(),
      currentPassword: 'old-pass',
      newPassword: 'new-pass',
      currentJti: 'def',
    })

    expect(result.isRight()).toBe(true)

    const remainingKeys = await fakeCacheService.keys('refresh_token:*')
    expect(remainingKeys).toContain('refresh_token:def')
    expect(remainingKeys).not.toContain('refresh_token:abc')
    expect(remainingKeys).toContain('refresh_token:ghi')
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user-role.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserRoleUseCase } from '../edit-user-role'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: EditUserRoleUseCase

describe('Edit User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new EditUserRoleUseCase(inMemoryUsersRepository)
  })

  it('should be able to edit a user', async () => {
    const adminUser = makeUser({ role: 'ADMIN' })
    const user = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: user.id.toString(),
      role: 'SUPERVISOR',
      actorId: adminUser.id.toString(),
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        role: 'SUPERVISOR',
      }),
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/find-user-by-email.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserNotFoundError } from '../errors/user-not-found'
import { FindUserByEmailUseCase } from '../find-user-by-email'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: FindUserByEmailUseCase

describe('Find User By Id', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new FindUserByEmailUseCase(inMemoryUsersRepository)
  })

  it('should be able to find a user by email', async () => {
    const user = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      email: 'johndoe@example.com',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        name: user.name,
        email: user.email,
      }),
    })
  })

  it('should not be able to find a non-existing user', async () => {
    const result = await sut.execute({
      email: 'johndoe2@example.com',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/list-users.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { ListUsersUseCase } from '../list-users'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: ListUsersUseCase

describe('List Users', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new ListUsersUseCase(inMemoryUsersRepository)
  })

  it('should return paginated users with metadata', async () => {
    for (let i = 1; i <= 35; i++) {
      await inMemoryUsersRepository.create(
        makeUser({
          name: `User ${i}`,
          email: `user${i}@example.com`,
          createdAt: new Date(2024, 0, i),
        }),
      )
    }

    const result = await sut.execute({ page: 2, perPage: 10 })

    expect(result.isRight()).toBe(true)

    if (result.isRight()) {
      const { data: users, meta } = result.value

      expect(users).toHaveLength(10)
      expect(users[0].name).toBe('User 25')
      expect(meta).toEqual({
        total: 35,
        count: 10,
        perPage: 10,
        totalPages: 4,
        currentPage: 2,
        nextPage: 3,
        previousPage: 1,
      })
    }
  })

  it('should return default perPage = 20 when not specified', async () => {
    for (let i = 1; i <= 22; i++) {
      await inMemoryUsersRepository.create(makeUser({}))
    }

    const result = await sut.execute({ page: 1 })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      expect(result.value.data).toHaveLength(20)
      expect(result.value.meta.perPage).toBe(20)
    }
  })

  it('should return nextPage as null on last page', async () => {
    for (let i = 1; i <= 15; i++) {
      await inMemoryUsersRepository.create(makeUser({}))
    }

    const result = await sut.execute({ page: 2, perPage: 10 })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      expect(result.value.meta.nextPage).toBe(null)
      expect(result.value.meta.previousPage).toBe(1)
    }
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/user-address-watcher.spec.ts">
import { UserAddressWatcher } from '../user-address-watcher'
import { makeAddress } from 'test/factories/make-address'

describe('User Address Watcher', () => {
  it('should return false if addresses are identical', () => {
    const base = makeAddress()

    const watcher = new UserAddressWatcher([base])
    watcher.update([
      makeAddress({
        street: base.street,
        number: base.number,
        complement: base.complement,
        neighborhood: base.neighborhood,
        city: base.city,
        state: base.state,
        zipCode: base.zipCode,
      }),
    ])

    expect(watcher.hasChanged()).toBe(false)
    expect(watcher.getUpdatedAddresses()).toHaveLength(1)
  })

  it('should return true if any field was changed', () => {
    const base = makeAddress()

    const changed = makeAddress({
      street: 'New Street',
      number: base.number,
      complement: base.complement,
      neighborhood: base.neighborhood,
      city: base.city,
      state: base.state,
      zipCode: base.zipCode,
    })

    const watcher = new UserAddressWatcher([base])
    watcher.update([changed])

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should return true if a new address was added', () => {
    const base = makeAddress()

    const watcher = new UserAddressWatcher([base])
    watcher.update([base, makeAddress()])

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should return true if an address was removed', () => {
    const a1 = makeAddress()
    const a2 = makeAddress()

    const watcher = new UserAddressWatcher([a1, a2])
    watcher.update([a1])

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should correctly return updated addresses', () => {
    const a1 = makeAddress()
    const a2 = makeAddress()

    const watcher = new UserAddressWatcher([a1])
    watcher.update([a1, a2])

    const updated = watcher.getUpdatedAddresses()

    expect(updated).toHaveLength(2)
    expect(updated).toEqual(expect.arrayContaining([a1, a2]))
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/user-avatar-watcher.spec.ts">
import { UserAvatarWatcher } from '../user-avatar-watcher'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

describe('User Avatar Watcher', () => {
  it('should return false if avatar has not changed', () => {
    const avatarId = new UniqueEntityID('avatar-1')
    const watcher = new UserAvatarWatcher(avatarId)

    watcher.update(new UniqueEntityID('avatar-1'))

    expect(watcher.hasChanged()).toBe(false)
  })

  it('should return true if avatar has changed', () => {
    const watcher = new UserAvatarWatcher(new UniqueEntityID('avatar-1'))

    watcher.update(new UniqueEntityID('avatar-2'))

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should return true if avatar was removed', () => {
    const watcher = new UserAvatarWatcher(new UniqueEntityID('avatar-1'))

    watcher.update(null)

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should return true if avatar was added', () => {
    const watcher = new UserAvatarWatcher(null)

    watcher.update(new UniqueEntityID('avatar-2'))

    expect(watcher.hasChanged()).toBe(true)
  })

  it('should return the updated avatar id', () => {
    const watcher = new UserAvatarWatcher(null)
    const newId = new UniqueEntityID('avatar-999')

    watcher.update(newId)

    expect(watcher.getUpdatedId()).toEqual(newId)
  })
})
</file>

<file path="src/domain/user/application/use-cases/edit-user-password.ts">
import { Either, left, right } from '@/core/either'
import { UserNotFoundError } from './errors'
import { UserUnauthorizedError } from './errors/user-unauthorized-error'
import { UsersRepository } from '../repositories/user-repository'
import { HashComparer } from '@/shared/cryptography/hash-comparer'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'
import { Injectable } from '@nestjs/common'

interface EditUserPasswordUseCaseRequest {
  userId: string
  currentPassword: string
  newPassword: string
  currentJti: string
}

type EditUserPasswordUseCaseResponse = Either<
  UserNotFoundError | UserUnauthorizedError,
  void
>

@Injectable()
export class EditUserPasswordUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private hashComparer: HashComparer,
    private hashGenerator: HashGenerator,
    private refreshTokenRepository: RefreshTokenRepository,
  ) {}

  async execute({
    userId,
    currentPassword,
    newPassword,
    currentJti,
  }: EditUserPasswordUseCaseRequest): Promise<EditUserPasswordUseCaseResponse> {
    const user = await this.usersRepository.findById(userId)

    if (!user) {
      return left(new UserNotFoundError())
    }

    const isPasswordValid = await this.hashComparer.compare(
      currentPassword,
      user.passwordHash,
    )

    if (!isPasswordValid) {
      return left(new UserUnauthorizedError())
    }

    const newPasswordHash = await this.hashGenerator.hash(newPassword)
    user.updatePassword(newPasswordHash)

    await this.usersRepository.save(user)

    await this.refreshTokenRepository.revokeAllForUserExcept(userId, currentJti)

    return right(undefined)
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user-role.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'
import type { Role } from '@prisma/client'

type EditUserRoleUseCaseRequest = {
  id: string
  role: Role
  actorId: string
}

type EditUserRoleUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserRoleUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
    role,
    actorId,
  }: EditUserRoleUseCaseRequest): Promise<EditUserRoleUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    user.updateRole(role, actorId)

    await this.usersRepository.save(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user-status.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'

type EditUserStatusUseCaseRequest = {
  id: string
  actorId: string
}

type EditUserStatusUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserStatusUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
    actorId,
  }: EditUserStatusUseCaseRequest): Promise<EditUserStatusUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    user.toggleActive(actorId)

    await this.usersRepository.save(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/list-users.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'
import type { PaginationMeta } from '@/core/repositories/pagination-params'

type ListUserUseCaseRequest = {
  page?: number
  perPage?: number
}

type ListUserUseCaseResponse = Either<
  null,
  {
    data: User[]
    meta: PaginationMeta
  }
>

@Injectable()
export class ListUsersUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    page = 1,
    perPage = 20,
  }: ListUserUseCaseRequest): Promise<ListUserUseCaseResponse> {
    const [users, total] = await this.usersRepository.list({
      page,
      perPage,
    })

    const totalPages = Math.ceil(total / perPage)

    return right({
      data: users,
      meta: {
        total,
        count: users.length,
        perPage,
        totalPages,
        currentPage: page,
        nextPage: page < totalPages ? page + 1 : null,
        previousPage: page > 1 ? page - 1 : null,
      },
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/user-address-watcher.ts">
import { Address } from '@/shared/address/enterprise/entities/address'

export class UserAddressWatcher {
  private current: Address[]
  private updated: Address[]

  constructor(current: Address[]) {
    this.current = current
    this.updated = [...current]
  }

  update(newAddresses: Address[]) {
    this.updated = [...newAddresses]
  }

  hasChanged(): boolean {
    if (this.current.length !== this.updated.length) return true

    return this.current.some((curr, i) => {
      const next = this.updated[i]
      return (
        curr.street !== next.street ||
        curr.number !== next.number ||
        curr.complement !== next.complement ||
        curr.neighborhood !== next.neighborhood ||
        curr.city !== next.city ||
        curr.state !== next.state ||
        curr.zipCode !== next.zipCode
      )
    })
  }

  getUpdatedAddresses(): Address[] {
    return this.updated
  }
}
</file>

<file path="src/domain/user/enterprise/entities/user-address-list.ts">
import { WatchedList } from '@/core/entities/watched-list'
import type { Address } from '@/shared/address/enterprise/entities/address'

export class UserAddressList extends WatchedList<Address> {
  compareItems(a: Address, b: Address): boolean {
    return a.id.equals(b.id)
  }
}
</file>

<file path="src/domain/user/enterprise/entities/user-avatar.ts">
import { Entity } from '@/core/entities/entity'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export interface UserAvatarProps {
  userId: UniqueEntityID
  avatarId: UniqueEntityID
}

export class UserAvatar extends Entity<UserAvatarProps> {
  get userId() {
    return this.props.userId
  }

  get avatarId() {
    return this.props.avatarId
  }

  static create(props: UserAvatarProps, id?: UniqueEntityID) {
    const userAvatar = new UserAvatar(props, id)

    return userAvatar
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-active-status-changed-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import type { User } from '../entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserActiveStatusChangedEvent implements DomainEvent {
  public occurredAt: Date
  public user: User
  public previousIsActive: boolean
  public actorId: string

  constructor(user: User, actorId: string, previousIsActive: boolean) {
    this.user = user
    this.previousIsActive = previousIsActive
    this.actorId = actorId
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-created-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import type { User } from '../entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class UserCreatedEvent implements DomainEvent {
  public occurredAt: Date
  public user: User
  public actorId: string

  constructor(user: User, actorId: string) {
    this.user = user
    this.actorId = actorId
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-password-changed-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { User } from '../entities/user'

export class UserPasswordChangedEvent implements DomainEvent {
  public occurredAt: Date
  public user: User

  constructor(user: User) {
    this.user = user
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-role-changed-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { User } from '../entities/user'

export class UserRoleChangedEvent implements DomainEvent {
  public occurredAt: Date
  public user: User
  public actorId: string
  public previousRole: string

  constructor(user: User, actorId: string, previousRole: string) {
    this.occurredAt = new Date()
    this.user = user
    this.actorId = actorId
    this.previousRole = previousRole
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/domain/user/enterprise/events/user-updated-event.ts">
import { DomainEvent } from '@/core/events/domain-event'
import type { User } from '../entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { UserAddressList } from '../entities/user-address-list'

type PreviousData = {
  name: string
  avatarId: UniqueEntityID | null | undefined
  addresses: UserAddressList
}

export class UserUpdatedEvent implements DomainEvent {
  public occurredAt: Date
  public user: User
  public previousData: PreviousData

  constructor(user: User, previousData: PreviousData) {
    this.user = user
    this.previousData = previousData
    this.occurredAt = new Date()
  }

  getAggregateId(): UniqueEntityID {
    return this.user.id
  }
}
</file>

<file path="src/infra/auth/casl/models/avatar.ts">
import { z } from 'zod'
import { roleSchema } from '../roles'

export const avatarSchema = z.object({
  sub: z.string(),
  role: roleSchema,
  __typename: z.literal('Avatar').default('Avatar'),
})

export type Avatar = z.infer<typeof avatarSchema>
</file>

<file path="src/infra/auth/casl/models/user.ts">
import { z } from 'zod'

import { roleSchema } from '../roles'

export const userSchema = z.object({
  sub: z.string(),
  role: roleSchema,
  __typename: z.literal('User').default('User'),
})

export type User = z.infer<typeof userSchema>
</file>

<file path="src/infra/auth/casl/subjects/user.ts">
import { z } from 'zod'
import { userSchema } from '../models/user'

export const userSubject = z.tuple([
  z.union([
    z.literal('manage'),
    z.literal('create'),
    z.literal('list'),
    z.literal('read'),
    z.literal('update'),
    z.literal('activate'),
    z.literal('deactivate'),
    z.literal('update-role'),
  ]),
  z.union([z.literal('User'), userSchema]),
])

export type UserSubject = z.infer<typeof userSubject>
</file>

<file path="src/infra/auth/casl/casl-ability.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { CaslAbilityFactory } from './ability.factory'
import { CHECK_POLICIES_KEY, PolicyHandler } from './check-policies.decorator'

@Injectable()
export class CaslAbilityGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || []

    const request = context.switchToHttp().getRequest()
    const user = request.user
    const ability = this.caslAbilityFactory.defineAbilityFor(user)

    const isAllowed = policyHandlers.every((handler) =>
      handler(ability, context),
    )

    if (!isAllowed) {
      throw new ForbiddenException('Acesso negado')
    }

    return true
  }
}
</file>

<file path="src/infra/auth/casl/check-policies.decorator.ts">
import { SetMetadata, type ExecutionContext } from '@nestjs/common'
import { AppAbility } from './ability.factory'

export type PolicyHandler = (
  ability: AppAbility,
  context: ExecutionContext,
) => boolean

export const CHECK_POLICIES_KEY = 'check_policies'
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers)
</file>

<file path="src/infra/auth/token-repository.ts">
export abstract class TokenRepository {
  abstract generateAccessToken(payload: {
    sub: string
    role: string
    jti: string
  }): Promise<{
    token: string
    expiresIn: number
  }>

  abstract generateRefreshToken(payload: {
    sub: string
    role: string
    jti: string
  }): Promise<{
    token: string
    expiresIn: number
  }>
}
</file>

<file path="src/infra/cache/redis/redis-cache-repository.ts">
import { Injectable } from '@nestjs/common'
import { CacheRepository } from '../cache-repository'
import { RedisService } from './redis.service'

@Injectable()
export class RedisCacheRepository implements CacheRepository {
  private EXPIRATION_SECONDS = 60 * 10 // 10 minutes
  constructor(private redis: RedisService) {}

  async set(key: string, value: string, ttlInSeconds?: number): Promise<void> {
    await this.redis.set(
      key,
      value,
      'EX',
      ttlInSeconds || this.EXPIRATION_SECONDS,
    )
  }

  get(key: string): Promise<string | null> {
    return this.redis.get(key)
  }

  async del(key: string): Promise<number> {
    return await this.redis.del(key)
  }

  async keys(pattern: string): Promise<string[]> {
    return await this.redis.keys(pattern)
  }
}
</file>

<file path="src/infra/cache/redis/redis.service.ts">
import { EnvService } from '@/infra/env/env.service'
import { Injectable } from '@nestjs/common'
import { Redis } from 'ioredis'

@Injectable()
export class RedisService extends Redis {
  private _commandTimeout: number

  constructor(envService: EnvService) {
    super({
      host: envService.get('REDIS_HOST'),
      port: envService.get('REDIS_PORT'),
      db: envService.get('REDIS_DB'),
      connectTimeout: envService.get('REDIS_COMMAND_TIMEOUT'),
    })

    this._commandTimeout = envService.get('REDIS_COMMAND_TIMEOUT')
  }

  get commandTimeout() {
    return this._commandTimeout
  }

  onModuleDestroy() {
    return this.disconnect()
  }
}
</file>

<file path="src/infra/cache/cache-repository.ts">
export abstract class CacheRepository {
  abstract set(key: string, value: string, ttlInSeconds?: number): Promise<void>
  abstract get(key: string): Promise<string | null>
  abstract del(key: string | string[]): Promise<number>
  abstract keys(pattern: string): Promise<string[]>
}
</file>

<file path="src/infra/cache/cache.module.ts">
import { Module } from '@nestjs/common'
import { EnvModule } from '../env/env.module'
import { CacheRepository } from './cache-repository'
import { RedisCacheRepository } from './redis/redis-cache-repository'
import { RedisService } from './redis/redis.service'

@Module({
  imports: [EnvModule],
  providers: [
    RedisService,
    {
      provide: CacheRepository,
      useClass: RedisCacheRepository,
    },
  ],
  exports: [CacheRepository, RedisService],
})
export class CacheModule {}
</file>

<file path="src/infra/cryptography/cryptography.module.ts">
import { Module } from '@nestjs/common'

import { JwtEncrypter } from './jwt-encrypter'
import { BcryptHasher } from './bcrypt-hasher'
import { Encrypter } from '@/shared/cryptography/encrypter'
import { HashComparer } from '@/shared/cryptography/hash-comparer'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import { TokenVerifier } from '@/shared/cryptography/token-verifier'
import { JwtVerifier } from './jwt-verifier'

@Module({
  providers: [
    { provide: Encrypter, useClass: JwtEncrypter },
    { provide: HashComparer, useClass: BcryptHasher },
    { provide: HashGenerator, useClass: BcryptHasher },
    { provide: TokenVerifier, useClass: JwtVerifier },
  ],
  exports: [Encrypter, HashComparer, HashGenerator, TokenVerifier],
})
export class CryptographyModule {}
</file>

<file path="src/infra/database/prisma/mappers/audit-log/prisma-audit-log.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { AuditLog } from '@/domain/audit-log/enterprise/entities/audit-log'
import { Prisma, AuditLog as PrismaAuditLog } from '@prisma/client'

export class PrismaAuditLogMapper {
  static toDomain(raw: PrismaAuditLog): AuditLog {
    return AuditLog.create(
      {
        actorId: raw.actorId,
        actorType: raw.actorType,
        action: raw.action,
        entity: raw.entity,
        entityId: raw.entityId,
        changes: raw.changes
          ? typeof raw.changes === 'object'
            ? raw.changes
            : JSON.parse(raw.changes as string)
          : null,
        createdAt: raw.createdAt,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(auditLog: AuditLog): Prisma.AuditLogCreateInput {
    return {
      id: auditLog.id.toString(),
      actorId: auditLog.actorId.toString(),
      actorType: auditLog.actorType,
      action: auditLog.action,
      entity: auditLog.entity,
      entityId: auditLog.entityId.toString(),
      changes: auditLog.changes
        ? JSON.stringify(auditLog.changes)
        : Prisma.JsonNull,
      createdAt: auditLog.createdAt,
    }
  }
}
</file>

<file path="src/infra/database/prisma/mappers/user/prisma-user-address.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Address } from '@/shared/address/enterprise/entities/address'
import { Address as PrismaAddress, Prisma } from '@prisma/client'

export class PrismaUserAddressMapper {
  static toDomain(raw: PrismaAddress): Address {
    return Address.create(
      {
        city: raw.city,
        neighborhood: raw.neighborhood,
        number: raw.number,
        state: raw.state,
        street: raw.street,
        zipCode: raw.zipCode,
        complement: raw.complement,
        userId: raw.userId ? new UniqueEntityID(raw.userId) : undefined,
        createdAt: raw.createdAt,
        updatedAt: raw.updatedAt,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(address: Address): Prisma.AddressCreateInput {
    return {
      id: address.id.toString(),
      user: {
        connect: {
          id: address.userId ? address.userId.toString() : undefined,
        },
      },
      street: address.street,
      number: address.number,
      complement: address.complement ?? undefined,
      neighborhood: address.neighborhood,
      city: address.city,
      state: address.state,
      zipCode: address.zipCode,
      createdAt: address.createdAt,
      updatedAt: address.updatedAt ?? new Date(),
    }
  }
}
</file>

<file path="src/infra/database/prisma/mappers/user/prisma-user.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { User } from '@/domain/user/enterprise/entities/user'
import { UserAddressList } from '@/domain/user/enterprise/entities/user-address-list'
import { User as PrismaUser, Prisma, Address } from '@prisma/client'
import { PrismaUserAddressMapper } from './prisma-user-address.mapper'

export class PrismaUserMapper {
  static toDomain(raw: PrismaUser & { addresses: Address[] }): User {
    return User.create(
      {
        name: raw.name,
        email: raw.email,
        passwordHash: raw.passwordHash,
        isActive: raw.isActive,
        role: raw.role,
        avatarId: raw.avatarId ? new UniqueEntityID(raw.avatarId) : undefined,
        addresses: new UserAddressList(
          raw.addresses.map((address) =>
            PrismaUserAddressMapper.toDomain(address),
          ),
        ),
        createdAt: raw.createdAt,
        updatedAt: raw.updatedAt,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(user: User): Prisma.UserCreateInput {
    const base: Prisma.UserCreateInput = {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      passwordHash: user.passwordHash,
      isActive: user.isActive,
      role: user.role,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    }

    if (user.avatarId) {
      base.avatar = {
        connect: {
          id: user.avatarId?.toString(),
        },
      }
    }
    return base
  }
}
</file>

<file path="src/infra/database/prisma/repositories/audit-log/prisma-audit-log.repository.ts">
import { Injectable } from '@nestjs/common'
import {
  AuditLogRepository,
  ListAuditLogsFilters,
} from '@/domain/audit-log/application/repositories/audit-log-repository'
import { AuditLog } from '@/domain/audit-log/enterprise/entities/audit-log'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaAuditLogMapper } from '../../mappers/audit-log/prisma-audit-log.mapper'
import { ActorType, type Prisma } from '@prisma/client'
import type { CursorPaginationParams } from '@/core/repositories/pagination-params'

@Injectable()
export class PrismaAuditLogRepository implements AuditLogRepository {
  constructor(private prisma: PrismaService) {}

  async create(auditLog: AuditLog): Promise<void> {
    const data = PrismaAuditLogMapper.toPrisma(auditLog)
    await this.prisma.auditLog.create({ data })
  }

  async resolveActorIdByEmail(
    actorType: ActorType,
    email: string,
  ): Promise<string | undefined> {
    if (actorType === 'USER') {
      const user = await this.prisma.user.findUnique({ where: { email } })
      return user?.id
    }

    if (actorType === 'CLIENT') {
      const client = await this.prisma.client.findUnique({ where: { email } })
      return client?.id
    }

    return undefined
  }

  async findMany(
    filters: ListAuditLogsFilters,
    pagination: CursorPaginationParams,
  ): Promise<[AuditLog[], boolean]> {
    const { actorType, actorId, entity, action, entityId, startDate, endDate } =
      filters

    const { cursor, limit } = pagination

    const createdAtRange: { gte?: Date; lte?: Date } = {}
    if (startDate) createdAtRange.gte = startDate
    if (endDate) createdAtRange.lte = endDate

    const where: Prisma.AuditLogWhereInput = {
      actorType,
      ...(actorId ? { actorId } : {}),
      ...(entity ? { entity } : {}),
      ...(action ? { action } : {}),
      ...(entityId ? { entityId } : {}),
      ...(startDate || endDate ? { createdAt: createdAtRange } : {}),
    }

    const results = await this.prisma.auditLog.findMany({
      where,
      take: limit + 1,
      orderBy: { createdAt: 'desc' },
      ...(cursor
        ? {
            skip: 1,
            cursor: { id: cursor },
          }
        : {}),
    })

    const hasNextPage = results.length > limit
    const items = hasNextPage ? results.slice(0, -1) : results

    return [items.map(PrismaAuditLogMapper.toDomain), hasNextPage]
  }
}
</file>

<file path="src/infra/database/prisma/repositories/user/tests/prisma-user-repository.e2e-spec.ts">
import { UserDatabaseModule } from './../user-database.module'
import { INestApplication, VersioningType } from '@nestjs/common'
import { UserFactory } from 'test/factories/make-user'
import { CacheRepository } from '@/infra/cache/cache-repository'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { CacheModule } from '@/infra/cache/cache.module'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'

describe('Prisma Users Repository (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let cacheRepository: CacheRepository
  let usersRepository: UsersRepository

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CacheModule],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    cacheRepository = moduleRef.get(CacheRepository)
    usersRepository = moduleRef.get(UsersRepository)

    await app.init()
  })

  it('should cache user details', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    const userDetails = await usersRepository.findById(id)

    const cached = await cacheRepository.get(`user:${id}:details`)

    if (!cached) {
      throw new Error()
    }

    expect(JSON.parse(cached)).toEqual(
      expect.objectContaining({
        id: userDetails?.id.toString(),
      }),
    )
  })

  it('should return cached user details on subsequent calls', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    let cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).toBeNull()

    await usersRepository.findById(id)

    cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).not.toBeNull()

    if (!cached) {
      throw new Error()
    }

    const userDetails = await usersRepository.findById(id)

    expect(JSON.parse(cached)).toEqual(
      expect.objectContaining({
        id: userDetails?.id.toString(),
      }),
    )
  })

  it('should reset user details cache when saving the user', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    await cacheRepository.set(
      `user:${id}:details`,
      JSON.stringify({ empty: true }),
    )

    await usersRepository.save(user)

    const cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).toBeNull()
  })

  it('should clear caches when deleting the user', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    await cacheRepository.set(`user:${id}:details`, JSON.stringify(user))
    await cacheRepository.set('users', JSON.stringify([user]))

    await usersRepository.delete(user)

    const cachedDetails = await cacheRepository.get(`user:${id}:details`)
    const cachedList = await cacheRepository.get('users')

    expect(cachedDetails).toBeNull()
    expect(cachedList).toBeNull()
  })
})
</file>

<file path="src/infra/database/prisma/repositories/user/prisma-user-address-repository.ts">
import { Injectable } from '@nestjs/common'
import { UserAddressRepository } from '@/domain/user/application/repositories/user-address-repository'
import { PrismaService } from '../../prisma.service'
import type { Address } from '@/shared/address/enterprise/entities/address'
import { PrismaUserAddressMapper } from '../../mappers/user/prisma-user-address.mapper'

@Injectable()
export class PrismaUserAddressRepository implements UserAddressRepository {
  constructor(private prisma: PrismaService) {}

  async findManyByUserId(userId: string): Promise<Address[]> {
    const addresses = await this.prisma.address.findMany({
      where: { userId },
    })

    return addresses.map(PrismaUserAddressMapper.toDomain)
  }

  async upsertManyForUser(userId: string, addresses: Address[]): Promise<void> {
    await this.prisma.$transaction(async (tx) => {
      await tx.address.deleteMany({ where: { userId } })

      for (const address of addresses) {
        const data = PrismaUserAddressMapper.toPrisma(address)
        await tx.address.create({ data })
      }
    })
  }
}
</file>

<file path="src/infra/database/prisma/repositories/user/prisma-user-avatar-repository.ts">
import { Injectable } from '@nestjs/common'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import { PrismaService } from '../../prisma.service'

@Injectable()
export class PrismaUserAvatarRepository implements UserAvatarRepository {
  constructor(private prisma: PrismaService) {}

  async attachAvatarToUser(userId: string, avatarId: string): Promise<void> {
    await this.prisma.avatar.update({
      where: { id: avatarId },
      data: { userId },
    })
  }
}
</file>

<file path="src/infra/database/prisma/repositories/user/user-database.module.ts">
import { Module } from '@nestjs/common'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { CacheModule } from '@/infra/cache/cache.module'
import { PrismaUsersRepository } from './prisma-users-repository'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import { PrismaUserAvatarRepository } from './prisma-user-avatar-repository'
import { UserFactory } from 'test/factories/make-user'
import { PrismaService } from '../../prisma.service'
import { UserAddressRepository } from '@/domain/user/application/repositories/user-address-repository'
import { PrismaUserAddressRepository } from './prisma-user-address-repository'

@Module({
  imports: [CacheModule],
  providers: [
    PrismaService,
    {
      provide: UsersRepository,
      useClass: PrismaUsersRepository,
    },
    {
      provide: UserAvatarRepository,
      useClass: PrismaUserAvatarRepository,
    },
    {
      provide: UserAddressRepository,
      useClass: PrismaUserAddressRepository,
    },
    UserFactory,
  ],
  exports: [
    PrismaService,
    UsersRepository,
    UserAvatarRepository,
    UserAddressRepository,
    UserFactory,
  ],
})
export class UserDatabaseModule {}
</file>

<file path="src/infra/events/user/__tests__/on-user-created.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { TokenService } from '@/infra/auth/token.service'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'
import { DomainEvents } from '@/core/events/domain-events'
import { waitFor } from 'test/utils/wait-for'

describe('User Created Event (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let tokenService: TokenService
  let userFactory: UserFactory

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, CryptographyModule, UserDatabaseModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    tokenService = moduleRef.get(TokenService)
    userFactory = moduleRef.get(UserFactory)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create an audit log when user is created', async () => {
    const admin = await userFactory.makePrismaUser({ role: 'ADMIN' })

    const accessToken = await tokenService.generateAccessToken({
      sub: admin.id.toString(),
      role: admin.role,
      jti: randomUUID(),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users')
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send({
        name: 'Alice Smith',
        email: 'alice@example.com',
        password: '12345678',
        role: 'MANAGER',
        addresses: [
          {
            street: 'Rua Um',
            number: '123',
            neighborhood: 'Centro',
            city: 'S√£o Paulo',
            state: 'SP',
            zipCode: '00000-000',
          },
        ],
      })

    expect(response.statusCode).toBe(201)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: admin.id.toString(),
          action: 'user:created',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog).toMatchObject({
        actorId: admin.id.toString(),
        actorType: 'USER',
        action: 'user:created',
        entity: 'USER',
      })
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/forgot-password.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { RateLimitService } from '@/shared/rate-limit/rate-limit.service'
import type { User } from '@/domain/user/enterprise/entities/user'

describe('Forgot Password (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let rateLimitService: RateLimitService
  let adminUser: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    rateLimitService = app.get(RateLimitService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
    rateLimitService.clearAll()

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  it('[204] Success ‚Üí should return 204 even if user exists or not', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({ email: adminUser.email })

    expect(response.statusCode).toBe(204)
  })

  it('[204] Success ‚Üí should return 204 even if user does NOT exist', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({ email: 'nonexistent@example.com' })

    expect(response.statusCode).toBe(204)
  })

  it('[400] Validation ‚Üí should return 400 if email is missing', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({})

    expect(response.statusCode).toBe(400)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 400,
        error: 'Bad Request',
      }),
    )
  })

  it('[422] Validation ‚Üí should return 422 if email is invalid format', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({ email: 'invalid-email-format' })

    expect(response.statusCode).toBe(422)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 422,
        error: 'Unprocessable Entity',
        message: expect.any(String),
      }),
    )
  })

  it('[429] should return 429 after exceeding rate limit', async () => {
    for (let i = 0; i < 3; i++) {
      await request(app.getHttpServer())
        .post('/v1/users/forgot-password')
        .send({ email: adminUser.email })
    }

    const response = await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({ email: adminUser.email })
      .expect(429)
    expect(response.headers['retry-after']).toBeDefined()
  })
})
</file>

<file path="src/infra/http/controllers/user/forgot-password.controller.ts">
import {
  Controller,
  Post,
  Body,
  HttpCode,
  UsePipes,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { ForgotPasswordUseCase } from '@/domain/user/application/use-cases/forgot-password'
import { ZodValidationPipe } from '@/infra/http/pipes/zod-validation.pipe'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  ApiTags,
  ApiOperation,
  ApiNoContentResponse,
  ApiBody,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { ForgotPasswordRequestDto } from '../../dtos/requests/user'
import { z } from 'zod'
import { EnvService } from '@/infra/env/env.service'
import { Public } from '@/infra/auth/public'
import { RateLimit } from '@/shared/rate-limit/rate-limit.decorator'
import { RateLimitGuard } from '@/shared/rate-limit/rate-limit.guard'

const forgotPasswordBodySchema = z.object({
  email: z.string().email(),
})

type ForgotPasswordBodySchema = z.infer<typeof forgotPasswordBodySchema>

@ApiTags('Users')
@ServiceTag('user')
@UseFilters(UserErrorFilter)
@Public()
@Controller({ path: 'users', version: '1' })
export class ForgotPasswordController {
  constructor(
    private forgotPasswordUseCase: ForgotPasswordUseCase,
    private env: EnvService,
  ) {}

  @Post('forgot-password')
  @UseGuards(RateLimitGuard)
  @RateLimit(3, 60)
  @HttpCode(204)
  @UsePipes(new ZodValidationPipe(forgotPasswordBodySchema))
  @ApiOperation({ summary: 'Solicitar redefini√ß√£o de senha' })
  @ApiNoContentResponse({ description: 'Token enviado por e-mail' })
  @ApiBody({ type: ForgotPasswordRequestDto })
  async handle(@Body() body: ForgotPasswordBodySchema) {
    const baseUrl = this.env.get('RESET_PASSWORD_URL')
    const result = await this.forgotPasswordUseCase.execute({
      email: body.email,
      resetPasswordUrl: baseUrl,
    })

    if (result.isLeft()) {
      throw result.value
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/refresh-token.controller.ts">
import { Controller, Post, Headers, UseFilters, HttpCode } from '@nestjs/common'
import { Public } from '@/infra/auth/public'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  ApiBadRequestResponse,
  ApiHeader,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { RefreshUserTokenUseCase } from '@/domain/user/application/use-cases/refresh-user-token'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import { WrongCredentialsDto } from '../../dtos/error/user'
import { RefreshTokenResponseDto } from '../../dtos/response/user'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Public()
@Controller({ path: 'users', version: '1' })
export class RefreshTokenController {
  constructor(private refreshUserToken: RefreshUserTokenUseCase) {}

  @Post('refresh')
  @HttpCode(200)
  @ApiOperation({
    summary: 'Refresh access token',
    description:
      'Renews the access token using a valid refresh token. The refresh token must be passed in the `Authorization` header.',
  })
  @ApiHeader({
    name: 'Authorization',
    description: 'Bearer {refresh_token}',
  })
  @ApiOkResponse({
    description: 'New access token issued',
    type: RefreshTokenResponseDto,
  })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(@Headers('authorization') authHeader: string) {
    const refreshToken = authHeader?.replace('Bearer ', '')

    const result = await this.refreshUserToken.execute({ refreshToken })

    if (result.isLeft()) {
      throw result.value
    }

    return {
      access_token: result.value.accessToken,
      refresh_token: result.value.refreshToken,
      expiresIn: result.value.expiresIn,
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/reset-password.controller.ts">
import {
  Controller,
  Post,
  Body,
  HttpCode,
  UsePipes,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { ResetPasswordUseCase } from '@/domain/user/application/use-cases/reset-password'
import { ZodValidationPipe } from '@/infra/http/pipes/zod-validation.pipe'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  ApiTags,
  ApiOperation,
  ApiNoContentResponse,
  ApiBadRequestResponse,
  ApiBody,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { z } from 'zod'
import { Public } from '@/infra/auth/public'
import { ResetPasswordRequestDto } from '../../dtos/requests/user'
import { RateLimit } from '@/shared/rate-limit/rate-limit.decorator'
import { RateLimitGuard } from '@/shared/rate-limit/rate-limit.guard'

export const resetPasswordBodySchema = z.object({
  token: z.string().nonempty(),
  password: z.string().min(8),
})

export type ResetPasswordBodySchema = z.infer<typeof resetPasswordBodySchema>

@ApiTags('Users')
@ServiceTag('user')
@UseFilters(UserErrorFilter)
@Public()
@Controller({ path: 'users', version: '1' })
export class ResetPasswordController {
  constructor(private resetPasswordUseCase: ResetPasswordUseCase) {}

  @Post('reset-password')
  @UseGuards(RateLimitGuard)
  @RateLimit(3, 60)
  @HttpCode(204)
  @UsePipes(new ZodValidationPipe(resetPasswordBodySchema))
  @ApiOperation({ summary: 'Reset user password using token' })
  @ApiNoContentResponse({ description: 'Password reset successfully' })
  @ApiBadRequestResponse({ description: 'Invalid token or data' })
  @ApiBody({ type: ResetPasswordRequestDto })
  async handle(@Body() body: { token: string; password: string }) {
    const result = await this.resetPasswordUseCase.execute(body)

    if (result.isLeft()) {
      throw result.value
    }
  }
}
</file>

<file path="src/infra/http/dtos/error/user/index.ts">
export * from './user-inactive.dto'
export * from './wrong-credentials.dto'
export * from './user-already-exists.dto'
export * from './invalid-role-transition.dto'
export * from './user-not-found.dto'
export * from './user-forbidden.dto'
export * from './user-unauthorized.dto'
</file>

<file path="src/infra/http/dtos/error/user/user-inactive.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic/forbidden.dto'

export class UserInactiveDto extends ForbiddenDto {
  @ApiProperty({ example: 'User inactive' })
  declare message: string
}
</file>

<file path="src/infra/http/filters/app-error.filter.ts">
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  Logger,
} from '@nestjs/common'
import { Response } from 'express'
import { ZodError } from 'zod'
import { BaseError } from '@/core/errors/use-case-error'

@Catch()
export class AppErrorFilter implements ExceptionFilter {
  private readonly logger = new Logger(AppErrorFilter.name)

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp()
    const res = ctx.getResponse<Response>()

    if (exception instanceof ZodError) {
      res.status(422).json({
        statusCode: 422,
        error: 'Unprocessable Entity',
        message: exception.errors.map((e) => ({
          path: e.path.join('.'),
          message: e.message,
        })),
      })
      return
    }

    if (exception instanceof BaseError) {
      const status = this.mapDomainErrorToStatus(exception.name)
      res.status(status).json({
        statusCode: status,
        error: this.statusToText(status),
        message: exception.message,
      })
      return
    }

    if (exception instanceof HttpException) {
      const status = exception.getStatus()
      const body = exception.getResponse()
      res.status(status).json({
        statusCode: status,
        error: this.statusToText(status),
        ...(typeof body === 'string' ? { message: body } : body),
      })
      return
    }

    this.logger.error(exception)
    res.status(500).json({
      statusCode: 500,
      error: 'Internal Server Error',
      message: 'Internal server error',
    })
  }

  protected mapDomainErrorToStatus(name: string): number {
    return (
      {
        InvalidAvatarTypeError: 400,
      }[name] ?? 400
    )
  }

  private statusToText(code: number): string {
    return (
      (
        {
          400: 'Bad Request',
          401: 'Unauthorized',
          403: 'Forbidden',
          404: 'Not Found',
          409: 'Conflict',
          422: 'Unprocessable Entity',
          429: 'Too Many Requests',
          500: 'Internal Server Error',
        } as const
      )[code] ?? 'Error'
    )
  }
}
</file>

<file path="src/infra/http/filters/avatar-error.filter.ts">
import { Catch } from '@nestjs/common'
import { AppErrorFilter } from './app-error.filter'
import { InvalidAvatarTypeError } from '@/shared/avatar/application/use-cases/errors/invalid-avatar-type-error'
import { AvatarUploadFailedError } from '@/shared/avatar/application/use-cases/errors/avatar-upload-failed-error'

@Catch()
export class AvatarErrorFilter extends AppErrorFilter {
  protected override mapDomainErrorToStatus(name: string): number {
    switch (name) {
      case InvalidAvatarTypeError.name:
        return 400
      case AvatarUploadFailedError.name:
        return 500
      default:
        return super.mapDomainErrorToStatus(name)
    }
  }
}
</file>

<file path="src/infra/http/filters/user-error.filter.ts">
import { Catch } from '@nestjs/common'
import { AppErrorFilter } from './app-error.filter'
import {
  UserAlreadyExistsError,
  UserNotFoundError,
} from '@/domain/user/application/use-cases/errors'
import { WrongCredentialsError } from '@/domain/user/application/use-cases/errors/wrong-credentials-error'
import { UserInactiveError } from '@/domain/user/application/use-cases/errors/user-inactive-error'
import { InvalidRoleTransitionError } from '@/domain/user/application/use-cases/errors/invalid-role-transition-error'
import { UserUnauthorizedError } from '@/domain/user/application/use-cases/errors/user-unauthorized-error'

@Catch()
export class UserErrorFilter extends AppErrorFilter {
  protected override mapDomainErrorToStatus(name: string): number {
    switch (name) {
      case UserUnauthorizedError.name:
      case WrongCredentialsError.name:
        return 401
      case UserInactiveError.name:
      case InvalidRoleTransitionError.name:
        return 403
      case UserNotFoundError.name:
        return 404
      case UserAlreadyExistsError.name:
        return 409
      default:
        return super.mapDomainErrorToStatus(name)
    }
  }
}
</file>

<file path="src/infra/http/indicators/s3-health.indicator.ts">
import { Injectable } from '@nestjs/common'
import { HealthIndicatorResult } from '@nestjs/terminus'
import { Uploader } from '@/shared/storage/uploader'

@Injectable()
export class S3HealthIndicator {
  constructor(private uploader: Uploader) {}

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    const healthCheckFileBaseName = `healthcheck-${Date.now()}.txt`
    let actualUploadedFileName: string | null = null

    try {
      const uploadResult = await this.uploader.upload({
        fileName: healthCheckFileBaseName,
        fileType: 'text/plain',
        body: Buffer.from('health-check'),
      })
      actualUploadedFileName = uploadResult.url

      return {
        [key]: { status: 'up' },
      }
    } catch (error) {
      console.error('S3 Health check upload failed:', error)
      return {
        [key]: { status: 'down' },
      }
    } finally {
      if (actualUploadedFileName) {
        try {
          await this.uploader.delete(actualUploadedFileName)
        } catch (deleteError) {
          console.error(
            `Failed to delete health check file ${actualUploadedFileName}:`,
            deleteError,
          )
        }
      }
    }
  }
}
</file>

<file path="src/infra/http/presenters/user.presenter.ts">
import type { User } from '@/domain/user/enterprise/entities/user'

export class UserPresenter {
  static toHTTP(user: User) {
    return {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isActive: user.isActive,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      addresses: user.addresses.getItems().map((address) => ({
        id: address.id.toString(),
        street: address.street,
        number: address.number,
        neighborhood: address.neighborhood,
        complement: address.complement,
        city: address.city,
        state: address.state,
        zipCode: address.zipCode,
      })),
    }
  }
}
</file>

<file path="src/infra/logger/winston/logger.interceptor.ts">
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  HttpException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { Observable, tap, catchError, throwError } from 'rxjs'

import { SERVICE_TAG } from '@/infra/decorators/service-tag.decorator'
import { LoggerService } from './logger.service'

@Injectable()
export class RequestLoggingInterceptor
  implements NestInterceptor<unknown, unknown>
{
  constructor(
    private readonly logger: LoggerService,
    private readonly reflector: Reflector,
  ) {}

  intercept(
    context: ExecutionContext,
    next: CallHandler<unknown>,
  ): Observable<unknown> {
    const http = context.switchToHttp()
    const req = http.getRequest()
    const res = http.getResponse()
    const start = Date.now()

    const service =
      this.reflector.get<string>(SERVICE_TAG, context.getClass()) ?? 'api'

    const baseMeta = {
      service,
      route: req.originalUrl,
      httpMethod: req.method,
    }

    return next.handle().pipe(
      tap(() => {
        const status = res.statusCode
        this.logger.info(`[${status}] Request handled`, {
          ...baseMeta,
          timeToComplete: Date.now() - start,
        })
      }),

      catchError((err) => {
        const status = err instanceof HttpException ? err.getStatus() : 500

        this.logger.error(`[${status}] ${err.message ?? 'Unhandled error'}`, {
          ...baseMeta,
          timeToComplete: Date.now() - start,
        })

        return throwError(() => err)
      }),
    )
  }
}
</file>

<file path="src/infra/logger/winston/logger.service.ts">
import { Injectable, Inject } from '@nestjs/common'
import { Logger } from 'winston'
import { WINSTON_LOGGER } from './winston.token'
import type { LoggerPort } from './logger.interface'

@Injectable()
export class LoggerService implements LoggerPort {
  constructor(@Inject(WINSTON_LOGGER) private readonly logger: Logger) {}

  info(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.info(msg, meta)
  }

  warn(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.warn(msg, meta)
  }

  error(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.error(msg, meta)
  }

  debug(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.debug(msg, meta)
  }
}
</file>

<file path="src/infra/mail/mail-repository.ts">
export abstract class MailRepository {
  abstract verify(): Promise<void>
  abstract send(params: {
    to: string
    subject: string
    html: string
  }): Promise<void>
}
</file>

<file path="src/infra/main.ts">
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { EnvService } from './env/env.service'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import { VersioningType } from '@nestjs/common'
import { AppErrorFilter } from './http/filters/app-error.filter'
import helmet from 'helmet'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.enableVersioning({
    type: VersioningType.URI,
  })

  app.useGlobalFilters(new AppErrorFilter())
  app.use(helmet())

  const swaggerConfig = new DocumentBuilder()
    .setTitle('Powerbrake API')
    .setDescription('Documenta√ß√£o da API do projeto')
    .setVersion('1.0')
    .addBearerAuth()
    .build()

  const document = SwaggerModule.createDocument(app, swaggerConfig)
  SwaggerModule.setup('docs', app, document)

  const envService = app.get(EnvService)
  const port = envService.get('APP_PORT')

  await app.listen(port)
}
bootstrap()
</file>

<file path="src/shared/cryptography/encrypter.ts">
export abstract class Encrypter {
  abstract encrypt(
    payload: Record<string, unknown>,
    expiresInSeconds?: number,
  ): Promise<string>
}
</file>

<file path="test/cache/fake-cache.ts">
import type { CacheRepository } from '@/infra/cache/cache-repository'

export class FakeCacheService implements CacheRepository {
  private store = new Map<string, { value: string; expiresAt?: number }>()

  async set(key: string, value: string, ttlInSeconds?: number): Promise<void> {
    const expiresAt = ttlInSeconds
      ? Date.now() + ttlInSeconds * 1000
      : undefined
    this.store.set(key, { value, expiresAt })
  }

  async get(key: string): Promise<string | null> {
    const record = this.store.get(key)
    if (!record) return null

    if (record.expiresAt && Date.now() > record.expiresAt) {
      this.store.delete(key)
      return null
    }

    return record.value
  }

  async del(key: string | string[]): Promise<number> {
    const keys = Array.isArray(key) ? key : [key]
    let count = 0

    for (const k of keys) {
      if (this.store.delete(k)) count++
    }

    return count
  }

  async keys(pattern: string): Promise<string[]> {
    // Escape antes e depois substitui * por .*
    const escaped = pattern.replace(/[-[\]{}()+?.,\\^$|#\s]/g, '\\$&')
    const regex = new RegExp('^' + escaped.replace(/\*/g, '.*') + '$')

    return Array.from(this.store.keys()).filter((key) => regex.test(key))
  }
}
</file>

<file path="test/cryptography/fake-encrypter.ts">
import type { Encrypter } from '@/shared/cryptography/encrypter'

export class FakeEncrypter implements Encrypter {
  public result = 'fake-token'
  public payload: Record<string, unknown> = {}

  async encrypt(payload: Record<string, unknown>): Promise<string> {
    this.payload = payload
    return this.result
  }
}
</file>

<file path="test/cryptography/fake-refresh-token.ts">
import { randomUUID } from 'crypto'
import { CacheRepository } from '@/infra/cache/cache-repository'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'

export class FakeRefreshTokenService implements RefreshTokenRepository {
  constructor(private readonly cache: CacheRepository) {}

  async create(userId: string): Promise<string> {
    const jti = randomUUID()
    await this.cache.set(this.key(jti), userId, 60 * 60 * 24 * 7) // 7 days
    return jti
  }

  async validate(jti: string): Promise<boolean> {
    const userId = await this.cache.get(this.key(jti))
    return !!userId
  }

  async revoke(jti: string): Promise<void> {
    await this.cache.del(this.key(jti))
  }

  async revokeAllForUser(userId: string): Promise<void> {
    const keys = await this.cache.keys('refresh_token:*')

    const deletable: string[] = []
    for (const key of keys) {
      const uid = await this.cache.get(key)
      if (uid === userId) {
        deletable.push(key)
      }
    }

    if (deletable.length > 0) {
      await this.cache.del(deletable)
    }
  }

  private key(jti: string): string {
    return `refresh_token:${jti}`
  }

  async isRevoked(jti: string): Promise<boolean> {
    const result = await this.cache.get(this.key(jti))
    return result === null
  }

  async revokeAllForUserExcept(
    userId: string,
    exceptJti: string,
  ): Promise<void> {
    const keys = await this.cache.keys('refresh_token:*')

    const deletable: string[] = []
    for (const key of keys) {
      const uid = await this.cache.get(key)
      if (uid === userId && key !== this.key(exceptJti)) {
        deletable.push(key)
      }
    }

    if (deletable.length > 0) {
      await this.cache.del(deletable)
    }
  }
}
</file>

<file path="test/factories/make-address.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Address } from '@/shared/address/enterprise/entities/address'

export function makeAddress(overrides: Partial<Address> = {}): Address {
  return Address.create({
    street: 'Rua A',
    number: '123',
    neighborhood: 'Bairro A',
    complement: null,
    city: 'Cidade A',
    state: 'Estado A',
    zipCode: '00000-000',
    userId: new UniqueEntityID('user-1'),
    ...overrides,
  })
}
</file>

<file path="test/mail/fake-mailer.ts">
import type { MailRepository } from '@/infra/mail/mail-repository'

export class FakeMailer implements MailRepository {
  public sent: Array<{ to: string; subject: string; html: string }> = []

  async send(data: {
    to: string
    subject: string
    html: string
  }): Promise<void> {
    this.sent.push(data)
  }

  async verify(): Promise<void> {}
}
</file>

<file path="test/repositories/audit-log/in-memory-audit-log.repository.ts">
import {
  AuditLogRepository,
  ListAuditLogsFilters,
} from '@/domain/audit-log/application/repositories/audit-log-repository'
import { AuditLog } from '@/domain/audit-log/enterprise/entities/audit-log'
import type { CursorPaginationParams } from '@/core/repositories/pagination-params'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { ActorType } from '@prisma/client'

export class InMemoryAuditLogRepository implements AuditLogRepository {
  public items: AuditLog[] = []

  constructor(private usersRepository: UsersRepository) {}

  async create(auditLog: AuditLog): Promise<void> {
    this.items.push(auditLog)
  }

  async resolveActorIdByEmail(
    actorType: ActorType,
    email: string,
  ): Promise<string | undefined> {
    if (actorType === ActorType.USER) {
      const user = await this.usersRepository.findByEmail(email)
      return user?.id.toString()
    }

    return undefined
  }

  async findMany(
    {
      actorType,
      actorId,
      entity,
      action,
      entityId,
      startDate,
      endDate,
    }: ListAuditLogsFilters,
    { cursor, limit }: CursorPaginationParams,
  ): Promise<[AuditLog[], boolean]> {
    let results = this.items.filter((item) => {
      return (
        item.actorType === actorType &&
        (!actorId || item.actorId === actorId) &&
        (!entity || item.entity === entity) &&
        (!action || item.action === action) &&
        (!entityId || item.entityId === entityId) &&
        (!startDate || item.createdAt >= startDate) &&
        (!endDate || item.createdAt <= endDate)
      )
    })

    results.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())

    if (cursor) {
      const index = results.findIndex((item) => item.id.toString() === cursor)
      if (index >= 0) {
        results = results.slice(index + 1)
      }
    }

    const paginated = results.slice(0, limit)
    const hasNextPage = results.length > limit

    return [paginated, hasNextPage]
  }
}
</file>

<file path="test/repositories/avatar/in-memory-avatar-repository.ts">
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'

export class InMemoryAvatarRepository implements AvatarRepository {
  public items: Avatar[] = []

  async create(avatar: Avatar): Promise<void> {
    this.items.push(avatar)
  }

  async findById(id: string): Promise<Avatar | null> {
    const avatar = this.items.find((item) => item.id.toString() === id)
    return avatar || null
  }

  async delete(id: string): Promise<void> {
    const index = this.items.findIndex((item) => item.id.toString() === id)

    if (index > -1) {
      this.items.splice(index, 1)
    }
  }

  async list(): Promise<Avatar[]> {
    return this.items
  }
}
</file>

<file path="test/repositories/user/in-memory-user-address-repository.ts">
import { UserAddressRepository } from '@/domain/user/application/repositories/user-address-repository'
import { Address } from '@/shared/address/enterprise/entities/address'

export class InMemoryUserAddressRepository implements UserAddressRepository {
  public items: Address[] = []

  async findManyByUserId(userId: string): Promise<Address[]> {
    return this.items.filter((address) => address.userId?.toString() === userId)
  }

  async upsertManyForUser(userId: string, addresses: Address[]): Promise<void> {
    this.items = this.items.filter(
      (address) => address.userId?.toString() !== userId,
    )

    this.items.push(...addresses)
  }
}
</file>

<file path="test/repositories/user/in-memory-user-avatar-repository.ts">
import { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

export class InMemoryUserAvatarRepository implements UserAvatarRepository {
  public items: UserAvatar[] = []

  async attachAvatarToUser(userId: string, avatarId: string): Promise<void> {
    const relation = UserAvatar.create({
      userId: new UniqueEntityID(userId),
      avatarId: new UniqueEntityID(avatarId),
    })

    const index = this.items.findIndex(
      (item) => item.userId.toString() === userId,
    )

    if (index >= 0) {
      this.items[index] = relation
    } else {
      this.items.push(relation)
    }
  }
}
</file>

<file path="test/storage/fake-uploader.ts">
import { Uploader, UploadParams } from '@/shared/storage/uploader'
import { randomUUID } from 'node:crypto'

type Upload = {
  fileName: string
  url: string
}

export class FakeUploader implements Uploader {
  public uploads: Upload[] = []

  async upload({ fileName }: UploadParams): Promise<{ url: string }> {
    const url = randomUUID()

    this.uploads.push({
      fileName,
      url,
    })

    return { url }
  }

  async delete(url: string): Promise<void> {
    const uploadIndex = this.uploads.findIndex((upload) => upload.url === url)

    if (uploadIndex > -1) {
      this.uploads.splice(uploadIndex, 1)
    }
  }
}
</file>

<file path=".env.example">
# APP
NODE_ENV=dev
APP_PORT="3333"

# DATABASE
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/postgres?schema=public"
DATABASE_HOST="localhost"
DATABASE_PORT="5432"
DATABASE_USERNAME="postgres"
DATABASE_PASSWORD="postgres"
DATABASE_NAME="postgres"

# REDIS
REDIS_HOST="127.0.0.1"
REDIS_PORT=6379
REDIS_DB=0

# UPLOAD (AWS & CLOUDFARE)
CLOUDFLARE_ACCOUNT_ID=""
AWS_ACCESS_KEY_ID=""
AWS_SECRET_ACCESS_KEY=""
AWS_BUCKET_NAME="bucket"

# MAIL
RESEND_API_KEY=""
RESET_PASSWORD_URL="http://localhost:3000/reset-password"

# JWT
JWT_PRIVATE_KEY=
JWT_PUBLIC_KEY=
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN // Full access
  MANAGER // Manager
  SUPERVISOR // Reports and supervision
  OPERATOR // Basic operations
}

model User {
  id           String   @id @default(uuid())
  name         String
  email        String   @unique
  passwordHash String   @map("password_hash")
  role         Role     @default(OPERATOR)
  isActive     Boolean  @default(true) @map("is_active")
  avatarId     String?  @unique @map("avatar_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  avatar    Avatar?   @relation(fields: [avatarId], references: [id])
  addresses Address[]

  @@map("users")
}

model Avatar {
  id       String  @id @default(uuid())
  title    String
  url      String
  userId   String? @map("user_id")
  clientId String? @map("client_id")

  user   User?
  client Client?

  @@map("avatars")
}

model Address {
  id           String   @id @default(uuid())
  street       String
  number       String
  complement   String?
  neighborhood String
  city         String
  state        String
  zipCode      String   @map("zip_code")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  userId   String? @map("user_id")
  clientId String? @map("client_id")

  user   User?   @relation(fields: [userId], references: [id])
  client Client? @relation(fields: [clientId], references: [id])

  @@map("address")
}

model Client {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  phone     String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  avatarId String? @unique @map("avatar_id")

  addresses Address[]
  avatar    Avatar?   @relation(fields: [avatarId], references: [id])

  @@map("clients")
}

enum ActorType {
  USER
  CLIENT
}

model AuditLog {
  id        String    @id @default(uuid())
  actorId   String    @map("actor_id")
  actorType ActorType @map("actor_type")
  action    String
  entity    String
  entityId  String    @map("entity_id")
  changes   Json?
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([actorId])
  @@index([entity, entityId])
  @@map("audit_logs")
}
</file>

<file path="src/core/repositories/pagination-params.ts">
export interface PaginationParams {
  page?: number
  perPage?: number
}

export interface PaginationMeta {
  total: number
  count: number
  perPage: number
  totalPages: number
  currentPage: number
  nextPage: number | null
  previousPage: number | null
}

export type CursorPaginationParams = {
  cursor?: string
  limit: number
}

export type CursorPaginationMeta = {
  count: number
  hasNextPage: boolean
  nextCursor?: string | null
}
</file>

<file path="src/domain/audit-log/application/subscribers/user/on-user-created.ts">
import { Injectable } from '@nestjs/common'
import { DomainEvents } from '@/core/events/domain-events'
import { EventHandler } from '@/core/events/event-handler'
import { UserCreatedEvent } from '@/domain/user/enterprise/events/user-created-event'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'

@Injectable()
export class OnUserCreated implements EventHandler {
  constructor(private createAuditLog: CreateAuditLogUseCase) {
    this.setupSubscriptions()
  }

  setupSubscriptions(): void {
    DomainEvents.register(this.handle.bind(this), UserCreatedEvent.name)
  }

  async handle(event: UserCreatedEvent): Promise<void> {
    const { user, actorId } = event

    await this.createAuditLog.execute({
      actorId,
      actorType: 'USER',
      action: 'user:created',
      entity: 'USER',
      entityId: user.id.toString(),
      changes: {
        name: user.name,
        email: user.email,
        role: user.role,
        createdAt: user.createdAt,
      },
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/__tests__/create-user.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { CreateUserUseCase } from '../create-user'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserAlreadyExistsError } from '../errors/user-already-exists-error'
import { FakeHasher } from 'test/cryptography/fake-hasher'
import { InMemoryUserAddressRepository } from 'test/repositories/user/in-memory-user-address-repository'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryUserAddressRepository: InMemoryUserAddressRepository
let fakeHasher: FakeHasher

let sut: CreateUserUseCase

describe('Create User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryUserAddressRepository = new InMemoryUserAddressRepository()
    fakeHasher = new FakeHasher()

    sut = new CreateUserUseCase(
      inMemoryUsersRepository,
      fakeHasher,
      inMemoryUserAddressRepository,
    )
  })

  it('should be able to create a new user', async () => {
    const adminUser = makeUser({
      role: 'ADMIN',
    })

    const result = await sut.execute({
      actorId: adminUser.id.toString(),
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
      addresses: [
        {
          street: 'Rua A',
          number: '123',
          neighborhood: 'Centro',
          complement: null,
          city: 'Petrolina',
          state: 'PE',
          zipCode: '56300-000',
        },
        {
          street: 'Rua B',
          number: '456',
          neighborhood: 'Centro',
          complement: 'Casa 2',
          city: 'Petrolina',
          state: 'PE',
          zipCode: '56300-001',
        },
      ],
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toEqual({
      data: inMemoryUsersRepository.items[0],
    })
    if (result.isRight()) {
      expect(result.value.data.addresses.getItems()).toHaveLength(2)
    }
  })

  it('should hash user password upon registration', async () => {
    const adminUser = makeUser({
      role: 'ADMIN',
    })

    const result = await sut.execute({
      actorId: adminUser.id.toString(),
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
      addresses: [
        {
          street: 'Rua A',
          number: '123',
          neighborhood: 'Centro',
          complement: null,
          city: 'Petrolina',
          state: 'PE',
          zipCode: '56300-000',
        },
      ],
    })

    expect(result.isRight()).toBe(true)

    const passwordHash = inMemoryUsersRepository.items[0].passwordHash

    const isPasswordCorrectlyHashed = await fakeHasher.compare(
      '123456',
      passwordHash,
    )

    expect(result.isRight()).toBe(true)
    expect(isPasswordCorrectlyHashed).toBe(true)
  })

  it('should not be able to create a new user with already existing email', async () => {
    const adminUser = makeUser({
      role: 'ADMIN',
    })

    const alreadyExistingUser = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(alreadyExistingUser)

    const result = await sut.execute({
      actorId: adminUser.id.toString(),
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
      addresses: [
        {
          street: 'Rua B',
          number: '456',
          neighborhood: 'Centro',
          complement: 'Casa 2',
          city: 'Petrolina',
          state: 'PE',
          zipCode: '56300-001',
        },
      ],
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserAlreadyExistsError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/forgot-password.spec.ts">
import { describe, it, expect, beforeEach } from 'vitest'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { FakeEncrypter } from 'test/cryptography/fake-encrypter'
import { makeUser } from 'test/factories/make-user'
import { ForgotPasswordUseCase } from '../forgot-password'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { FakeMailer } from 'test/mail/fake-mailer'

let usersRepository: InMemoryUsersRepository
let encrypter: FakeEncrypter
let mailer: FakeMailer
let sut: ForgotPasswordUseCase

const fakeEmail = 'user@example.com'
const fakeUserId = 'user-123'
const fakeToken = 'fake-token'
const resetPasswordUrl = 'https://example.com/reset-password'

describe('ForgotPasswordUseCase', () => {
  beforeEach(() => {
    usersRepository = new InMemoryUsersRepository()
    encrypter = new FakeEncrypter()
    mailer = new FakeMailer()

    sut = new ForgotPasswordUseCase(usersRepository, encrypter, mailer)
  })

  it('should send reset email if user exists', async () => {
    const user = makeUser({ email: fakeEmail }, new UniqueEntityID(fakeUserId))
    await usersRepository.create(user)

    const result = await sut.execute({
      email: fakeEmail,
      resetPasswordUrl,
    })

    expect(result.isRight()).toBe(true)
    expect(mailer.sent).toHaveLength(1)
    expect(mailer.sent[0]).toEqual(
      expect.objectContaining({
        to: fakeEmail,
        subject: expect.any(String),
        html: expect.stringContaining(`${resetPasswordUrl}?token=${fakeToken}`),
      }),
    )
  })

  it('should do nothing if user does not exist', async () => {
    const result = await sut.execute({
      email: fakeEmail,
      resetPasswordUrl,
    })

    expect(result.isRight()).toBe(true)
    expect(mailer.sent).toHaveLength(0)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/reset-password.spec.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { makeUser } from 'test/factories/make-user'
import { FakeHasher } from 'test/cryptography/fake-hasher'
import { FakeTokenVerifier } from 'test/cryptography/fake-token-verifier'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { ResetPasswordUseCase } from '../reset-password'
import { UserNotFoundError } from '../errors'
import { UserUnauthorizedError } from '../errors/user-unauthorized-error'
import { FakeRefreshTokenService } from 'test/cryptography/fake-refresh-token'
import { FakeCacheService } from 'test/cache/fake-cache'

let usersRepository: InMemoryUsersRepository
let tokenVerifier: FakeTokenVerifier
let hashGenerator: FakeHasher
let fakeCacheService: FakeCacheService
let refreshTokenService: FakeRefreshTokenService
let sut: ResetPasswordUseCase

const fakeToken = 'valid.token'
const fakeUserId = 'user-123'
const fakePassword = 'NovaSenha@123'
const expectedHash = fakePassword.concat('-hashed')

describe('Reset Password', () => {
  beforeEach(() => {
    usersRepository = new InMemoryUsersRepository()
    tokenVerifier = new FakeTokenVerifier()
    hashGenerator = new FakeHasher()
    fakeCacheService = new FakeCacheService()
    refreshTokenService = new FakeRefreshTokenService(fakeCacheService)

    sut = new ResetPasswordUseCase(
      tokenVerifier,
      usersRepository,
      hashGenerator,
      refreshTokenService,
    )
  })

  it('should reset password when token is valid and user exists', async () => {
    const user = makeUser({}, new UniqueEntityID(fakeUserId))
    await usersRepository.create(user)

    tokenVerifier.setTokenPayload(fakeToken, { sub: fakeUserId })

    const result = await sut.execute({
      token: fakeToken,
      password: fakePassword,
    })

    expect(result.isRight()).toBe(true)
    expect(user.passwordHash).toBe(expectedHash)
  })

  it('should return UserNotFoundError if user does not exist', async () => {
    tokenVerifier.setTokenPayload(fakeToken, { sub: fakeUserId })

    const result = await sut.execute({
      token: fakeToken,
      password: fakePassword,
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })

  it('should return UserUnauthorizedError if token is invalid', async () => {
    const result = await sut.execute({
      token: 'invalid.token',
      password: fakePassword,
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserUnauthorizedError)
  })

  it('should reset the password and revoke all refresh tokens', async () => {
    const user = makeUser({
      email: 'john@example.com',
      passwordHash: 'old-hash',
    })
    await usersRepository.create(user)

    tokenVerifier.setTokenPayload(fakeToken, { sub: user.id.toString() })

    const revokeSpy = vi
      .spyOn(refreshTokenService, 'revokeAllForUser')
      .mockResolvedValue()

    const result = await sut.execute({
      token: fakeToken,
      password: 'new-password',
    })

    expect(result.isRight()).toBe(true)

    const updatedUser = await usersRepository.findById(user.id.toString())
    expect(updatedUser?.passwordHash).toBe('new-password-hashed')

    expect(revokeSpy).toHaveBeenCalledWith(user.id.toString())
  })
})
</file>

<file path="src/domain/user/application/use-cases/forgot-password.ts">
import { Either, right } from '@/core/either'
import { Injectable } from '@nestjs/common'
import { Encrypter } from '@/shared/cryptography/encrypter'
import { MailRepository } from '@/infra/mail/mail-repository'
import { UsersRepository } from '../repositories/user-repository'

interface ForgotPasswordUseCaseRequest {
  email: string
  resetPasswordUrl: string
}

type ForgotPasswordUseCaseResponse = Either<null, null>

@Injectable()
export class ForgotPasswordUseCase {
  constructor(
    private readonly usersRepository: UsersRepository,
    private readonly encrypter: Encrypter,
    private readonly mailer: MailRepository,
  ) {}

  async execute({
    email,
    resetPasswordUrl,
  }: ForgotPasswordUseCaseRequest): Promise<ForgotPasswordUseCaseResponse> {
    const user = await this.usersRepository.findByEmail(email)

    if (!user) {
      return right(null)
    }

    const token = await this.encrypter.encrypt({ sub: user.id.toString() })

    const url = `${resetPasswordUrl}?token=${token}`

    await this.mailer.send({
      to: user.email,
      subject: 'Redefina sua senha',
      html: `<p>Ol√°,</p><p>Para redefinir sua senha, <a href="${url}">clique aqui</a>. Este link expira em 1 hora.</p>`,
    })

    user.requestPasswordReset()
    await this.usersRepository.dispatchEvent(user.id)

    return right(null)
  }
}
</file>

<file path="src/infra/auth/casl/ability.factory.ts">
import {
  AbilityBuilder,
  createMongoAbility,
  type CreateAbility,
  type MongoAbility,
} from '@casl/ability'
import { ForbiddenException, Injectable } from '@nestjs/common'
import { z } from 'zod'
import { userSubject } from './subjects/user'
import { permissions } from './permissions'
import type { User } from './models/user'
import { avatarSubject } from './subjects/avatar'
import { auditLogSubject } from './subjects/audit-log'

export const appAbilitiesSchema = z.union([
  userSubject,
  avatarSubject,
  auditLogSubject,
  z.tuple([z.literal('manage'), z.literal('all')]),
])
type AppAbilities = z.infer<typeof appAbilitiesSchema>

export type AppAbility = MongoAbility<AppAbilities>
export const createAppAbility = createMongoAbility as CreateAbility<AppAbility>

@Injectable()
export class CaslAbilityFactory {
  defineAbilityFor(user: User) {
    const builder = new AbilityBuilder(createAppAbility)

    if (typeof permissions[user.role] !== 'function') {
      throw new ForbiddenException(
        `Permissions for role ${user.role} not found.`,
      )
    }

    permissions[user.role](user, builder)

    const ability = builder.build({
      detectSubjectType(subject) {
        return subject.__typename
      },
    })

    ability.can = ability.can.bind(ability)
    ability.cannot = ability.cannot.bind(ability)
    return ability
  }
}
</file>

<file path="src/infra/auth/casl/permissions.ts">
import { AbilityBuilder } from '@casl/ability'
import { AppAbility } from './ability.factory'
import type { User } from './models/user'
import type { Role } from '@prisma/client'

type PermissionsByRole = (
  user: User,
  builder: AbilityBuilder<AppAbility>,
) => void

export const permissions: Record<Role, PermissionsByRole> = {
  ADMIN(user, { can, cannot }) {
    can('manage', 'all')
    cannot('update', 'User')
    can('update', 'User', {
      sub: { $eq: user.sub },
    })
  },
  MANAGER(user, { can }) {
    can('read', 'User')
    can('list', 'User')
    can('create', 'User')
    can('activate', 'User')
    can('deactivate', 'User')
    can('update-role', 'User')
    can('update', 'User', {
      sub: { $eq: user.sub },
    })
    can('manage', 'Avatar')
  },
  SUPERVISOR(user, { can }) {
    can('read', 'User')
    can('list', 'User')
    can('update', 'User', {
      sub: { $eq: user.sub },
    })
    can('manage', 'Avatar')
  },
  OPERATOR(user, { can, cannot }) {
    cannot('read', 'User')
    cannot('list', 'User')
    can('read', 'User', {
      sub: { $eq: user.sub },
    })
    can('update', 'User', {
      sub: { $eq: user.sub },
    })
    can('manage', 'Avatar')
  },
}
</file>

<file path="src/infra/auth/refresh-token.repository.ts">
export abstract class RefreshTokenRepository {
  abstract create(userId: string): Promise<string>
  abstract validate(jti: string): Promise<boolean>
  abstract revoke(jti: string): Promise<void>
  abstract revokeAllForUser(userId: string): Promise<void>
  abstract revokeAllForUserExcept(
    userId: string,
    exceptJti: string,
  ): Promise<void>
}
</file>

<file path="src/infra/auth/refresh-token.service.ts">
import { Injectable } from '@nestjs/common'
import { randomUUID } from 'crypto'
import { CacheRepository } from '../cache/cache-repository'
import { RefreshTokenRepository } from './refresh-token.repository'

@Injectable()
export class RefreshTokenService implements RefreshTokenRepository {
  constructor(private cache: CacheRepository) {}

  async create(userId: string): Promise<string> {
    const jti = randomUUID()

    await this.cache.set(this.key(jti), userId, 60 * 60 * 24 * 7) // 7 days

    return jti
  }

  async validate(jti: string): Promise<boolean> {
    const exists = await this.cache.get(this.key(jti))
    return !!exists
  }

  async revoke(jti: string): Promise<void> {
    await this.cache.del(this.key(jti))
  }

  async revokeAllForUser(userId: string): Promise<void> {
    const keys = await this.cache.keys(`refresh_token:*`)
    const tokens = await Promise.all(
      keys.map(async (key) => {
        const uid = await this.cache.get(key)
        return { key, uid }
      }),
    )
    const keysToDelete = tokens
      .filter((t) => t.uid === userId)
      .map((t) => t.key)

    if (keysToDelete.length > 0) {
      await this.cache.del(keysToDelete)
    }
  }

  private key(jti: string): string {
    return `refresh_token:${jti}`
  }

  async revokeAllForUserExcept(
    userId: string,
    exceptJti: string,
  ): Promise<void> {
    const keys = await this.cache.keys('refresh_token:*')

    const tokens = await Promise.all(
      keys.map(async (key) => {
        const uid = await this.cache.get(key)
        return { key, uid }
      }),
    )

    const keysToDelete = tokens
      .filter((t) => t.uid === userId && t.key !== this.key(exceptJti))
      .map((t) => t.key)

    if (keysToDelete.length > 0) {
      await this.cache.del(keysToDelete)
    }
  }
}
</file>

<file path="src/infra/cryptography/jwt-encrypter.ts">
import { Encrypter } from '@/shared/cryptography/encrypter'
import { Injectable } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'

@Injectable()
export class JwtEncrypter implements Encrypter {
  constructor(private jwtService: JwtService) {}

  encrypt(
    payload: Record<string, unknown>,
    expiresInSeconds: number = 60 * 60,
  ): Promise<string> {
    const iat = Math.floor(Date.now() / 1000)
    const exp = iat + expiresInSeconds

    return this.jwtService.signAsync({
      ...payload,
      iat,
      exp,
    })
  }
}
</file>

<file path="src/infra/events/user/__tests__/on-user-password-changed.e2e-spec.ts">
import { DomainEvents } from '@/core/events/domain-events'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { TokenService } from '@/infra/auth/token.service'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import { randomUUID } from 'crypto'
import request from 'supertest'
import { hash } from 'bcryptjs'
import { waitFor } from 'test/utils/wait-for'

describe('On user password changed (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)

    DomainEvents.shouldRun = true

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "audit_logs" CASCADE')
  })

  it('[EVENT] ‚Üí should create audit log when user changes password', async () => {
    const password = '123456'
    const user = await userFactory.makePrismaUser({
      passwordHash: await hash(password, 8),
    })

    const token = await tokenService.generate({
      sub: user.id.toString(),
      role: user.role,
      jti: randomUUID(),
    })

    await request(app.getHttpServer())
      .patch(`/v1/users/${user.id.toString()}/password`)
      .set('Authorization', `Bearer ${token}`)
      .send({
        currentPassword: password,
        newPassword: 'new-password',
      })
      .expect(204)

    await waitFor(async () => {
      const auditLog = await prisma.auditLog.findFirst({
        where: {
          actorId: user.id.toString(),
          action: 'user:password_changed',
        },
      })

      expect(auditLog).not.toBeNull()
      expect(auditLog?.changes).toContain('passwordChanged')
    })
  })
})
</file>

<file path="src/infra/http/controllers/avatar/avatar-controllers.module.ts">
import { Module } from '@nestjs/common'
import { CaslAbilityModule } from '@/infra/auth/casl/casl-ability.module'
import { StorageModule } from '@/infra/storage/storage.module'
import { UploadAndCreateAvatarUseCase } from '@/shared/avatar/application/use-cases/upload-and-create-avatar'
import { UploadAvatarController } from './upload-avatar.controller'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { AvatarDatabaseModule } from '@/infra/database/prisma/repositories/avatar/avatar-database.module'

@Module({
  imports: [
    UserDatabaseModule,
    AvatarDatabaseModule,
    CaslAbilityModule,
    StorageModule,
  ],
  controllers: [UploadAvatarController],
  providers: [UploadAndCreateAvatarUseCase],
})
export class AvatarControllersModule {}
</file>

<file path="src/infra/http/controllers/avatar/upload-avatar.controller.ts">
import {
  Controller,
  FileTypeValidator,
  HttpCode,
  MaxFileSizeValidator,
  ParseFilePipe,
  Post,
  UploadedFile,
  UseFilters,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common'
import { FileInterceptor } from '@nestjs/platform-express'
import {
  ApiBody,
  ApiCreatedResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOperation,
  ApiTags,
} from '@nestjs/swagger'
import { JwtAuthGuard } from '@/infra/auth/jwt-auth.guard'
import { UploadAndCreateAvatarUseCase } from '@/shared/avatar/application/use-cases/upload-and-create-avatar'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UploadAvatarRequestDto } from '../../dtos/requests/avatar'
import { UploadAvatarResponseDto } from '../../dtos/response/avatar'
import {
  AvatarForbiddenDto,
  AvatarUploadFailedDto,
} from '../../dtos/error/avatar'
import { AvatarErrorFilter } from '../../filters/avatar-error.filter'

@UseFilters(AvatarErrorFilter)
@ApiTags('Avatar')
@ServiceTag('avatar')
@Controller({ path: 'avatar', version: '1' })
export class UploadAvatarController {
  constructor(private uploadAndCreateAvatar: UploadAndCreateAvatarUseCase) {}

  @Post()
  @UseGuards(JwtAuthGuard, CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('manage', 'Avatar'))
  @ApiOperation({ summary: 'Upload Avatar' })
  @HttpCode(201)
  @UseInterceptors(FileInterceptor('file'))
  @ApiBody({ type: UploadAvatarRequestDto })
  @ApiCreatedResponse({ type: UploadAvatarResponseDto })
  @ApiForbiddenResponse({ type: AvatarForbiddenDto })
  @ApiInternalServerErrorResponse({ type: AvatarUploadFailedDto })
  async handle(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({
            maxSize: 1024 * 1024 * 2, // 2mb
          }),
          new FileTypeValidator({
            fileType: '.(png|jpg|jpeg)',
          }),
        ],
      }),
    )
    file: Express.Multer.File,
  ) {
    const result = await this.uploadAndCreateAvatar.execute({
      fileName: file.originalname,
      fileType: file.mimetype,
      body: file.buffer,
    })

    if (result.isLeft()) {
      throw result.value
    }

    return {
      data: result.value.data.id.toString(),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-avatar.integration.e2e-spec.ts">
import request from 'supertest'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'

describe('Edit User Avatar (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await prisma.$disconnect()
    await app.close()
  })

  it('[INTEGRATION] ‚Üí should upload an avatar and assign it to the user', async () => {
    const user = await userFactory.makePrismaUser({
      name: 'Test User',
      email: 'test@example.com',
      role: 'OPERATOR',
    })

    const accessToken = await token.generateAccessToken({
      sub: user.id.toString(),
      role: user.role,
      jti: randomUUID(),
    })

    const avatarUploadRes = await request(app.getHttpServer())
      .post('/v1/avatar')
      .set('Authorization', `Bearer ${accessToken.token}`)
      .attach('file', './test/e2e/sample-upload.png')

    const avatarId = avatarUploadRes.body.data

    const payload = {
      name: 'Updated User',
      avatarId,
      addresses: [
        {
          street: 'New Street',
          number: '202',
          neighborhood: 'New Neighborhood',
          city: 'New City',
          state: 'New State',
          zipCode: '11111-111',
        },
      ],
    }

    await request(app.getHttpServer())
      .patch(`/v1/users/${user.id}`)
      .set('Authorization', `Bearer ${accessToken.token}`)
      .send(payload)
      .expect(200)

    const userOnDatabase = await prisma.user.findUnique({
      where: { id: user.id.toString() },
    })

    const avatarOnDatabase = await prisma.avatar.findUnique({
      where: { id: avatarId },
    })

    expect(userOnDatabase?.avatarId).toBe(avatarId)
    expect(avatarOnDatabase?.userId).toBe(user.id.toString())
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/refresh-token.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { JwtService } from '@nestjs/jwt'
import { UserFactory } from 'test/factories/make-user'
import { RefreshTokenService } from '@/infra/auth/refresh-token.service'
import type { User } from '@/domain/user/enterprise/entities/user'
import { randomUUID } from 'node:crypto'
import { CacheModule } from '@/infra/cache/cache.module'

const refreshTokenEndpoint = '/v1/users/refresh'

describe('Refresh Token (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let refreshTokenService: RefreshTokenService
  let adminUser: User
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CacheModule],
      providers: [UserFactory, RefreshTokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    refreshTokenService = moduleRef.get(RefreshTokenService)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  it('[200] OK ‚Üí should return new access token from valid refresh token', async () => {
    const jti = await refreshTokenService.create(adminUser.id.toString())

    const refreshToken = jwt.sign(
      {
        sub: adminUser.id.toString(),
        role: adminUser.role,
        jti,
      },
      { algorithm: 'RS256' },
    )

    const response = await request(app.getHttpServer())
      .post(refreshTokenEndpoint)
      .set('Authorization', `Bearer ${refreshToken}`)

    expect(response.statusCode).toBe(200)
    expect(response.body).toEqual({
      access_token: expect.objectContaining({
        expiresIn: expect.any(Number),
        token: expect.any(String),
      }),
      refresh_token: expect.objectContaining({
        token: expect.any(String),
      }),
      expiresIn: expect.any(Number),
    })
  })

  it('[401] Unauthorized ‚Üí should return error for invalid refresh token', async () => {
    const response = await request(app.getHttpServer())
      .post(refreshTokenEndpoint)
      .set('Authorization', 'Bearer invalid.token.here')

    expect(response.statusCode).toBe(401)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      }),
    )
  })

  it('[401] Unauthorized ‚Üí should return error for expired refresh token', async () => {
    const jti = await refreshTokenService.create(adminUser.id.toString())

    const expiredToken = jwt.sign(
      {
        sub: adminUser.id.toString(),
        role: adminUser.role,
        jti,
        exp: Math.floor(Date.now() / 1000) - 10,
        iat: Math.floor(Date.now() / 1000) - 20,
      },
      { algorithm: 'RS256' },
    )

    const response = await request(app.getHttpServer())
      .post(refreshTokenEndpoint)
      .set('Authorization', `Bearer ${expiredToken}`)

    expect(response.statusCode).toBe(401)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      }),
    )
  })

  it('[401] Unauthorized ‚Üí should return error if jti not found in repository', async () => {
    const fakeJti = randomUUID()

    const fakeToken = jwt.sign(
      {
        sub: adminUser.id.toString(),
        role: adminUser.role,
        jti: fakeJti,
        exp: Math.floor(Date.now() / 1000) + 60 * 10,
        iat: Math.floor(Date.now() / 1000),
      },
      { algorithm: 'RS256' },
    )

    const response = await request(app.getHttpServer())
      .post(refreshTokenEndpoint)
      .set('Authorization', `Bearer ${fakeToken}`)

    expect(response.statusCode).toBe(401)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      }),
    )
  })

  it('[401] Unauthorized ‚Üí should return error if no Authorization header is sent', async () => {
    const response = await request(app.getHttpServer()).post(
      refreshTokenEndpoint,
    )

    expect(response.statusCode).toBe(401)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      }),
    )
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/reset-password.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { UserFactory } from 'test/factories/make-user'
import { TokenService } from '@/infra/auth/token.service'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { RateLimitService } from '@/shared/rate-limit/rate-limit.service'

describe('Reset Password (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let tokenService: TokenService
  let rateLimitService: RateLimitService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    tokenService = moduleRef.get(TokenService)
    rateLimitService = app.get(RateLimitService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
    rateLimitService.clearAll()
  })

  it('[204] Success ‚Üí should reset the password with valid token', async () => {
    const user = await userFactory.makePrismaUser({
      email: 'reset@example.com',
    })

    const token = await tokenService.generate({
      sub: user.id.toString(),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({
        token,
        password: 'NovaSenha@123',
      })

    expect(response.statusCode).toBe(204)
  })

  it('[401] Unauthorized ‚Üí should return 401 with invalid token', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({
        token: 'invalid.token',
        password: 'NovaSenha@123',
      })

    expect(response.statusCode).toBe(401)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      }),
    )
  })

  it('[404] Not Found ‚Üí should return 404 if user does not exist', async () => {
    const fakeId = 'non-existent-id'
    const token = await tokenService.generate({ sub: fakeId })

    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({
        token,
        password: 'NovaSenha@123',
      })

    expect(response.statusCode).toBe(404)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 404,
        error: 'Not Found',
        message: 'User not found',
      }),
    )
  })

  it('[400] Validation ‚Üí should return 400 if required fields are missing', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({})

    expect(response.statusCode).toBe(400)
    expect(response.body).toEqual(
      expect.objectContaining({
        statusCode: 400,
        message: 'Missing required fields',
        error: 'Bad Request',
        errors: expect.objectContaining({
          name: 'ZodValidationError',
          details: expect.arrayContaining([
            expect.objectContaining({
              path: expect.arrayContaining(['token']),
            }),
            expect.objectContaining({
              path: expect.arrayContaining(['password']),
            }),
          ]),
        }),
      }),
    )
  })

  it('[429] should return 429 after exceeding rate limit', async () => {
    const user = await userFactory.makePrismaUser({
      email: 'reset429@example.com',
    })
    const token = await tokenService.generate({
      sub: user.id.toString(),
    })

    for (let i = 0; i < 3; i++) {
      await request(app.getHttpServer())
        .post('/v1/users/reset-password')
        .send({ token, password: 'NovaSenha@123' })
        .expect(204)
    }

    const response = await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({ token, password: 'NovaSenha@123' })
      .expect(429)

    expect(response.headers['retry-after']).toBeDefined()
  })
})
</file>

<file path="src/infra/http/controllers/user/find-user-by-id.controller.ts">
import {
  Controller,
  Get,
  HttpCode,
  Param,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { UserPresenter } from '../../presenters/user.presenter'
import { FindUserByIdUseCase } from '@/domain/user/application/use-cases/find-user-by-id'
import {
  ApiBadRequestResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import {
  UserForbiddenDto,
  UserNotFoundDto,
  WrongCredentialsDto,
} from '../../dtos/error/user'
import { userCanReadSelfHandler } from '@/infra/auth/casl/handlers/user-can-read-self.handler'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class FindUserByIdController {
  constructor(private findUserByIdUseCase: FindUserByIdUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies(userCanReadSelfHandler)
  @Get(':id')
  @HttpCode(200)
  @ApiOperation({ summary: 'Find user by id' })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(@Param('id', ParseUuidPipe) id: string) {
    const result = await this.findUserByIdUseCase.execute({ id })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/list-users.controller.ts">
import {
  Controller,
  Get,
  HttpCode,
  Query,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { z } from 'zod'
import { UserPresenter } from '../../presenters/user.presenter'
import {
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiOperation,
  ApiQuery,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { ListUsersUseCase } from '@/domain/user/application/use-cases/list-users'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { UserListResponseDto } from '../../dtos/response/user'
import { UserForbiddenDto, WrongCredentialsDto } from '../../dtos/error/user'

const querySchema = z.object({
  page: z.coerce.number().optional().default(1),
  perPage: z.coerce.number().optional().default(20),
})
type QuerySchema = z.infer<typeof querySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class ListUsersController {
  constructor(private listUsersUseCase: ListUsersUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('list', 'User'))
  @Get()
  @HttpCode(200)
  @ApiOperation({ summary: 'List all users (paginated)' })
  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })
  @ApiQuery({ name: 'perPage', required: false, type: Number, example: 20 })
  @ApiOkResponse({ type: UserListResponseDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @Query(new ZodValidationPipe(querySchema)) { page, perPage }: QuerySchema,
  ) {
    const result = await this.listUsersUseCase.execute({ page, perPage })

    if (result.isRight()) {
      const { data, meta } = result.value
      return {
        data: data.map(UserPresenter.toHTTP),
        meta,
      }
    }

    throw result.value
  }
}
</file>

<file path="src/infra/http/controllers/health.controller.ts">
import { Public } from '@/infra/auth/public'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { Controller, Get } from '@nestjs/common'
import {
  ApiTags,
  ApiOperation,
  ApiOkResponse,
  ApiServiceUnavailableResponse,
} from '@nestjs/swagger'
import {
  HealthCheckService,
  HealthCheck,
  HealthCheckResult,
} from '@nestjs/terminus'
import { PrismaHealthIndicator } from '../indicators/prisma-health.indicator'
import { RedisHealthIndicator } from '../indicators/redis-health.indicator'
import { S3HealthIndicator } from '../indicators/s3-health.indicator'
import { HealthCheckResponseDto } from '../dtos/common/health-check-response.dto'
import { MailHealthIndicator } from '../indicators/mailer-health.indicator'

@ApiTags('Health')
@ServiceTag('health')
@Public()
@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private prisma: PrismaHealthIndicator,
    private redis: RedisHealthIndicator,
    private s3: S3HealthIndicator,
    private mailer: MailHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  @ApiOperation({
    summary: 'Check application health and its dependent services.',
    description:
      'Returns the status of monitored components (database, Redis, S3). Overall status will be "ok" if all components are healthy, or "error" if any component fails.',
  })
  @ApiOkResponse({
    description: 'All services are operational and the application is healthy.',
    type: HealthCheckResponseDto,
  })
  @ApiServiceUnavailableResponse({
    description:
      'One or more services are unavailable or the application is unhealthy.',
    type: HealthCheckResponseDto,
  })
  check(): Promise<HealthCheckResult> {
    return this.health.check([
      () => this.prisma.isHealthy('database'),
      () => this.redis.isHealthy('redis'),
      () => this.s3.isHealthy('s3'),
      () => this.mailer.isHealthy('reSend'),
    ])
  }
}
</file>

<file path="src/infra/http/dtos/requests/user/index.ts">
export * from './authenticate-request.dto'
export * from './create-user-request.dto'
export * from './edit-user-request.dto'
export * from './edit-user-role-request.dto'
export * from './reset-password-request.dto'
export * from './forgot-password-request.dto'
export * from './edit-user-password-request.dto'
</file>

<file path="src/infra/http/dtos/response/user/index.ts">
export * from './authenticate-response.dto'
export * from './user-response.dto'
export * from './user-list-response.dto'
export * from './refresh-token-response.dto'
</file>

<file path="src/infra/logger/logger.module.ts">
import { Module, Global } from '@nestjs/common'
import { WinstonLoggerProvider } from './winston/winston.provider'
import { APP_INTERCEPTOR } from '@nestjs/core'
import { LoggerService } from './winston/logger.service'
import { RequestLoggingInterceptor } from './winston/logger.interceptor'

@Global()
@Module({
  providers: [
    WinstonLoggerProvider,
    LoggerService,
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLoggingInterceptor,
    },
  ],
  exports: [LoggerService],
})
export class LoggerModule {}
</file>

<file path="src/infra/mail/mailer.module.ts">
import { Module } from '@nestjs/common'
import { ResendMailer } from './resend/resend-mailer'
import { MailRepository } from './mail-repository'
import { EnvModule } from '../env/env.module'
import { LoggerModule } from '../logger/logger.module'

@Module({
  imports: [EnvModule, LoggerModule],
  providers: [
    ResendMailer,
    {
      provide: MailRepository,
      useClass: ResendMailer,
    },
  ],
  exports: [MailRepository],
})
export class MailerModule {}
</file>

<file path="src/shared/avatar/application/use-cases/upload-and-create-avatar.ts">
import { left, right, type Either } from '@/core/either'
import { Avatar } from '../../enterprise/entities/avatar'
import { Injectable } from '@nestjs/common'
import { AvatarRepository } from '../repositories/avatar-repository'
import { Uploader } from '@/shared/storage/uploader'
import { InvalidAvatarTypeError } from './errors/invalid-avatar-type-error'
import { AvatarUploadFailedError } from './errors/avatar-upload-failed-error'

type UploadAndCreateAvatarUseCaseRequest = {
  fileName: string
  fileType: string
  body: Buffer
}

type UploadAndCreateAvatarUseCaseResponse = Either<
  InvalidAvatarTypeError | AvatarUploadFailedError,
  {
    data: Avatar
  }
>

@Injectable()
export class UploadAndCreateAvatarUseCase {
  constructor(
    private avatarRepository: AvatarRepository,
    private uploader: Uploader,
  ) {}

  async execute({
    fileName,
    fileType,
    body,
  }: UploadAndCreateAvatarUseCaseRequest): Promise<UploadAndCreateAvatarUseCaseResponse> {
    if (!/^(image\/(jpeg|jpg|png))$/.test(fileType)) {
      return left(new InvalidAvatarTypeError(fileType))
    }

    const uploadResult = await this.uploader.upload({
      fileName,
      fileType,
      body,
    })

    if (!uploadResult || !uploadResult.url) {
      return left(new AvatarUploadFailedError())
    }

    const avatar = Avatar.create({
      title: fileName,
      url: uploadResult.url,
    })

    await this.avatarRepository.create(avatar)

    return right({
      data: avatar,
    })
  }
}
</file>

<file path="src/domain/user/application/repositories/user-repository.ts">
import { PaginationParams } from '@/core/repositories/pagination-params'
import { User } from '../../enterprise/entities/user'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export abstract class UsersRepository {
  abstract findById(id: string): Promise<User | null>
  abstract findManyByIds(ids: string[]): Promise<User[]>
  abstract findByEmail(email: string): Promise<User | null>
  abstract list(params: PaginationParams): Promise<[User[], number]>
  abstract save(user: User): Promise<void>
  abstract create(user: User): Promise<void>
  abstract delete(user: User): Promise<void>
  abstract dispatchEvent(userId: UniqueEntityID): Promise<void>
}
</file>

<file path="src/domain/user/application/use-cases/__tests__/authenticate-user.spec.ts">
import { describe, beforeEach, it, expect } from 'vitest'
import { AuthenticateUserUseCase } from '@/domain/user/application/use-cases/authenticate-user'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { FakeHasher } from 'test/cryptography/fake-hasher'
import { Role } from '@prisma/client'
import { FakeCacheService } from 'test/cache/fake-cache'
import { FakeRefreshTokenService } from 'test/cryptography/fake-refresh-token'
import { FakeTokenService } from 'test/cryptography/fake-token'

let sut: AuthenticateUserUseCase
let usersRepository: InMemoryUsersRepository
let hasher: FakeHasher
let fakeTokenService: FakeTokenService
let fakeCacheService: FakeCacheService
let refreshTokenService: FakeRefreshTokenService

describe('Authenticate User', () => {
  beforeEach(() => {
    usersRepository = new InMemoryUsersRepository()
    hasher = new FakeHasher()
    fakeTokenService = new FakeTokenService()
    fakeCacheService = new FakeCacheService()
    refreshTokenService = new FakeRefreshTokenService(fakeCacheService)

    sut = new AuthenticateUserUseCase(
      usersRepository,
      hasher,
      fakeTokenService,
      refreshTokenService,
    )
  })

  it('should be able to authenticate a user and return tokens', async () => {
    const user = makeUser({
      email: 'johndoe@example.com',
      passwordHash: await hasher.hash('123456'),
      role: 'OPERATOR' as Role,
    })

    await usersRepository.create(user)

    const result = await sut.execute({
      email: 'johndoe@example.com',
      password: '123456',
    })

    expect(result.isRight()).toBe(true)

    if (result.isRight()) {
      const value = result.value
      expect(value.accessToken).toHaveProperty('token')
      expect(value.accessToken).toHaveProperty('expiresIn')
      expect(typeof value.accessToken.token).toBe('string')
      expect(typeof value.accessToken.expiresIn).toBe('number')

      expect(value.refreshToken).toHaveProperty('token')
      expect(value.refreshToken).toHaveProperty('expiresIn')
      expect(typeof value.refreshToken.token).toBe('string')
      expect(typeof value.refreshToken.expiresIn).toBe('number')

      expect(typeof value.expiresIn).toBe('number')
    }
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserUseCase } from '../edit-user'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { InMemoryUserAvatarRepository } from 'test/repositories/user/in-memory-user-avatar-repository'
import { InMemoryAvatarRepository } from 'test/repositories/avatar/in-memory-avatar-repository'
import { makeAvatar } from 'test/factories/make-avatar'
import { UserNotFoundError } from '../errors'
import { InMemoryUserAddressRepository } from 'test/repositories/user/in-memory-user-address-repository'
import { Address } from '@/shared/address/enterprise/entities/address'

let inMemoryUsersRepository: InMemoryUsersRepository
let inMemoryAvatarRepository: InMemoryAvatarRepository
let inMemoryUserAvatarRepository: InMemoryUserAvatarRepository
let inMemoryUserAddressRepository: InMemoryUserAddressRepository

let sut: EditUserUseCase

describe('Edit User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    inMemoryUserAvatarRepository = new InMemoryUserAvatarRepository()
    inMemoryAvatarRepository = new InMemoryAvatarRepository()
    inMemoryUserAddressRepository = new InMemoryUserAddressRepository()

    sut = new EditUserUseCase(
      inMemoryUsersRepository,
      inMemoryUserAvatarRepository,
      inMemoryUserAddressRepository,
    )
  })

  it('should be able to edit a user', async () => {
    const user = makeUser({}, new UniqueEntityID('user-1'))
    const avatar = makeAvatar({}, new UniqueEntityID('avatar-1'))

    await inMemoryUsersRepository.create(user)
    await inMemoryAvatarRepository.create(avatar)

    const result = await sut.execute({
      id: user.id.toString(),
      name: 'New Name',
      avatarId: avatar.id.toString(),
      addresses: [
        {
          street: 'Rua A',
          number: '123',
          neighborhood: 'Bairro B',
          city: 'Cidade C',
          state: 'Estado D',
          zipCode: '00000-000',
        },
      ],
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      expect(result.value.data.name).toBe('New Name')
      expect(result.value.data.avatarId?.toString()).toBe('avatar-1')
    }

    const attached = inMemoryUserAvatarRepository.items.find(
      (ua) =>
        ua.userId.toString() === 'user-1' &&
        ua.avatarId.toString() === 'avatar-1',
    )

    expect(attached).toBeDefined()
  })

  it('should return error if user does not exist', async () => {
    const result = await sut.execute({
      id: 'user-01',
      name: 'Any',
      addresses: [
        {
          street: 'Rua A',
          number: '123',
          neighborhood: 'Bairro B',
          city: 'Cidade C',
          state: 'Estado D',
          zipCode: '00000-000',
        },
      ],
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })

  it('should update user name and avatar, and replace existing address with a new one', async () => {
    const userId = new UniqueEntityID('user-1')

    const oldAddress = Address.create({
      street: 'Old Street',
      number: '101',
      neighborhood: 'Old Neighborhood',
      city: 'Old City',
      state: 'Old State',
      zipCode: '99999-999',
      complement: null,
      userId,
    })

    const user = makeUser(
      {
        name: 'Original Name',
        addresses: [oldAddress],
      },
      userId,
    )

    const avatar = makeAvatar({}, new UniqueEntityID('avatar-1'))

    await inMemoryUsersRepository.create(user)
    await inMemoryAvatarRepository.create(avatar)
    await inMemoryUserAddressRepository.upsertManyForUser(
      user.id.toString(),
      user.addresses.getItems(),
    )

    const result = await sut.execute({
      id: user.id.toString(),
      name: 'Updated Name',
      avatarId: avatar.id.toString(),
      addresses: [
        {
          street: 'New Street',
          number: '202',
          neighborhood: 'New Neighborhood',
          city: 'New City',
          state: 'New State',
          zipCode: '11111-111',
        },
      ],
    })

    expect(result.isRight()).toBe(true)
    if (result.isRight()) {
      expect(result.value.data.name).toBe('Updated Name')
      expect(result.value.data.avatarId?.toString()).toBe('avatar-1')
    }

    const newAddresses = await inMemoryUserAddressRepository.findManyByUserId(
      user.id.toString(),
    )

    expect(newAddresses).toHaveLength(1)
    expect(newAddresses[0].street).toBe('New Street')

    const attached = inMemoryUserAvatarRepository.items.find(
      (ua) =>
        ua.userId.toString() === user.id.toString() &&
        ua.avatarId.toString() === 'avatar-1',
    )

    expect(attached).toBeDefined()
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/logout-user.spec.ts">
import { describe, it, expect, beforeEach } from 'vitest'
import { LogoutUserUseCase } from '../logout-user'
import { FakeCacheService } from 'test/cache/fake-cache'
import { FakeRefreshTokenService } from 'test/cryptography/fake-refresh-token'
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'

let sut: LogoutUserUseCase
let fakeCacheService: FakeCacheService
let refreshTokenService: FakeRefreshTokenService
let inMemoryUsersRepository: InMemoryUsersRepository

describe('Logout', () => {
  beforeEach(() => {
    fakeCacheService = new FakeCacheService()
    refreshTokenService = new FakeRefreshTokenService(fakeCacheService)
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new LogoutUserUseCase(refreshTokenService, inMemoryUsersRepository)
  })

  it('should revoke the refresh token by jti', async () => {
    const user = makeUser({})

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      jti: 'fake-jti',
      userId: user.id.toString(),
    })

    expect(result.isRight()).toBe(true)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/refresh-user-token.spec.ts">
import { RefreshUserTokenUseCase } from '@/domain/user/application/use-cases/refresh-user-token'
import { UserUnauthorizedError } from '@/domain/user/application/use-cases/errors/user-unauthorized-error'
import { JwtService } from '@nestjs/jwt'
import type { RefreshTokenPayload } from '@/infra/auth/jwt.strategy'
import type { Role } from '@prisma/client'
import { FakeCacheService } from 'test/cache/fake-cache'
import { FakeRefreshTokenService } from 'test/cryptography/fake-refresh-token'
import { FakeTokenService } from 'test/cryptography/fake-token'

let sut: RefreshUserTokenUseCase
let jwtService: JwtService
let fakeTokenService: FakeTokenService
let fakeCacheService: FakeCacheService
let refreshTokenService: FakeRefreshTokenService

const validPayload: RefreshTokenPayload = {
  sub: 'user-id-123',
  role: 'ADMIN' as Role,
  jti: 'jti-456',
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + 3600,
}

describe('Refresh User Token', () => {
  beforeEach(() => {
    jwtService = {
      verify: vi.fn(),
    } as unknown as JwtService

    fakeTokenService = new FakeTokenService()
    fakeCacheService = new FakeCacheService()
    refreshTokenService = new FakeRefreshTokenService(fakeCacheService)

    sut = new RefreshUserTokenUseCase(
      jwtService,
      fakeTokenService,
      refreshTokenService,
    )
  })

  it('should not allow refreshing if token is missing', async () => {
    const result = await sut.execute({ refreshToken: '' })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserUnauthorizedError)
  })

  it('should not allow refreshing if token is invalid', async () => {
    vi.spyOn(jwtService, 'verify').mockImplementation(() => {
      throw new Error('invalid token')
    })

    const result = await sut.execute({ refreshToken: 'invalid.token' })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserUnauthorizedError)
  })

  it('should not allow refreshing if jti is not valid in repository', async () => {
    vi.spyOn(jwtService, 'verify').mockReturnValue(validPayload)
    vi.spyOn(refreshTokenService, 'validate').mockResolvedValue(false)

    const result = await sut.execute({ refreshToken: 'valid.token' })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserUnauthorizedError)
  })

  it('should generate new access token if refresh token is valid', async () => {
    vi.spyOn(jwtService, 'verify').mockReturnValue(validPayload)
    vi.spyOn(refreshTokenService, 'validate').mockResolvedValue(true)
    vi.spyOn(fakeTokenService, 'generateAccessToken').mockResolvedValue({
      token: 'access-token-abc',
      expiresIn: 9999,
    })

    const result = await sut.execute({ refreshToken: 'valid.token' })

    expect(result.isRight()).toBe(true)
    expect(result.value).toEqual({
      accessToken: {
        token: 'access-token-abc',
        expiresIn: 9999,
      },
      refreshToken: {
        token: 'valid.token',
        expiresIn: validPayload.exp,
      },
      expiresIn: 9999,
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/create-user.ts">
import { left, right, type Either } from '@/core/either'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { User } from '@/domain/user/enterprise/entities/user'
import { UserAlreadyExistsError } from './errors/user-already-exists-error'
import { Injectable } from '@nestjs/common'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import type { Role } from '@prisma/client'
import { Address } from '@/shared/address/enterprise/entities/address'
import { UserAddressRepository } from '../repositories/user-address-repository'
import { UserAddressList } from '../../enterprise/entities/user-address-list'
import { UserUnauthorizedError } from './errors/user-unauthorized-error'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

interface CreateUserUseCaseRequest {
  actorId: string
  name: string
  email: string
  password: string
  role: Role
  addresses: {
    street: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    zipCode: string
  }[]
}

type CreateUserUseCaseResponse = Either<
  UserAlreadyExistsError | UserUnauthorizedError,
  {
    data: User
  }
>

@Injectable()
export class CreateUserUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private hashGenerator: HashGenerator,
    private userAddressRepository: UserAddressRepository,
  ) {}

  async execute({
    actorId,
    name,
    email,
    password,
    role,
    addresses,
  }: CreateUserUseCaseRequest): Promise<CreateUserUseCaseResponse> {
    if (!actorId) {
      return left(new UserUnauthorizedError())
    }

    const userAlreadyExists = await this.usersRepository.findByEmail(email)

    if (userAlreadyExists) {
      return left(new UserAlreadyExistsError(email))
    }

    const passwordHash = await this.hashGenerator.hash(password)

    const user = User.create(
      {
        email,
        isActive: true,
        name,
        passwordHash,
        role,
      },
      undefined,
      new UniqueEntityID(actorId),
    )

    const addressList = new UserAddressList(
      addresses.map((a) =>
        Address.create({
          ...a,
          userId: user.id,
        }),
      ),
    )

    user.updateAddress(addressList)

    await this.usersRepository.create(user)

    await this.userAddressRepository.upsertManyForUser(
      user.id.toString(),
      addressList.getItems(),
    )

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/logout-user.ts">
import { Injectable } from '@nestjs/common'
import { left, right, type Either } from '@/core/either'
import { UserUnauthorizedError } from './errors/user-unauthorized-error'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'
import { UsersRepository } from '../repositories/user-repository'

type LogoutUserUseCaseRequest = {
  jti: string
  userId: string
}

type LogoutUserUseCaseResponse = Either<UserUnauthorizedError, null>

@Injectable()
export class LogoutUserUseCase {
  constructor(
    private refreshTokenRepository: RefreshTokenRepository,
    private usersRepository: UsersRepository,
  ) {}

  async execute({
    jti,
    userId,
  }: LogoutUserUseCaseRequest): Promise<LogoutUserUseCaseResponse> {
    if (!jti) return left(new UserUnauthorizedError())

    const user = await this.usersRepository.findById(userId)

    if (!user) {
      return left(new UserUnauthorizedError())
    }

    await this.refreshTokenRepository.revoke(jti)

    user.logout()
    await this.usersRepository.dispatchEvent(user.id)

    return right(null)
  }
}
</file>

<file path="src/domain/user/application/use-cases/refresh-user-token.ts">
import { left, right, type Either } from '@/core/either'
import { Injectable } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { UserUnauthorizedError } from './errors/user-unauthorized-error'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'
import { TokenRepository } from '@/infra/auth/token-repository'
import type { UserPayload } from '@/infra/auth/jwt.strategy'

type RefreshUserTokenUseCaseRequest = {
  refreshToken: string
}

type RefreshUserTokenUseCaseResponse = Either<
  UserUnauthorizedError,
  {
    accessToken: {
      token: string
      expiresIn: number
    }
    refreshToken: {
      token: string
      expiresIn: number
    }
    expiresIn: number
  }
>

@Injectable()
export class RefreshUserTokenUseCase {
  constructor(
    private jwtService: JwtService,
    private tokenRepository: TokenRepository,
    private refreshTokenRepository: RefreshTokenRepository,
  ) {}

  async execute({
    refreshToken,
  }: RefreshUserTokenUseCaseRequest): Promise<RefreshUserTokenUseCaseResponse> {
    if (!refreshToken) {
      return left(new UserUnauthorizedError())
    }

    let payload: UserPayload

    try {
      payload = this.jwtService.verify(refreshToken)
    } catch {
      return left(new UserUnauthorizedError())
    }

    const isValid = await this.refreshTokenRepository.validate(payload.jti)

    if (!isValid) {
      return left(new UserUnauthorizedError())
    }

    const jti = await this.refreshTokenRepository.create(payload.sub)

    const accessToken = await this.tokenRepository.generateAccessToken({
      sub: payload.sub,
      role: payload.role,
      jti,
    })

    return right({
      accessToken,
      refreshToken: {
        token: refreshToken,
        expiresIn: payload.exp,
      },
      expiresIn: accessToken.expiresIn,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/reset-password.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import { TokenVerifier } from '@/shared/cryptography/token-verifier'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { UserUnauthorizedError } from './errors/user-unauthorized-error'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'

type ResetPasswordRequest = {
  token: string
  password: string
}

type ResetPasswordResponse = Either<
  UserNotFoundError | UserUnauthorizedError,
  void
>

type ResetTokenPayload = {
  sub: string
}

@Injectable()
export class ResetPasswordUseCase {
  constructor(
    private tokenVerifier: TokenVerifier,
    private usersRepository: UsersRepository,
    private hashGenerator: HashGenerator,
    private refreshTokenRepository: RefreshTokenRepository,
  ) {}

  async execute({
    token,
    password,
  }: ResetPasswordRequest): Promise<ResetPasswordResponse> {
    let payload: ResetTokenPayload

    try {
      payload = this.tokenVerifier.verify<ResetTokenPayload>(token)
    } catch {
      return left(new UserUnauthorizedError())
    }

    const user = await this.usersRepository.findById(payload.sub)

    if (!user) {
      return left(new UserNotFoundError())
    }

    const passwordHash = await this.hashGenerator.hash(password)

    user.resetPassword(passwordHash)

    await this.usersRepository.save(user)
    await this.refreshTokenRepository.revokeAllForUser(user.id.toString())

    return right(undefined)
  }
}
</file>

<file path="src/infra/auth/auth.module.ts">
import { Module } from '@nestjs/common'
import { JwtModule } from '@nestjs/jwt'
import { PassportModule } from '@nestjs/passport'
import { JwtStrategy } from './jwt.strategy'
import { APP_GUARD } from '@nestjs/core'
import { JwtAuthGuard } from './jwt-auth.guard'
import { EnvService } from '../env/env.service'
import { EnvModule } from '../env/env.module'
import { TokenService } from './token.service'
import { RefreshTokenService } from './refresh-token.service'
import { CryptographyModule } from '../cryptography/cryptography.module'
import { CacheModule } from '../cache/cache.module'
import { RefreshTokenRepository } from './refresh-token.repository'
import { TokenRepository } from './token-repository'

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      imports: [EnvModule],
      inject: [EnvService],
      global: true,
      useFactory(env: EnvService) {
        const privateKey = env.get('JWT_PRIVATE_KEY')
        const publicKey = env.get('JWT_PUBLIC_KEY')

        return {
          signOptions: { algorithm: 'RS256' },
          privateKey: Buffer.from(privateKey, 'base64'),
          publicKey: Buffer.from(publicKey, 'base64'),
        }
      },
    }),
    CryptographyModule,
    CacheModule,
  ],
  providers: [
    JwtStrategy,
    EnvService,
    {
      provide: TokenRepository,
      useClass: TokenService,
    },
    {
      provide: RefreshTokenRepository,
      useClass: RefreshTokenService,
    },
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard,
    },
  ],
  exports: [TokenRepository, RefreshTokenRepository],
})
export class AuthModule {}
</file>

<file path="src/infra/auth/token.service.ts">
import { Injectable } from '@nestjs/common'
import { Encrypter } from '@/shared/cryptography/encrypter'
import { TokenRepository } from './token-repository'

@Injectable()
export class TokenService implements TokenRepository {
  constructor(private encrypter: Encrypter) {}

  async generateAccessToken(payload: {
    sub: string
    role: string
    jti: string
  }) {
    const now = Math.floor(Date.now() / 1000)
    const exp = now + 60 * 60 // 1 hour

    const token = await this.encrypter.encrypt({
      ...payload,
      iat: now,
      exp,
    })

    return { token, expiresIn: exp }
  }

  async generateRefreshToken(payload: {
    sub: string
    role: string
    jti: string
  }) {
    const now = Math.floor(Date.now() / 1000)
    const exp = now + 60 * 60 * 24 * 7 // 7 days

    const token = await this.encrypter.encrypt({
      ...payload,
      iat: now,
      exp,
    })

    return { token, expiresIn: exp }
  }

  async generate(payload: Record<string, unknown>) {
    return this.encrypter.encrypt(payload)
  }
}
</file>

<file path="src/infra/http/controllers/user/__tests__/logout-user.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import request from 'supertest'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { RefreshTokenService } from '@/infra/auth/refresh-token.service'
import { JwtService } from '@nestjs/jwt'
import { CacheModule } from '@/infra/cache/cache.module'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('Logout User (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let refreshTokenService: RefreshTokenService
  let jwt: JwtService

  const endpoint = '/v1/users/logout'

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, CacheModule, CryptographyModule],
      providers: [UserFactory, RefreshTokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({ type: VersioningType.URI })

    prisma = moduleRef.get(PrismaService)
    jwt = moduleRef.get(JwtService)
    userFactory = moduleRef.get(UserFactory)
    refreshTokenService = moduleRef.get(RefreshTokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  it('[204] OK ‚Üí should logout user and revoke refresh token', async () => {
    const user = await userFactory.makePrismaUser()

    const jti = await refreshTokenService.create(user.id.toString())

    const now = Math.floor(Date.now() / 1000)
    const exp = now + 60 * 60 * 24 * 7 // 7 days

    const refreshToken = jwt.sign(
      {
        sub: user.id.toString(),
        role: user.role,
        jti,
        iat: now,
        exp,
      },
      { algorithm: 'RS256' },
    )

    const response = await request(app.getHttpServer())
      .post(endpoint)
      .set('Authorization', `Bearer ${refreshToken}`)

    expect(response.statusCode).toBe(204)
  })

  it('[401] Unauthorized ‚Üí should fail without token', async () => {
    const response = await request(app.getHttpServer()).post(endpoint)

    expect(response.statusCode).toBe(401)
  })

  it('[401] Unauthorized ‚Üí should fail with invalid token', async () => {
    const response = await request(app.getHttpServer())
      .post(endpoint)
      .set('Authorization', 'Bearer invalid.token.here')

    expect(response.statusCode).toBe(401)
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/reset-password.integration.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import request from 'supertest'
import { User } from '@/domain/user/enterprise/entities/user'
import { FakeMailer } from 'test/mail/fake-mailer'
import { MailRepository } from '@/infra/mail/mail-repository'
import { RedisService } from '@/infra/cache/redis/redis.service'
import { RefreshTokenService } from '@/infra/auth/refresh-token.service'
import { CacheModule } from '@/infra/cache/cache.module'
import { EnvModule } from '@/infra/env/env.module'

describe('Reset Password Flow (Integration)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let mailer: FakeMailer
  let cacheService: RedisService
  let refreshTokenService: RefreshTokenService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CacheModule, EnvModule],
      providers: [UserFactory, FakeMailer, RefreshTokenService, RedisService],
    })
      .overrideProvider(MailRepository)
      .useClass(FakeMailer)
      .compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    mailer = moduleRef.get(MailRepository) as FakeMailer
    cacheService = moduleRef.get(RedisService)
    refreshTokenService = moduleRef.get(RefreshTokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
    mailer.sent.length = 0
  })

  it('[INTEGRATION] ‚Üí should reset the password successfully', async () => {
    const user: User = await userFactory.makePrismaUser({
      email: 'example@email.com',
      passwordHash: 'old-password',
    })

    const refreshToken = await refreshTokenService.create(user.id.toString())

    await request(app.getHttpServer())
      .post('/v1/users/forgot-password')
      .send({ email: user.email })
      .expect(204)

    expect(mailer.sent).toHaveLength(1)

    const html = mailer.sent[0].html
    const tokenMatch = html.match(/token=([a-zA-Z0-9._-]+)/)
    const token = tokenMatch?.[1]

    expect(token).toBeDefined()

    await request(app.getHttpServer())
      .post('/v1/users/reset-password')
      .send({
        token,
        password: 'new-password',
      })
      .expect(204)

    const updatedUser = await prisma.user.findUniqueOrThrow({
      where: { id: user.id.toString() },
    })

    expect(updatedUser.passwordHash).not.toBe(user.passwordHash)

    const storedToken = await cacheService.get(`refresh_token:${refreshToken}`)
    expect(storedToken).toBeNull()
  })
})
</file>

<file path="src/infra/http/controllers/user/edit-user-role.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { z } from 'zod'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { EditUserRoleUseCase } from '@/domain/user/application/use-cases/edit-user-role'
import { roleSchema } from '@/infra/auth/casl/roles'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import {
  InvalidRoleTransitionDto,
  UserNotFoundDto,
  WrongCredentialsDto,
} from '../../dtos/error/user'
import { EditUserRoleRequestDto } from '../../dtos/requests/user'
import type { UserPayload } from '@/infra/auth/jwt.strategy'
import { CurrentUser } from '@/infra/auth/current-user.decorator'

const editUserRoleBodySchema = z.object({
  role: roleSchema,
})

type EditUserRoleBodySchema = z.infer<typeof editUserRoleBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class EditUserRoleController {
  constructor(private editUserRoleUseCase: EditUserRoleUseCase) {}

  @Patch(':id/role')
  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('update-role', 'User'))
  @HttpCode(200)
  @ApiOperation({ summary: 'Edit user role' })
  @ApiBody({ type: EditUserRoleRequestDto })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: InvalidRoleTransitionDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @CurrentUser() currentUser: UserPayload,
    @Param('id', ParseUuidPipe) id: string,
    @Body(new ZodValidationPipe(editUserRoleBodySchema))
    body: EditUserRoleBodySchema,
  ) {
    const { role } = body

    const result = await this.editUserRoleUseCase.execute({
      id,
      role,
      actorId: currentUser.sub,
    })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/edit-user-status.controller.ts">
import {
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { EditUserStatusUseCase } from '@/domain/user/application/use-cases/edit-user-status'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import {
  UserForbiddenDto,
  UserNotFoundDto,
  WrongCredentialsDto,
} from '../../dtos/error/user'
import { CurrentUser } from '@/infra/auth/current-user.decorator'
import type { UserPayload } from '@/infra/auth/jwt.strategy'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class EditUserStatusController {
  constructor(private editUserStatusUseCase: EditUserStatusUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies(
    (ability) =>
      ability.can('activate', 'User') && ability.can('deactivate', 'User'),
  )
  @Patch(':id/status')
  @HttpCode(200)
  @ApiOperation({ summary: 'Edit user status' })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @CurrentUser() currentUser: UserPayload,
    @Param('id', ParseUuidPipe) id: string,
  ) {
    const result = await this.editUserStatusUseCase.execute({
      id,
      actorId: currentUser.sub,
    })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/logout-user.controller.ts">
import {
  Controller,
  HttpCode,
  Post,
  UseGuards,
  UseFilters,
} from '@nestjs/common'
import { LogoutUserUseCase } from '@/domain/user/application/use-cases/logout-user'
import { CurrentUser } from '@/infra/auth/current-user.decorator'
import { JwtAuthGuard } from '@/infra/auth/jwt-auth.guard'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  ApiInternalServerErrorResponse,
  ApiNoContentResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger'
import { InternalServerErrorDto } from '../../dtos/error/generic'
import { UserUnauthorizedDto } from '../../dtos/error/user'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import type { UserPayload } from '@/infra/auth/jwt.strategy'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class LogoutUserController {
  constructor(private logoutUserUseCase: LogoutUserUseCase) {}

  @Post('logout')
  @UseGuards(JwtAuthGuard)
  @HttpCode(204)
  @UseGuards(JwtAuthGuard)
  @ApiOperation({ summary: 'Logout user by invalidating refresh token' })
  @ApiNoContentResponse({ description: 'User logged out successfully' })
  @ApiUnauthorizedResponse({
    description: 'User is not authenticated',
    type: UserUnauthorizedDto,
  })
  @ApiInternalServerErrorResponse({
    description: 'Unexpected error',
    type: InternalServerErrorDto,
  })
  async handle(@CurrentUser() user: UserPayload) {
    const result = await this.logoutUserUseCase.execute({
      jti: user.jti,
      userId: user.sub,
    })

    if (result.isLeft()) throw result.value
  }
}
</file>

<file path="src/infra/http/http.module.ts">
import { Module } from '@nestjs/common'
import { UserControllersModule } from './controllers/user/user-controllers.module'
import { AvatarControllersModule } from './controllers/avatar/avatar-controllers.module'
import { TerminusModule } from '@nestjs/terminus'
import { HealthController } from './controllers/health.controller'
import { PrismaHealthIndicator } from './indicators/prisma-health.indicator'
import { RedisHealthIndicator } from './indicators/redis-health.indicator'
import { S3HealthIndicator } from './indicators/s3-health.indicator'
import { PrismaModule } from '../database/prisma/prisma.module'
import { CacheModule } from '../cache/cache.module'
import { StorageModule } from '../storage/storage.module'
import { MailHealthIndicator } from './indicators/mailer-health.indicator'
import { MailerModule } from '../mail/mailer.module'
import { AuditLogControllersModule } from './controllers/audit-log/audit-log-controllers.module'

@Module({
  imports: [
    UserControllersModule,
    AvatarControllersModule,
    AuditLogControllersModule,

    TerminusModule,
    PrismaModule,
    CacheModule,
    StorageModule,
    MailerModule,
  ],
  controllers: [HealthController],
  providers: [
    PrismaHealthIndicator,
    RedisHealthIndicator,
    S3HealthIndicator,
    MailHealthIndicator,
  ],
})
export class HttpModule {}
</file>

<file path="src/infra/storage/r2/r2-storage.ts">
import { Uploader, type UploadParams } from '@/shared/storage/uploader'
import {
  DeleteObjectCommand,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3'
import { randomUUID } from 'node:crypto'
import { Injectable } from '@nestjs/common'
import { EnvService } from '@/infra/env/env.service'
import { LoggerService } from '@/infra/logger/winston/logger.service'
import { withTimeout } from '@/shared/utils/with-timeout'
import { retryWithBackoff } from '@/shared/utils/retry-with-backoff'
import { circuitBreaker, BrokenCircuitError } from 'cockatiel'
import { createCircuitBreaker } from '@/shared/utils/circuit-breaker'

@Injectable()
export class R2Storage implements Uploader {
  private client: S3Client
  private bucketName: string
  private readonly timeout: number
  private readonly retryAttempts: number
  private readonly retryBackoffMs: number
  private breaker: ReturnType<typeof circuitBreaker>

  constructor(
    envService: EnvService,
    private readonly logger: LoggerService,
  ) {
    const accountId = envService.get('CLOUDFLARE_ACCOUNT_ID')
    this.bucketName = envService.get('AWS_BUCKET_NAME')
    this.timeout = envService.get('STORAGE_TIMEOUT')
    this.retryAttempts = envService.get('STORAGE_RETRY_ATTEMPTS')
    this.retryBackoffMs = envService.get('STORAGE_RETRY_BACKOFF')

    this.client = new S3Client({
      endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
      region: 'auto',
      credentials: {
        accessKeyId: envService.get('AWS_ACCESS_KEY_ID'),
        secretAccessKey: envService.get('AWS_SECRET_ACCESS_KEY'),
      },
    })

    this.breaker = createCircuitBreaker('storage', this.logger)
  }

  async upload({
    body,
    fileName,
    fileType,
  }: UploadParams): Promise<{ url: string }> {
    const uploadId = randomUUID()
    const uniqueFileName = `${uploadId}-${fileName}`

    try {
      await this.breaker.execute(() =>
        retryWithBackoff(
          () =>
            withTimeout(
              this.client.send(
                new PutObjectCommand({
                  Bucket: this.bucketName,
                  Key: uniqueFileName,
                  ContentType: fileType,
                  Body: body,
                }),
              ),
              this.timeout,
            ),
          {
            retries: this.retryAttempts,
            initialDelayMs: this.retryBackoffMs,
            factor: 2,
            onRetry: (err, attempt) => {
              this.logger.warn(
                `[Storage] upload retry #${attempt} after error: ${String(err)}`,
              )
            },
          },
        ),
      )
      return {
        url: uniqueFileName,
      }
    } catch (e) {
      if (e instanceof BrokenCircuitError) {
        this.logger.error(
          'Servi√ßo de storage indispon√≠vel (circuit breaker aberto)',
        )
        throw new Error('Servi√ßo de storage indispon√≠vel')
      }
      throw e
    }
  }

  async delete(fileName: string): Promise<void> {
    try {
      await this.breaker.execute(() =>
        retryWithBackoff(
          () =>
            withTimeout(
              this.client.send(
                new DeleteObjectCommand({
                  Bucket: this.bucketName,
                  Key: fileName,
                }),
              ),
              this.timeout,
            ),
          {
            retries: this.retryAttempts,
            initialDelayMs: this.retryBackoffMs,
            factor: 2,
            onRetry: (err, attempt) => {
              this.logger.warn(
                `[Storage] delete retry #${attempt} after error: ${String(err)}`,
              )
            },
          },
        ),
      )
    } catch (e) {
      if (e instanceof BrokenCircuitError) {
        this.logger.error(
          'Servi√ßo de storage indispon√≠vel (circuit breaker aberto)',
        )
        throw new Error('Servi√ßo de storage indispon√≠vel')
      }
      throw e
    }
  }
}
</file>

<file path="src/infra/storage/storage.module.ts">
import { Uploader } from '@/shared/storage/uploader'
import { Module } from '@nestjs/common'
import { EnvModule } from '../env/env.module'
import { R2Storage } from './r2/r2-storage'
import { LoggerModule } from '../logger/logger.module'

@Module({
  imports: [EnvModule, LoggerModule],
  providers: [
    {
      provide: Uploader,
      useClass: R2Storage,
    },
  ],
  exports: [Uploader],
})
export class StorageModule {}
</file>

<file path="src/infra/app.module.ts">
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { envSchema } from './env/env'
import { HttpModule } from './http/http.module'
import { AuthModule } from './auth/auth.module'
import { EnvModule } from './env/env.module'
import { LoggerModule } from './logger/logger.module'
import { EventsModule } from './events/events.module'

@Module({
  imports: [
    ConfigModule.forRoot({
      validate: (env) => envSchema.parse(env),
      isGlobal: true,
    }),
    LoggerModule,
    AuthModule,
    HttpModule,
    EnvModule,
    EventsModule,
  ],
})
export class AppModule {}
</file>

<file path="src/domain/audit-log/application/use-cases/create-audit-log.ts">
import { Injectable } from '@nestjs/common'
import { Either, right } from '@/core/either'
import { AuditLog } from '../../enterprise/entities/audit-log'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { ActorType } from '@prisma/client'
import { AuditLogRepository } from '../repositories/audit-log-repository'

type CreateAuditLogUseCaseRequest = {
  actorId: string
  actorType: ActorType
  action: string
  entity: string
  entityId: string
  changes?: Record<string, unknown> | null
}

type CreateAuditLogUseCaseResponse = Either<null, void>

@Injectable()
export class CreateAuditLogUseCase {
  constructor(private auditLogsRepository: AuditLogRepository) {}

  async execute({
    actorId,
    actorType,
    action,
    entity,
    entityId,
    changes,
  }: CreateAuditLogUseCaseRequest): Promise<CreateAuditLogUseCaseResponse> {
    const auditLog = AuditLog.create(
      {
        actorId,
        actorType,
        action,
        entity,
        entityId,
        changes,
      },
      new UniqueEntityID(),
    )

    await this.auditLogsRepository.create(auditLog)

    return right(undefined)
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserAvatarWatcher } from './user-avatar-watcher'
import { UserAvatarRepository } from '../repositories/user-avatar-repository'
import { UserAddressWatcher } from './user-address-watcher'
import { UserAddressRepository } from '../repositories/user-address-repository'
import { Address } from '@/shared/address/enterprise/entities/address'
import { UserAddressList } from '../../enterprise/entities/user-address-list'

type EditUserUseCaseRequest = {
  id: string
  name?: string
  addresses?: {
    street: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    zipCode: string
  }[]
  avatarId?: string
}

type EditUserUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private userAvatarRepository: UserAvatarRepository,
    private userAddressRepository: UserAddressRepository,
  ) {}

  async execute({
    id,
    name,
    addresses,
    avatarId,
  }: EditUserUseCaseRequest): Promise<EditUserUseCaseResponse> {
    const user = await this.usersRepository.findById(id)
    if (!user) return left(new UserNotFoundError())

    let finalName = user.name
    let finalAvatarId = user.avatarId ?? null
    let finalAddressList = user.addresses

    if (name) {
      finalName = name
    }

    if (avatarId !== undefined) {
      const avatarWatcher = new UserAvatarWatcher(user.avatarId ?? null)
      const newAvatarId = avatarId ? new UniqueEntityID(avatarId) : null

      avatarWatcher.update(newAvatarId)
      finalAvatarId = avatarWatcher.getUpdatedId()

      if (avatarWatcher.hasChanged() && newAvatarId) {
        await this.userAvatarRepository.attachAvatarToUser(
          user.id.toString(),
          newAvatarId.toString(),
        )
      }
    }

    if (addresses) {
      const currentAddresses =
        await this.userAddressRepository.findManyByUserId(id)

      const addressWatcher = new UserAddressWatcher(currentAddresses)
      const updatedAddresses = addresses.map((a) =>
        Address.create({ ...a, userId: user.id }),
      )

      addressWatcher.update(updatedAddresses)

      if (addressWatcher.hasChanged()) {
        await this.userAddressRepository.upsertManyForUser(
          user.id.toString(),
          updatedAddresses,
        )
        finalAddressList = new UserAddressList(updatedAddresses)
      }
    }

    user.update({
      name: finalName,
      avatarId: finalAvatarId,
      addresses: finalAddressList,
    })

    await this.usersRepository.save(user)

    return right({ data: user })
  }
}
</file>

<file path="src/infra/auth/jwt.strategy.ts">
import { Injectable } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { z } from 'zod'
import { EnvService } from '../env/env.service'
import { roleSchema } from './casl/roles'

const tokenPayloadSchema = z.object({
  sub: z.string().uuid(),
  role: roleSchema,
  iat: z.number(),
  exp: z.number(),
  jti: z.string().uuid(),
})

export type UserPayload = z.infer<typeof tokenPayloadSchema>

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(config: EnvService) {
    const publicKey = config.get('JWT_PUBLIC_KEY')

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: Buffer.from(publicKey, 'base64'),
      algorithms: ['RS256'],
    })
  }

  async validate(payload: UserPayload) {
    return tokenPayloadSchema.parse(payload)
  }
}
</file>

<file path="src/infra/http/controllers/user/authenticate-user.controller.ts">
import { AuthenticateUserUseCase } from '@/domain/user/application/use-cases/authenticate-user'
import { Public } from '@/infra/auth/public'
import {
  Body,
  Controller,
  HttpCode,
  Post,
  UseFilters,
  UseGuards,
  UsePipes,
} from '@nestjs/common'
import { z } from 'zod'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { UserInactiveDto, WrongCredentialsDto } from '../../dtos/error/user'
import { AuthenticateUserRequestDto } from '../../dtos/requests/user'
import { AuthenticateUserResponseDto } from '../../dtos/response/user'
import { RateLimit } from '@/shared/rate-limit/rate-limit.decorator'
import { RateLimitGuard } from '@/shared/rate-limit/rate-limit.guard'

const authenticateBodySchema = z.object({
  email: z.string().email(),
  password: z.string(),
})

type AuthenticateBodySchema = z.infer<typeof authenticateBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Public()
@Controller({ path: 'users', version: '1' })
export class AuthenticateUserController {
  constructor(private authenticateUser: AuthenticateUserUseCase) {}

  @Post('login')
  @UseGuards(RateLimitGuard)
  @RateLimit(5, 60)
  @HttpCode(200)
  @ApiOperation({ summary: 'Authenticate user' })
  @ApiBody({ type: AuthenticateUserRequestDto })
  @ApiOkResponse({
    description: 'Success',
    type: AuthenticateUserResponseDto,
  })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserInactiveDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  @UsePipes(new ZodValidationPipe(authenticateBodySchema))
  async handle(@Body() body: AuthenticateBodySchema) {
    const { email, password } = body
    const result = await this.authenticateUser.execute({ email, password })

    if (result.isLeft()) throw result.value

    return {
      access_token: result.value.accessToken,
      refresh_token: result.value.refreshToken,
      expiresIn: result.value.expiresIn,
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/create-user.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Post,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { z } from 'zod'
import { CreateUserUseCase } from '@/domain/user/application/use-cases/create-user'
import { UserPresenter } from '../../presenters/user.presenter'
import { Role } from '@prisma/client'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiConflictResponse,
  ApiCreatedResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'

import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import {
  UserAlreadyExistsDto,
  UserForbiddenDto,
  WrongCredentialsDto,
} from '../../dtos/error/user'
import { UserResponseDto } from '../../dtos/response/user'
import { CreateUserRequestDto } from '../../dtos/requests/user'
import { CurrentUser } from '@/infra/auth/current-user.decorator'
import type { UserPayload } from '@/infra/auth/jwt.strategy'

const createUserBodySchema = z.object({
  name: z.string(),
  email: z.string().email(),
  password: z.string(),
  addresses: z.array(
    z.object({
      street: z.string(),
      number: z.string(),
      complement: z.string().nullish(),
      neighborhood: z.string(),
      city: z.string(),
      state: z.string(),
      zipCode: z.string(),
    }),
  ),
  role: z.nativeEnum(Role),
})

type CreateUserBodySchema = z.infer<typeof createUserBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class CreateUserController {
  constructor(private createUserUseCase: CreateUserUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('create', 'User'))
  @Post()
  @HttpCode(201)
  @ApiOperation({ summary: 'Create user' })
  @ApiBody({ type: CreateUserRequestDto })
  @ApiCreatedResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiConflictResponse({ type: UserAlreadyExistsDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @CurrentUser() currentUser: UserPayload,
    @Body(new ZodValidationPipe(createUserBodySchema))
    body: CreateUserBodySchema,
  ) {
    const result = await this.createUserUseCase.execute({
      actorId: currentUser.sub,
      ...body,
    })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/edit-user.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { EditUserUseCase } from '@/domain/user/application/use-cases/edit-user'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { z } from 'zod'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { EditUserRequestDto } from '../../dtos/requests/user'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import {
  UserNotFoundDto,
  UserForbiddenDto,
  WrongCredentialsDto,
} from '../../dtos/error/user'
import { UserResponseDto } from '../../dtos/response/user'
import { ParseUuidPipe, ZodValidationPipe } from '../../pipes'
import { userCanUpdateSelfHandler } from '@/infra/auth/casl/handlers/user-can-update-self.handler'

const editUserBodySchema = z.object({
  name: z.string().optional(),
  addresses: z
    .array(
      z.object({
        street: z.string(),
        number: z.string(),
        complement: z.string().nullish(),
        neighborhood: z.string(),
        city: z.string(),
        state: z.string(),
        zipCode: z.string(),
      }),
    )
    .optional(),
  avatarId: z.string().uuid().optional(),
})

type EditUserBodySchema = z.infer<typeof editUserBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class EditUserController {
  constructor(private editUserUseCase: EditUserUseCase) {}

  @Patch(':id')
  @UseGuards(CaslAbilityGuard)
  @CheckPolicies(userCanUpdateSelfHandler)
  @HttpCode(200)
  @ApiOperation({ summary: 'Edit user' })
  @ApiBody({ type: EditUserRequestDto })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @Param('id', ParseUuidPipe) id: string,
    @Body(new ZodValidationPipe(editUserBodySchema)) body: EditUserBodySchema,
  ) {
    const result = await this.editUserUseCase.execute({ id, ...body })

    if (result.isLeft()) throw result.value

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="test/factories/make-user.ts">
import { faker } from '@faker-js/faker'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { User, type UserProps } from '@/domain/user/enterprise/entities/user'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaUserMapper } from '@/infra/database/prisma/mappers/user/prisma-user.mapper'
import { UserAddressList } from '@/domain/user/enterprise/entities/user-address-list'
import { Address } from '@/shared/address/enterprise/entities/address'

export function makeUser(
  override: Partial<Omit<UserProps, 'addresses'>> & {
    addresses?: Address[]
  } = {},
  id?: UniqueEntityID,
  actorId?: UniqueEntityID,
) {
  const { addresses, ...rest } = override

  const addressesList = addresses
    ? new UserAddressList(addresses)
    : new UserAddressList()

  const user = User.create(
    {
      name: faker.person.fullName(),
      email: faker.internet.email(),
      passwordHash: faker.internet.password(),
      role: 'OPERATOR',
      isActive: true,
      addresses: addressesList,
      ...rest,
    },
    id,
    actorId,
  )

  return user
}

@Injectable()
export class UserFactory {
  constructor(private prisma: PrismaService) {}

  async makePrismaUser(
    data: Partial<UserProps> & { addresses?: Address[] } = {},
  ): Promise<User> {
    const user = makeUser({
      ...data,
      addresses: data.addresses,
    })

    await this.prisma.user.create({
      data: PrismaUserMapper.toPrisma(user),
    })

    return user
  }

  async makeManyPrismaUser(
    data: (Partial<UserProps> & { addresses?: Address[] })[] = [],
  ): Promise<User[]> {
    const users = data.map((attrs) =>
      makeUser({
        ...attrs,
        addresses: attrs.addresses,
      }),
    )

    if (users.length === 0) return []

    await this.prisma.user.createMany({
      data: users.map(PrismaUserMapper.toPrisma),
    })

    return users
  }
}
</file>

<file path="test/repositories/user/in-memory-users-repository.ts">
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { DomainEvents } from '@/core/events/domain-events'
import type { PaginationParams } from '@/core/repositories/pagination-params'
import type { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import type { User } from '@/domain/user/enterprise/entities/user'

export class InMemoryUsersRepository implements UsersRepository {
  public items: User[] = []

  async findById(id: string) {
    const user = this.items.find((item) => item.id.toString() === id)

    return user || null
  }

  async findManyByIds(ids: string[]): Promise<User[]> {
    const idSet = new Set(ids)
    return this.items.filter((user) => idSet.has(user.id.toString()))
  }

  async findByEmail(email: string) {
    const user = this.items.find((item) => item.email === email)

    return user || null
  }

  async list({ page = 1, perPage = 20 }: PaginationParams) {
    const total = this.items.length
    const startIndex = (page - 1) * perPage
    const endIndex = startIndex + perPage

    const users = this.items
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(startIndex, endIndex)

    return [users, total] as [User[], number]
  }

  async create(user: User) {
    this.items.push(user)

    DomainEvents.dispatchEventsForAggregate(user.id)
  }

  async save(user: User) {
    const itemIndex = this.items.findIndex((item) => item.id === user.id)

    this.items[itemIndex] = user
  }

  async delete(user: User) {
    const itemIndex = this.items.findIndex((item) => item.id === user.id)

    this.items.splice(itemIndex, 1)
  }

  async dispatchEvent(userId: UniqueEntityID) {
    DomainEvents.dispatchEventsForAggregate(userId)
  }
}
</file>

<file path="src/infra/env/env.ts">
import { z } from 'zod'

export const envSchema = z.object({
  NODE_ENV: z.string(),
  APP_PORT: z.coerce.number().optional().default(3333),

  DATABASE_URL: z.string().url(),
  DATABASE_HOST: z.string(),
  DATABASE_PORT: z.string(),
  DATABASE_USERNAME: z.string(),
  DATABASE_PASSWORD: z.string(),
  DATABASE_NAME: z.string(),

  REDIS_HOST: z.string().optional().default('127.0.0.1'),
  REDIS_PORT: z.coerce.number().optional().default(6379),
  REDIS_DB: z.coerce.number().optional().default(0),
  REDIS_COMMAND_TIMEOUT: z.coerce.number(),

  RATE_LIMIT_POINTS: z.coerce.number(),
  RATE_LIMIT_DURATION: z.coerce.number(),

  CLOUDFLARE_ACCOUNT_ID: z.string(),
  AWS_ACCESS_KEY_ID: z.string(),
  AWS_SECRET_ACCESS_KEY: z.string(),
  AWS_BUCKET_NAME: z.string(),
  STORAGE_RETRY_ATTEMPTS: z.coerce.number(),
  STORAGE_RETRY_BACKOFF: z.coerce.number(),
  STORAGE_TIMEOUT: z.coerce.number(),

  RESEND_API_KEY: z.string(),
  RESET_PASSWORD_URL: z.string(),
  EMAIL_RETRY_ATTEMPTS: z.coerce.number(),
  EMAIL_RETRY_BACKOFF: z.coerce.number(),
  EMAIL_SEND_TIMEOUT: z.coerce.number(),

  JWT_PRIVATE_KEY: z.string(),
  JWT_PUBLIC_KEY: z.string(),
})

export type Env = z.infer<typeof envSchema>
</file>

<file path="src/infra/http/controllers/user/__tests__/authenticate-user.controller.e2e-spec.ts">
import { UserFactory } from 'test/factories/make-user'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { hash } from 'bcryptjs'
import request from 'supertest'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { JwtService } from '@nestjs/jwt'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import type { User } from '@/domain/user/enterprise/entities/user'
import { RateLimitService } from '@/shared/rate-limit/rate-limit.service'

const authenticateUserEndpoint = '/v1/users/login'

describe('Authenticate User (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let jwt: JwtService
  let adminUser: User
  let rateLimitService: RateLimitService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)
    rateLimitService = app.get(RateLimitService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
    rateLimitService.clearAll()

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
      passwordHash: await hash('123456', 8),
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe('TRUNCATE TABLE "users" CASCADE')
  })

  describe(`[POST] ${authenticateUserEndpoint}`, async () => {
    it('[200] Success ‚Üí Return token', async () => {
      const response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({ email: adminUser.email, password: '123456' })

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        access_token: expect.objectContaining({
          expiresIn: expect.any(Number),
          token: expect.any(String),
        }),
        refresh_token: expect.objectContaining({
          expiresIn: expect.any(Number),
          token: expect.any(String),
        }),
        expiresIn: expect.any(Number),
      })

      const payload = jwt.verify(response.body.access_token.token)
      expect(payload.sub).toBe(adminUser.id.toString())
    })

    it('[400] Bad Request ‚Üí Missing required fields', async () => {
      let response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({ password: 'whatever123' })

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 400,
          error: 'Bad Request',
          message: expect.stringMatching(/Missing required fields/),
        }),
      )

      response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({ email: 'whatever@example.com' })

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 400,
          error: 'Bad Request',
          message: expect.stringMatching(/Missing required fields/),
        }),
      )
    })

    it('[401] Unauthorized ‚Üí Wrong credentials', async () => {
      const response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({
          email: adminUser.email,
          password: 'WrongPass!',
        })

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Credentials are not valid.',
      })
    })

    it('[403] Forbidden ‚Üí Inactive user', async () => {
      const user = await userFactory.makePrismaUser({
        isActive: false,
        passwordHash: await hash('123456', 8),
      })

      const response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({ email: user.email, password: '123456' })

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'User inactive',
      })
    })

    it('[422] Unprocessable Entity ‚Üí Invalid email', async () => {
      const response = await request(app.getHttpServer())
        .post(authenticateUserEndpoint)
        .send({ email: 'invalid-email', password: 'somePass123' })

      expect(response.statusCode).toBe(422)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 422,
          error: 'Unprocessable Entity',
          message: 'Validation failed',
        }),
      )
    })

    it('[429] should return 429 after exceeding rate limit', async () => {
      for (let i = 0; i < 5; i++) {
        await request(app.getHttpServer())
          .post('/v1/users/login')
          .send({ email: adminUser.email, password: 'errada' })
          .expect(401)
      }

      const response = await request(app.getHttpServer())
        .post('/v1/users/login')
        .send({ email: adminUser.email, password: 'errada' })
        .expect(429)
      expect(response.headers['retry-after']).toBeDefined()
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-role.controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import type { User } from '@/domain/user/enterprise/entities/user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { Role } from '@prisma/client'
import { randomUUID } from 'node:crypto'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('Edit User Role (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let operatorUser: User
  let operatorAccessToken: {
    token: string
    expiresIn: number
  }
  let supervisorUser: User
  let supervisorAccessToken: {
    token: string
    expiresIn: number
  }
  let targetUser: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })

    operatorUser = await userFactory.makePrismaUser({
      email: 'operator.user@example.com',
      role: 'OPERATOR',
    })

    operatorAccessToken = await token.generateAccessToken({
      sub: operatorUser.id.toString(),
      role: operatorUser.role,
      jti: randomUUID(),
    })

    supervisorUser = await userFactory.makePrismaUser({
      email: 'supervisor.user@example.com',
      role: 'SUPERVISOR',
    })

    supervisorAccessToken = await token.generateAccessToken({
      sub: supervisorUser.id.toString(),
      role: supervisorUser.role,
      jti: randomUUID(),
    })

    targetUser = await userFactory.makePrismaUser({
      email: 'target.user@example.com',
      role: 'OPERATOR',
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[PATCH] /v1/users/:id/role', async () => {
    it('[200] Success ‚Üí should be able to edit user role', async () => {
      const payload = {
        role: Role.MANAGER,
      }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/role`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        data: expect.objectContaining({
          id: targetUser.id.toString(),
          role: Role.MANAGER,
        }),
      })

      const userOnDatabase = await prisma.user.findUnique({
        where: {
          id: targetUser.id.toString(),
        },
      })

      expect(userOnDatabase?.role).toBe(Role.MANAGER)
    })

    it('[400] Bad Request ‚Üí should not be able to edit user role without the right id', async () => {
      const payload = { role: Role.MANAGER }

      const response = await request(app.getHttpServer())
        .patch('/v1/users/invalid-uuid/role')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual({
        statusCode: 400,
        error: 'Bad Request',
        message: 'Param id must be a valid UUID',
      })
    })

    it('[401] Unauthorized ‚Üí should not be able to edit user role without token', async () => {
      const payload = { role: Role.MANAGER }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/role`)
        .send(payload)

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to edit user role without permission (OPERATOR)', async () => {
      const payload = { role: Role.MANAGER }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/role`)
        .set('Authorization', `Bearer ${operatorAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to edit user role without permission (SUPERVISOR)', async () => {
      const payload = { role: Role.ADMIN }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/role`)
        .set('Authorization', `Bearer ${supervisorAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[404] Not Found ‚Üí should not be able to edit not found user', async () => {
      const fakeId = randomUUID()
      const payload = { role: Role.MANAGER }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${fakeId}/role`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(404)
      expect(response.body).toEqual({
        statusCode: 404,
        error: 'Not Found',
        message: 'User not found',
      })
    })

    it('[422] Unprocessable Entity ‚Üí should not be able to edit user with invalid role', async () => {
      const payload = { role: 'UNKNOWN_ROLE' }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/role`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(422)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 422,
          error: 'Unprocessable Entity',
          message: 'Validation failed',
        }),
      )
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-status.controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import type { User } from '@/domain/user/enterprise/entities/user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { randomUUID } from 'node:crypto'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('Edit User Status (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let managerUser: User
  let managerAccessToken: {
    token: string
    expiresIn: number
  }
  let operatorUser: User
  let operatorAccessToken: {
    token: string
    expiresIn: number
  }
  let targetUser: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })

    managerUser = await userFactory.makePrismaUser({
      email: 'manager.user@example.com',
      role: 'MANAGER',
    })

    managerAccessToken = await token.generateAccessToken({
      sub: managerUser.id.toString(),
      role: managerUser.role,
      jti: randomUUID(),
    })

    operatorUser = await userFactory.makePrismaUser({
      email: 'operator.user@example.com',
      role: 'OPERATOR',
    })

    operatorAccessToken = await token.generateAccessToken({
      sub: operatorUser.id.toString(),
      role: operatorUser.role,
      jti: randomUUID(),
    })

    targetUser = await userFactory.makePrismaUser({
      email: 'target.user@example.com',
      role: 'OPERATOR',
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[PATCH] /v1/users/status/:id', async () => {
    it('[200] Success ‚Üí should be able to edit user status (ADMIN)', async () => {
      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/status`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        data: expect.objectContaining({
          id: targetUser.id.toString(),
          isActive: false,
        }),
      })

      const userOnDatabase = await prisma.user.findUnique({
        where: {
          id: targetUser.id.toString(),
        },
      })

      expect(userOnDatabase?.isActive).toBe(false)
    })

    it('[200] Success ‚Üí should be able to edit user status (MANAGER)', async () => {
      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id}/status`)
        .set('Authorization', `Bearer ${managerAccessToken.token}`)

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        data: expect.objectContaining({
          id: targetUser.id.toString(),
          isActive: false,
        }),
      })

      const userOnDatabase = await prisma.user.findUnique({
        where: { id: targetUser.id.toString() },
      })
      expect(userOnDatabase?.isActive).toBe(false)
    })

    it('[400] Bad Request ‚Üí should not be able to edit user status without the right id', async () => {
      const response = await request(app.getHttpServer())
        .patch('/v1/users/invalid-uuid/status')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual({
        statusCode: 400,
        error: 'Bad Request',
        message: 'Param id must be a valid UUID',
      })
    })

    it('[401] Unauthorized ‚Üí should not be able to edit user status without token', async () => {
      const response = await request(app.getHttpServer()).patch(
        `/v1/users/${targetUser.id.toString()}/status`,
      )

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to edit user status without permission', async () => {
      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${targetUser.id.toString()}/status`)
        .set('Authorization', `Bearer ${operatorAccessToken.token}`)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[404] Not Found ‚Üí should not be able to edit not found user', async () => {
      const fakeId = randomUUID()
      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${fakeId}/status`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(404)
      expect(response.body).toEqual({
        statusCode: 404,
        error: 'Not Found',
        message: 'User not found',
      })
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/find-user-by-id.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import type { User } from '@/domain/user/enterprise/entities/user'
import { Role } from '@prisma/client'
import { randomUUID } from 'node:crypto'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'

describe('Find User By Id (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let operatorUser: User
  let operatorAccessToken: {
    token: string
    expiresIn: number
  }
  let targetUser: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })

    operatorUser = await userFactory.makePrismaUser({
      email: 'operator.user@example.com',
      role: 'OPERATOR',
    })

    operatorAccessToken = await token.generateAccessToken({
      sub: operatorUser.id.toString(),
      role: operatorUser.role,
      jti: randomUUID(),
    })

    targetUser = await userFactory.makePrismaUser({
      name: 'Target User',
      email: 'target.user@example.com',
      role: 'OPERATOR',
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[GET] /v1/users/:id', async () => {
    it('[200] Success ‚Üí should be able to find user by id', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v1/users/${targetUser.id.toString()}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        data: expect.objectContaining({
          id: targetUser.id.toString(),
          name: 'Target User',
          email: 'target.user@example.com',
          role: Role.OPERATOR,
          isActive: true,
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
        }),
      })
    })

    it('[400] Bad Request ‚Üí should not be able to find user without the right id', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users/invalid-uuid')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual({
        statusCode: 400,
        error: 'Bad Request',
        message: 'Param id must be a valid UUID',
      })
    })

    it('[401] Unauthorized ‚Üí should not be able to find user without token', async () => {
      const response = await request(app.getHttpServer()).get(
        `/v1/users/${targetUser.id.toString()}`,
      )

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to find user without permission', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v1/users/${targetUser.id.toString()}`)
        .set('Authorization', `Bearer ${operatorAccessToken.token}`)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it("[404] Not Found ‚Üí should not be able to find user that does'nt exists", async () => {
      const fakeId = randomUUID()
      const response = await request(app.getHttpServer())
        .get(`/v1/users/${fakeId}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(404)
      expect(response.body).toEqual({
        statusCode: 404,
        error: 'Not Found',
        message: 'User not found',
      })
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/user-controllers.module.ts">
import { Module } from '@nestjs/common'
import { CreateUserController } from './create-user.controller'
import { CreateUserUseCase } from '@/domain/user/application/use-cases/create-user'
import { FindUserByIdController } from './find-user-by-id.controller'
import { FindUserByIdUseCase } from '@/domain/user/application/use-cases/find-user-by-id'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { AuthenticateUserController } from './authenticate-user.controller'
import { AuthenticateUserUseCase } from '@/domain/user/application/use-cases/authenticate-user'
import { CaslAbilityModule } from '@/infra/auth/casl/casl-ability.module'
import { EditUserController } from './edit-user.controller'
import { EditUserUseCase } from '@/domain/user/application/use-cases/edit-user'
import { EditUserStatusController } from './edit-user-status.controller'
import { EditUserStatusUseCase } from '@/domain/user/application/use-cases/edit-user-status'
import { EditUserRoleController } from './edit-user-role.controller'
import { EditUserRoleUseCase } from '@/domain/user/application/use-cases/edit-user-role'
import { ListUsersController } from './list-users.controller'
import { ListUsersUseCase } from '@/domain/user/application/use-cases/list-users'
import { StorageModule } from '@/infra/storage/storage.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { RefreshTokenController } from './refresh-token.controller'
import { RefreshUserTokenUseCase } from '@/domain/user/application/use-cases/refresh-user-token'
import { AuthModule } from '@/infra/auth/auth.module'
import { LogoutUserController } from './logout-user.controller'
import { LogoutUserUseCase } from '@/domain/user/application/use-cases/logout-user'
import { MailerModule } from '@/infra/mail/mailer.module'
import { ResetPasswordController } from './reset-password.controller'
import { ResetPasswordUseCase } from '@/domain/user/application/use-cases/reset-password'
import { ForgotPasswordController } from './forgot-password.controller'
import { ForgotPasswordUseCase } from '@/domain/user/application/use-cases/forgot-password'
import { EnvModule } from '@/infra/env/env.module'
import { EditUserPasswordController } from './edit-user-password.controller'
import { EditUserPasswordUseCase } from '@/domain/user/application/use-cases/edit-user-password'
import { RateLimitModule } from '@/shared/rate-limit/rate-limit.module'

@Module({
  imports: [
    UserDatabaseModule,
    CryptographyModule,
    CaslAbilityModule,
    StorageModule,
    AuthModule,
    MailerModule,
    EnvModule,
    RateLimitModule,
  ],
  controllers: [
    AuthenticateUserController,
    CreateUserController,
    EditUserRoleController,
    EditUserStatusController,
    EditUserController,
    FindUserByIdController,
    ListUsersController,
    RefreshTokenController,
    LogoutUserController,
    ResetPasswordController,
    ForgotPasswordController,
    EditUserPasswordController,
  ],
  providers: [
    AuthenticateUserUseCase,
    CreateUserUseCase,
    EditUserRoleUseCase,
    EditUserStatusUseCase,
    EditUserUseCase,
    FindUserByIdUseCase,
    ListUsersUseCase,
    RefreshUserTokenUseCase,
    LogoutUserUseCase,
    ResetPasswordUseCase,
    ForgotPasswordUseCase,
    EditUserPasswordUseCase,
  ],
})
export class UserControllersModule {}
</file>

<file path="src/infra/mail/resend/resend-mailer.ts">
import { HttpException, Injectable } from '@nestjs/common'
import { Resend } from 'resend'
import type { MailRepository } from '../mail-repository'
import { EnvService } from '@/infra/env/env.service'
import { withTimeout } from '@/shared/utils/with-timeout'
import { retryWithBackoff } from '@/shared/utils/retry-with-backoff'
import { BrokenCircuitError } from 'cockatiel'
import { createCircuitBreaker } from '@/shared/utils/circuit-breaker'
import type { LoggerPort } from '@/infra/logger/winston/logger.interface'

interface SendEmailParams {
  to: string
  subject: string
  html: string
}

@Injectable()
export class ResendMailer implements MailRepository {
  private client: Resend
  private readonly timeout: number
  private readonly retryAttempts: number
  private readonly retryBackoffMs: number
  private breaker: ReturnType<typeof createCircuitBreaker>

  constructor(
    envService: EnvService,
    private logger: LoggerPort,
  ) {
    this.client = new Resend(envService.get('RESEND_API_KEY'))
    this.timeout = envService.get('EMAIL_SEND_TIMEOUT')
    this.retryAttempts = envService.get('EMAIL_RETRY_ATTEMPTS')
    this.retryBackoffMs = envService.get('EMAIL_RETRY_BACKOFF')

    this.breaker = createCircuitBreaker('email', this.logger)
  }

  async send(params: SendEmailParams): Promise<void> {
    try {
      await this.breaker.execute(() =>
        retryWithBackoff(
          () =>
            withTimeout(
              this.client.emails.send({
                from: 'onboarding@resend.dev',
                to: params.to,
                subject: params.subject,
                html: params.html,
              }),
              this.timeout,
            ),
          {
            retries: this.retryAttempts,
            initialDelayMs: this.retryBackoffMs,
            factor: 2,
            onRetry: (err, attempt) => {
              this.logger.warn(
                `[Email] retry #${attempt} after error: ${String(err)}`,
              )
            },
          },
        ),
      )
    } catch (e) {
      if (e instanceof BrokenCircuitError) {
        this.logger.error(
          'Servi√ßo de e-mail indispon√≠vel (circuit breaker aberto)',
        )
        throw new HttpException('Servi√ßo de e-mail indispon√≠vel', 503)
      }
      throw e
    }
  }

  async verify(): Promise<void> {
    try {
      await this.breaker.execute(() =>
        retryWithBackoff(
          () =>
            withTimeout(
              this.client.emails.send({
                to: 'healthcheck@example.com',
                from: 'no-reply@example.com',
                subject: '[HealthCheck] Email',
                html: '<p>Health check</p>',
              }),
              this.timeout,
            ),
          {
            retries: this.retryAttempts,
            initialDelayMs: this.retryBackoffMs,
            factor: 2,
            onRetry: (err, attempt) => {
              this.logger.warn(
                `[verify] Email retry #${attempt} after error: ${String(err)}`,
              )
            },
          },
        ),
      )
    } catch (e) {
      if (e instanceof BrokenCircuitError) {
        this.logger.error(
          'Servi√ßo de e-mail indispon√≠vel (circuit breaker aberto)',
        )
        throw new HttpException('Servi√ßo de e-mail indispon√≠vel', 503)
      }
      throw e
    }
  }
}
</file>

<file path="src/domain/user/application/use-cases/authenticate-user.ts">
import { left, right, type Either } from '@/core/either'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { Injectable } from '@nestjs/common'
import { WrongCredentialsError } from './errors/wrong-credentials-error'
import { HashComparer } from '../../../../shared/cryptography/hash-comparer'
import { UserInactiveError } from './errors/user-inactive-error'
import { RefreshTokenRepository } from '@/infra/auth/refresh-token.repository'
import { TokenRepository } from '@/infra/auth/token-repository'

type AuthenticateUserUseCaseRequest = {
  email: string
  password: string
}

type AuthenticateUserUseCaseResponse = Either<
  WrongCredentialsError | UserInactiveError,
  {
    accessToken: {
      token: string
      expiresIn: number
    }
    refreshToken: {
      token: string
      expiresIn: number
    }
    expiresIn: number
  }
>

@Injectable()
export class AuthenticateUserUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private hashComparar: HashComparer,
    private tokenRepository: TokenRepository,
    private refreshTokenRepository: RefreshTokenRepository,
  ) {}

  async execute({
    email,
    password,
  }: AuthenticateUserUseCaseRequest): Promise<AuthenticateUserUseCaseResponse> {
    const user = await this.usersRepository.findByEmail(email)

    if (!user) {
      return left(new WrongCredentialsError())
    }

    if (!user.isActive) {
      return left(new UserInactiveError())
    }

    const isPasswordValid = await this.hashComparar.compare(
      password,
      user.passwordHash,
    )

    if (!isPasswordValid) {
      return left(new WrongCredentialsError())
    }
    const jti = await this.refreshTokenRepository.create(user.id.toString())

    const accessToken = await this.tokenRepository.generateAccessToken({
      sub: user.id.toString(),
      role: user.role,
      jti,
    })

    const refreshToken = await this.tokenRepository.generateRefreshToken({
      sub: user.id.toString(),
      role: user.role,
      jti,
    })

    user.login()
    await this.usersRepository.dispatchEvent(user.id)

    return right({
      accessToken,
      refreshToken,
      expiresIn: accessToken.expiresIn,
    })
  }
}
</file>

<file path="src/infra/http/controllers/user/__tests__/create-user.controller.e2e-spec.ts">
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import type { User } from '@/domain/user/enterprise/entities/user'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'

const createUserEndpoint = '/v1/users'

describe('Create User (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let operatorUser: User
  let operatorAccessToken: {
    token: string
    expiresIn: number
  }

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })

    operatorUser = await userFactory.makePrismaUser({
      email: 'operator.user@example.com',
      role: 'OPERATOR',
    })

    operatorAccessToken = await token.generateAccessToken({
      sub: operatorUser.id.toString(),
      role: operatorUser.role,
      jti: randomUUID(),
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe(`[POST] ${createUserEndpoint}`, async () => {
    it('[201] Created ‚Üí should be able to create a new user', async () => {
      const payload = {
        name: 'New User',
        role: 'OPERATOR',
        password: '123456',
        email: 'new.user@example.com',
        addresses: [
          {
            street: 'New Street',
            number: '202',
            neighborhood: 'New Neighborhood',
            city: 'New City',
            state: 'New State',
            zipCode: '11111-111',
          },
        ],
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(201)

      const userOnDatabase = await prisma.user.findFirst({
        where: {
          email: payload.email,
        },
      })

      expect(userOnDatabase).toBeTruthy()
    })

    it('[400] Bad Request ‚Üí should not be able to create user without required params', async () => {
      const payload = {
        email: 'missing.name@example.com',
        password: 'SomePass1!',
        role: 'OPERATOR',
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(400)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Missing required fields',
        }),
      )
    })

    it('[401] Unauthorized ‚Üí should not be able to create user without token', async () => {
      const payload = {
        name: 'User NoAuth',
        email: 'noauth.user@example.com',
        password: 'NoAuthPass1!',
        role: 'OPERATOR',
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .send(payload)

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to create user without permission', async () => {
      const payload = {
        name: 'Attempted User',
        email: 'attempted@example.com',
        password: 'AttemptedPass1!',
        role: 'OPERATOR',
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .set('Authorization', `Bearer ${operatorAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[409] Conflict ‚Üí should not be able to create user with same email', async () => {
      await userFactory.makePrismaUser({
        email: 'new.user@example.com',
        role: 'OPERATOR',
      })

      const payload = {
        name: 'New User',
        role: 'OPERATOR',
        password: '123456',
        email: 'new.user@example.com',
        addresses: [
          {
            street: 'New Street',
            number: '202',
            neighborhood: 'New Neighborhood',
            city: 'New City',
            state: 'New State',
            zipCode: '11111-111',
          },
        ],
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(409)
      expect(response.body).toEqual({
        statusCode: 409,
        error: 'Conflict',
        message: `User ${payload.email} already exists`,
      })
    })

    it('[422] Unprocessable Entity ‚Üí should not be able to create user with invalid params', async () => {
      const payload = {
        name: 'Invalid Email',
        email: 'invalid-email',
        password: 'SomePass1!',
        role: 'UNKNOWN_ROLE',
        addresses: [],
      }

      const response = await request(app.getHttpServer())
        .post(createUserEndpoint)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(422)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 422,
          error: 'Unprocessable Entity',
          message: 'Validation failed',
        }),
      )
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/list-users.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import type { User } from '@/domain/user/enterprise/entities/user'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'

describe('List Users (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let operatorUser: User
  let operatorAccessToken: {
    token: string
    expiresIn: number
  }
  const ITEMS_PER_PAGE = 10

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })

    operatorUser = await userFactory.makePrismaUser({
      email: 'operator.user@example.com',
      role: 'OPERATOR',
    })

    operatorAccessToken = await token.generateAccessToken({
      sub: operatorUser.id.toString(),
      role: operatorUser.role,
      jti: randomUUID(),
    })

    const usersToCreate = Array.from(
      { length: ITEMS_PER_PAGE + 15 },
      (_, i) => ({
        name: `User${i + 1}`,
        email: `user${i + 1}@example.com`,
      }),
    )

    await userFactory.makeManyPrismaUser(usersToCreate)
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[GET] /v1/users', async () => {
    it('[200] Success ‚Üí should be able to list users with meta', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)

      expect(response.statusCode).toBe(200)
      expect(response.body.data).toHaveLength(20)
      expect(response.body.meta).toEqual({
        total: 27,
        count: 20,
        perPage: 20,
        totalPages: 2,
        currentPage: 1,
        nextPage: 2,
        previousPage: null,
      })
    })

    it('[200] Success should be able to list paginated users', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .query({ page: 2 })

      expect(response.statusCode).toBe(200)
      expect(response.body.data).toHaveLength(7)
      response.body.data.forEach((user: User) => {
        expect(user).toEqual(
          expect.objectContaining({
            id: expect.any(String),
            email: expect.any(String),
          }),
        )
      })
    })

    it('[401] Unauthorized ‚Üí should not be able to list users without token', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users')
        .query({ page: 1 })

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: expect.stringContaining('Unauthorized'),
      })
    })

    it('[403] Forbidden ‚Üí should not be able to list users without permission', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users')
        .set('Authorization', `Bearer ${operatorAccessToken.token}`)
        .query({ page: 1 })

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[422] Unprocessable Entity ‚Üí should not be able to list users with invalid query', async () => {
      const response = await request(app.getHttpServer())
        .get('/v1/users')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .query({ page: 'abc' })

      expect(response.statusCode).toBe(422)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 422,
          error: 'Unprocessable Entity',
          message: 'Validation failed',
        }),
      )
    })
  })
})
</file>

<file path="src/infra/http/controllers/avatar/__tests__/upload-avatar.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { AvatarDatabaseModule } from '@/infra/database/prisma/repositories/avatar/avatar-database.module'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import { User } from '@/domain/user/enterprise/entities/user'
import { Uploader } from '@/shared/storage/uploader'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'

describe('Upload Avatar (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }
  let uploader: Uploader

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        AppModule,
        AvatarDatabaseModule,
        UserDatabaseModule,
        CryptographyModule,
      ],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)
    uploader = moduleRef.get(Uploader)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[POST] /v1/users/avatar', async () => {
    it('[201] Created ‚Üí should create user avatar', async () => {
      const response = await request(app.getHttpServer())
        .post('/v1/avatar')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .attach('file', './test/e2e/sample-upload.png')

      expect(response.statusCode).toBe(201)
      expect(response.body).toEqual({
        data: expect.any(String),
      })
    })

    it('[500] Internal Server Error ‚Üí should return error if R2 upload fails', async () => {
      vi.spyOn(uploader, 'upload').mockResolvedValueOnce({
        url: '',
      })

      const res = await request(app.getHttpServer())
        .post('/v1/avatar')
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .attach('file', './test/e2e/sample-upload.png')
        .expect(500)

      expect(res.body.message).toBe('Failed to upload avatar')

      const avatarInDb = await prisma.avatar.findFirst({
        where: { userId: adminUser.id.toString() },
      })

      expect(avatarInDb).toBeNull()
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import { UserDatabaseModule } from '@/infra/database/prisma/repositories/user/user-database.module'
import type { User } from '@/domain/user/enterprise/entities/user'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { TokenService } from '@/infra/auth/token.service'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { randomUUID } from 'node:crypto'

describe('Edit User (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let token: TokenService
  let adminUser: User
  let adminAccessToken: {
    token: string
    expiresIn: number
  }

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CryptographyModule],
      providers: [UserFactory, TokenService],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    token = moduleRef.get(TokenService)

    await app.init()
  })

  afterAll(async () => {
    await app.close()
  })

  beforeEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )

    adminUser = await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      role: 'ADMIN',
    })

    adminAccessToken = await token.generateAccessToken({
      sub: adminUser.id.toString(),
      role: adminUser.role,
      jti: randomUUID(),
    })
  })

  afterEach(async () => {
    await prisma.$executeRawUnsafe(
      'TRUNCATE TABLE "users" RESTART IDENTITY CASCADE',
    )
  })

  describe('[PATCH] /v1/users/:id', async () => {
    it('[200] Success ‚Üí should be able to edit user data', async () => {
      const payload = {
        name: 'Updated Name',
        addresses: [
          {
            street: 'Any Street',
            number: '123',
            neighborhood: 'Any Neighborhood',
            city: 'Any City',
            state: 'Any State',
            zipCode: '12345-678',
          },
        ],
      }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${adminUser.id.toString()}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(200)
      expect(response.body).toEqual({
        data: expect.objectContaining({
          id: adminUser.id.toString(),
          name: payload.name,
        }),
      })

      const userOnDatabase = await prisma.user.findUnique({
        where: { id: adminUser.id.toString() },
      })
      expect(userOnDatabase?.name).toBe(payload.name)
    })

    it('[200] Success ‚Üí should sync addresses on edit', async () => {
      await prisma.address.createMany({
        data: [
          {
            id: 'addr-1',
            street: 'Old Street',
            number: '100',
            neighborhood: 'Old Neighborhood',
            city: 'Old City',
            state: 'Old State',
            zipCode: '00000-000',
            complement: null,
            userId: adminUser.id.toString(),
            createdAt: new Date(),
            updatedAt: new Date(),
          },
        ],
      })

      const payload = {
        name: 'Synced Name',
        addresses: [
          {
            street: 'New Street',
            number: '200',
            neighborhood: 'New Neighborhood',
            city: 'New City',
            state: 'New State',
            zipCode: '11111-111',
            complement: 'Apartment 202',
          },
        ],
      }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${adminUser.id.toString()}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(200)
      expect(response.body.data.addresses).toHaveLength(1)
      expect(response.body.data.addresses[0]).toEqual(
        expect.objectContaining({
          street: 'New Street',
          number: '200',
        }),
      )

      const addressesInDB = await prisma.address.findMany({
        where: { userId: adminUser.id.toString() },
      })

      expect(addressesInDB).toHaveLength(1)
      expect(addressesInDB[0].street).toBe('New Street')
    })

    it('[401] Unauthorized ‚Üí should not be able to edit user without token', async () => {
      const payload = { name: 'Attempt NoAuth' }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${adminUser.id.toString()}`)
        .send(payload)

      expect(response.statusCode).toBe(401)
      expect(response.body).toEqual({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Unauthorized',
      })
    })

    it('[403] Forbidden ‚Üí should not be able to edit another user data', async () => {
      const operatorUser = await userFactory.makePrismaUser({
        email: 'operator.user@example.com',
        role: 'OPERATOR',
      })
      const payload = { name: 'Attempted Edit' }

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${operatorUser.id.toString()}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send(payload)

      expect(response.statusCode).toBe(403)
      expect(response.body).toEqual({
        statusCode: 403,
        error: 'Forbidden',
        message: 'Acesso negado',
      })
    })

    it('[422] Unprocessable Entity ‚Üí should fail with invalid avatarId UUID', async () => {
      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${adminUser.id.toString()}`)
        .set('Authorization', `Bearer ${adminAccessToken.token}`)
        .send({ avatarId: 'invalid-uuid' })

      expect(response.statusCode).toBe(422)
      expect(response.body).toEqual(
        expect.objectContaining({
          statusCode: 422,
          error: 'Unprocessable Entity',
          message: 'Validation failed',
        }),
      )
    })
  })
})
</file>

<file path="src/infra/database/prisma/repositories/user/prisma-users-repository.ts">
import type { PaginationParams } from '@/core/repositories/pagination-params'
import type { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { User } from '@/domain/user/enterprise/entities/user'
import { Injectable } from '@nestjs/common'
import { CacheRepository } from '@/infra/cache/cache-repository'
import { PrismaService } from '../../prisma.service'
import { PrismaUserMapper } from '../../mappers/user/prisma-user.mapper'
import { DomainEvents } from '@/core/events/domain-events'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

@Injectable()
export class PrismaUsersRepository implements UsersRepository {
  constructor(
    private prisma: PrismaService,
    private cache: CacheRepository,
  ) {}

  async findById(id: string): Promise<User | null> {
    const cacheHit = await this.cache.get(`user:${id}:details`)

    if (cacheHit) {
      const cachedData = JSON.parse(cacheHit)

      return PrismaUserMapper.toDomain(cachedData)
    }

    const user = await this.prisma.user.findFirst({
      where: {
        id,
      },
      include: {
        addresses: true,
      },
    })

    if (!user) {
      return null
    }

    await this.cache.set(`user:${id}:details`, JSON.stringify(user))

    return PrismaUserMapper.toDomain(user)
  }

  async findManyByIds(ids: string[]): Promise<User[]> {
    const users = await this.prisma.user.findMany({
      where: {
        id: { in: ids },
      },
      include: {
        addresses: true,
      },
    })

    return users.map(PrismaUserMapper.toDomain)
  }

  async findByEmail(email: string): Promise<User | null> {
    const user = await this.prisma.user.findFirst({
      where: {
        email,
      },
      include: {
        addresses: true,
      },
    })

    if (!user) {
      return null
    }

    const userDetails = PrismaUserMapper.toDomain(user)

    return userDetails
  }

  async list({
    page = 1,
    perPage = 20,
  }: PaginationParams): Promise<[User[], number]> {
    const cacheHit = await this.cache.get(`users:page:${page}:${perPage}`)

    if (cacheHit) {
      const cachedData = JSON.parse(cacheHit)

      return cachedData.map(PrismaUserMapper.toDomain)
    }

    const [users, total] = await this.prisma.$transaction([
      this.prisma.user.findMany({
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * perPage,
        take: perPage,
        include: {
          addresses: true,
        },
      }),
      this.prisma.user.count(),
    ])

    await this.cache.set(`users:page:${page}:${perPage}`, JSON.stringify(users))

    return [users.map(PrismaUserMapper.toDomain), total]
  }

  async save(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.update({
        where: { id: data.id },
        data,
      }),
      this.cache.del(`user:${data.id}:details`),
    ])

    DomainEvents.dispatchEventsForAggregate(user.id)
  }

  async create(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.create({
        data,
      }),
      this.cache.del('users'),
    ])
    DomainEvents.dispatchEventsForAggregate(user.id)
  }

  async delete(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.delete({
        where: { id: data.id },
      }),
      this.cache.del(`user:${data.id}:details`),
      this.cache.del(`users`),
    ])
  }

  async dispatchEvent(userId: UniqueEntityID) {
    DomainEvents.dispatchEventsForAggregate(userId)
  }
}
</file>

<file path="src/infra/events/user/user-events.module.ts">
import { Module } from '@nestjs/common'
import { OnUserPasswordChanged } from '@/domain/audit-log/application/subscribers/user/on-user-password-changed'
import { CreateAuditLogUseCase } from '@/domain/audit-log/application/use-cases/create-audit-log'
import { AuditLogDatabaseModule } from '@/infra/database/prisma/repositories/audit-log/audit-log-database.module'
import { OnUserCreated } from '@/domain/audit-log/application/subscribers/user/on-user-created'
import { OnUserUpdated } from '@/domain/audit-log/application/subscribers/user/on-user-updated'
import { OnUserRoleChanged } from '@/domain/audit-log/application/subscribers/user/on-user-role-changed'
import { OnUserActiveStatusChanged } from '@/domain/audit-log/application/subscribers/user/on-user-active-status-changed'
import { OnUserLoggedIn } from '@/domain/audit-log/application/subscribers/user/on-user-logged-in'
import { OnUserLoggedOut } from '@/domain/audit-log/application/subscribers/user/on-user-logged-out'
import { OnUserRequestedPasswordReset } from '@/domain/audit-log/application/subscribers/user/on-user-requested-password-reset'
import { OnUserResetPassword } from '@/domain/audit-log/application/subscribers/user/on-user-reset-password'

@Module({
  imports: [AuditLogDatabaseModule],
  providers: [
    OnUserCreated,
    OnUserUpdated,
    OnUserPasswordChanged,
    OnUserRoleChanged,
    OnUserActiveStatusChanged,
    OnUserLoggedIn,
    OnUserLoggedOut,
    OnUserRequestedPasswordReset,
    OnUserResetPassword,
    CreateAuditLogUseCase,
  ],
})
export class UserEventsModule {}
</file>

<file path="src/domain/user/enterprise/entities/user.ts">
import { AggregateRoot } from '@/core/entities/aggregate-root'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { Optional } from '@/core/types/optional'
import type { Role } from '@prisma/client'
import { UserAddressList } from './user-address-list'
import { UserPasswordChangedEvent } from '../events/user-password-changed-event'
import { UserCreatedEvent } from '../events/user-created-event'
import { UserUpdatedEvent } from '../events/user-updated-event'
import { UserRoleChangedEvent } from '../events/user-role-changed-event'
import { UserActiveStatusChangedEvent } from '../events/user-active-status-changed-event'
import { UserLoggedInEvent } from '../events/user-logged-in-event'
import { UserLoggedOutEvent } from '../events/user-logged-out-event'
import { UserRequestedPasswordResetEvent } from '../events/user-request-password-reset-event'
import { UserResetPasswordEvent } from '../events/user-reset-password-event'

export interface UserProps {
  name: string
  email: string
  passwordHash: string
  role: Role
  isActive: boolean
  avatarId?: UniqueEntityID | null
  addresses: UserAddressList
  createdAt: Date
  updatedAt?: Date
}

export class User extends AggregateRoot<UserProps> {
  get name() {
    return this.props.name
  }

  get email() {
    return this.props.email
  }

  get passwordHash() {
    return this.props.passwordHash
  }

  get role() {
    return this.props.role
  }

  get isActive() {
    return this.props.isActive
  }

  get avatarId() {
    return this.props.avatarId
  }

  get addresses() {
    return this.props.addresses
  }

  get createdAt() {
    return this.props.createdAt
  }

  get updatedAt() {
    return this.props.updatedAt
  }

  updateRole(value: Role, actorId: string) {
    const previousData = this.props.role
    this.props.role = value

    this.addDomainEvent(new UserRoleChangedEvent(this, actorId, previousData))
    this.touch()
  }

  toggleActive(actorId: string) {
    const previousData = this.props.isActive
    this.props.isActive = !this.props.isActive

    this.addDomainEvent(
      new UserActiveStatusChangedEvent(this, actorId, previousData),
    )
    this.touch()
  }

  updateAddress(addresses: UserAddressList) {
    this.props.addresses = addresses
    this.touch()
  }

  updatePassword(hash: string) {
    this.props.passwordHash = hash

    this.addDomainEvent(new UserPasswordChangedEvent(this))
    this.touch()
  }

  resetPassword(hash: string) {
    this.props.passwordHash = hash

    this.addDomainEvent(new UserResetPasswordEvent(this))
    this.touch()
  }

  update({
    name,
    avatarId,
    addresses,
  }: {
    name: string
    avatarId: UniqueEntityID | null
    addresses: UserAddressList
  }) {
    let updated = false
    const previousData = {
      name: this.props.name,
      avatarId: this.props.avatarId,
      addresses: this.props.addresses,
    }

    if (this.props.name !== name) {
      this.props.name = name
      updated = true
    }

    if (this.props.avatarId?.toString() !== avatarId?.toString()) {
      this.props.avatarId = avatarId
      updated = true
    }

    if (!this.props.addresses.equals(addresses)) {
      this.props.addresses = addresses
      updated = true
    }

    if (updated) {
      this.touch()
      this.addDomainEvent(new UserUpdatedEvent(this, previousData))
    }
  }

  login() {
    this.addDomainEvent(new UserLoggedInEvent(this))
  }

  logout() {
    this.addDomainEvent(new UserLoggedOutEvent(this))
  }

  requestPasswordReset() {
    this.addDomainEvent(new UserRequestedPasswordResetEvent(this))
  }

  private touch() {
    this.props.updatedAt = new Date()
  }

  static create(
    props: Optional<UserProps, 'createdAt' | 'addresses'>,
    id?: UniqueEntityID,
    actorId?: UniqueEntityID,
  ) {
    const now = new Date()
    const user = new User(
      {
        ...props,
        role: props.role ?? 'OPERATOR',
        addresses: props.addresses ?? new UserAddressList(),
        isActive: props.isActive ?? true,
        createdAt: props.createdAt ?? now,
        updatedAt: props.updatedAt ?? now,
      },
      id,
    )

    const isNewUser = !id

    if (isNewUser && actorId) {
      user.addDomainEvent(new UserCreatedEvent(user, actorId.toString()))
    }

    return user
  }
}
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:cov": "vitest run --coverage",
    "test:debug": "vitest --inspect-brk -- inspect --logHeapUsage --threads=false",
    "test:e2e": "vitest run --config ./vitest.config.e2e.mjs",
    "test:e2e:watch": "vitest --config ./vitest.config.e2e.mjs",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:migrate:prod": "prisma migrate deploy && prisma generate",
    "prisma:studio": "prisma studio",
    "prisma:seed": "prisma db seed",
    "prepare": "husky install"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.821.0",
    "@casl/ability": "^6.7.3",
    "@nestjs-modules/ioredis": "^2.0.2",
    "@nestjs/axios": "^4.0.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/swagger": "^11.2.0",
    "@nestjs/terminus": "^11.0.0",
    "@nestjs/throttler": "^6.4.0",
    "@prisma/client": "^6.8.2",
    "bcryptjs": "^3.0.2",
    "cockatiel": "^3.2.1",
    "dayjs": "^1.11.13",
    "helmet": "^8.1.0",
    "ioredis": "^5.6.1",
    "kleur": "^4.1.5",
    "nest-winston": "^1.10.2",
    "passport-jwt": "^4.0.1",
    "rate-limiter-flexible": "^7.1.1",
    "reflect-metadata": "^0.2.2",
    "resend": "^4.5.2",
    "rxjs": "^7.8.2",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0",
    "zod": "^3.25.28",
    "zod-validation-error": "^3.4.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@faker-js/faker": "^9.8.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@rocketseat/eslint-config": "^2.2.2",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/bcryptjs": "^2.4.6",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "@vitest/coverage-v8": "^3.1.4",
    "dotenv": "^16.5.0",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^10.0.1",
    "eslint-import-resolver-typescript": "^4.4.2",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "multer": "^2.0.0",
    "prettier": "^3.4.2",
    "prisma": "^6.8.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.20.0",
    "unplugin-swc": "^1.5.3",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^3.1.4"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
</file>

</files>
