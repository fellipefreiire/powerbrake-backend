This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250529214226_create_user/
      migration.sql
    20250530160155_add_manager_role/
      migration.sql
    20250602180156_map_and_avatar_url/
      migration.sql
    20250602193921_create_avatar/
      migration.sql
    20250603023156_user_avatar/
      migration.sql
    migration_lock.toml
  schema.prisma
  seed.ts
src/
  core/
    entities/
      aggregate-root.ts
      entity.ts
      unique-entity-id.ts
    errors/
      generic-error/
        index.ts
      not-allowed-error/
        index.ts
      resource-not-found-error/
        index.ts
      use-case-error.ts
    events/
      domain-event.ts
      domain-events.spec.ts
      domain-events.ts
      event-handler.ts
    repositories/
      pagination-params.ts
    types/
      optional.ts
    either.spec.ts
    either.ts
  domain/
    user/
      application/
        repositories/
          user-avatar-repository.ts
          user-repository.ts
        use-cases/
          __tests__/
            authenticate-user.spec.ts
            create-user.spec.ts
            edit-user-role.spec.ts
            edit-user-status.spec.ts
            edit-user.spec.ts
            find-user-by-email.spec.ts
            find-user-by-id.spec.ts
            list-users.spec.ts
          errors/
            index.ts
            invalid-role-transition-error.ts
            user-already-exists-error.ts
            user-inactive-error.ts
            user-not-found.ts
            wrong-credentials-error.ts
          authenticate-user.ts
          create-user.ts
          edit-user-role.ts
          edit-user-status.ts
          edit-user.ts
          find-user-by-email.ts
          find-user-by-id.ts
          list-users.ts
      enterprise/
        entities/
          user-avatar.ts
          user.ts
  infra/
    auth/
      casl/
        models/
          user.ts
        subjects/
          user.ts
        ability.factory.ts
        casl-ability.guard.ts
        casl-ability.module.ts
        check-policies.decorator.ts
        permissions.ts
        roles.ts
      auth.module.ts
      current-user.decorator.ts
      jwt-auth.guard.ts
      jwt.strategy.ts
      public.ts
    cache/
      redis/
        redis-cache-repository.ts
        redis.service.ts
      cache-repository.ts
      cache.module.ts
    cryptography/
      bcrypt-hasher.ts
      cryptography.module.ts
      jwt-encrypter.ts
    database/
      prisma/
        mappers/
          avatar/
            prisma-avatar.mapper.ts
          user/
            prisma-user-avatar.mapper.ts
            prisma-user.mapper.ts
        prisma.service.ts
      repositories/
        avatar/
          avatar-database.module.ts
          prisma-avatar-repository.ts
        user/
          tests/
            prisma-user-repository.e2e-spec.ts
          prisma-user-avatar-repository.ts
          prisma-users-repository.ts
          user-database.module.ts
    decorators/
      service-tag.decorator.ts
    env/
      env.module.ts
      env.service.ts
      env.ts
    http/
      controllers/
        avatar/
          __tests__/
            upload-avatar.controller.e2e-spec.ts
          avatar-controllers.module.ts
          upload-avatar.controller.ts
        user/
          __tests__/
            authenticate-user.controller.e2e-spec.ts
            create-user.controller.e2e-spec.ts
            edit-user-controller.e2e-spec.ts
            edit-user-role.controller.e2e-spec.ts
            edit-user-status.controller.e2e-spec.ts
            find-user-by-id.controller.e2e-spec.ts
            list-users.controller.e2e-spec.ts
          authenticate-user.controller.ts
          create-user.controller.ts
          edit-user-role.controller.ts
          edit-user-status.controller.ts
          edit-user.controller.ts
          find-user-by-id.controller.ts
          list-users.controller.ts
          user-controllers.module.ts
      dtos/
        error/
          generic/
            bad-request.dto.ts
            conflict.dto.ts
            forbidden.dto.ts
            index.ts
            internal-server.dto.ts
            not-found.dto.ts
            too-many-requests.dto.ts
            unauthorized.dto.ts
            unprocessable-entity.dto.ts
            validation.dto.ts
          user/
            index.ts
            invalid-role-transition.dto.ts
            user-already-exists.dto.ts
            user-forbidden.dto.ts
            user-inactive.dto.ts
            user-not-found.dto.ts
            wrong-credentials.dto.ts
        requests/
          user/
            authenticate-request.dto.ts
            create-user-request.dto.ts
            edit-user-request.dto.ts
            edit-user-role-request.dto.ts
            index.ts
        response/
          user/
            authenticate-response.dto.ts
            index.ts
            user-response.dto.ts
      filters/
        app-error.filter.ts
        user-error.filter.ts
      pipes/
        parse-uuid.pipe.ts
        zod-validation.pipe.ts
      presenters/
        user.presenter.ts
      http.module.ts
    logger/
      logger.interceptor.ts
      logger.module.ts
      logger.service.ts
      winston.config.ts
      winston.provider.ts
      winston.token.ts
    storage/
      r2-storage.ts
      storage.module.ts
    app.module.ts
    main.ts
  shared/
    avatar/
      application/
        repositories/
          avatar-repository.ts
        storage/
          uploader.ts
        use-cases/
          errors/
            avatar-not-found-error.ts
            avatar-upload-failed-error.ts
            invalid-avatar-type-error.ts
          tests/
            upload-and-create-avatar.spec.ts
          upload-and-create-avatar.ts
      enterprise/
        entities/
          avatar.ts
    cryptography/
      encrypter.ts
      hash-comparer.ts
      hash-generator.ts
test/
  cryptography/
    fake-encrypter.ts
    fake-hasher.ts
  factories/
    make-avatar.ts
    make-user.ts
  repositories/
    avatar/
      in-memory-avatar-repository.ts
    user/
      in-memory-user-avatar-repository.ts
      in-memory-users-repository.ts
  storage/
    fake-uploader.ts
  utils/
    wait-for.ts
  setup-e2e.ts
.env.example
.eslintrc.json
.gitignore
.prettierrc
docker-compose.yml
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.eslint.json
tsconfig.json
vitest.config.e2e.mjs
vitest.config.mjs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250529214226_create_user/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('ADMIN', 'OPERATOR', 'SUPERVISOR');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'OPERATOR',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");
</file>

<file path="prisma/migrations/20250530160155_add_manager_role/migration.sql">
-- AlterEnum
ALTER TYPE "Role" ADD VALUE 'MANAGER';
</file>

<file path="prisma/migrations/20250602180156_map_and_avatar_url/migration.sql">
/*
  Warnings:

  - You are about to drop the column `createdAt` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `isActive` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `passwordHash` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `users` table. All the data in the column will be lost.
  - Added the required column `password_hash` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updated_at` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "users" DROP COLUMN "createdAt",
DROP COLUMN "isActive",
DROP COLUMN "passwordHash",
DROP COLUMN "updatedAt",
ADD COLUMN     "avatar_url" TEXT,
ADD COLUMN     "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "is_active" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "password_hash" TEXT NOT NULL,
ADD COLUMN     "updated_at" TIMESTAMP(3) NOT NULL;
</file>

<file path="prisma/migrations/20250602193921_create_avatar/migration.sql">
/*
  Warnings:

  - You are about to drop the column `avatar_url` on the `users` table. All the data in the column will be lost.
  - A unique constraint covering the columns `[avatar_id]` on the table `users` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "users" DROP COLUMN "avatar_url",
ADD COLUMN     "avatar_id" TEXT;

-- CreateTable
CREATE TABLE "avatars" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "url" TEXT NOT NULL,

    CONSTRAINT "avatars_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_avatar_id_key" ON "users"("avatar_id");

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_avatar_id_fkey" FOREIGN KEY ("avatar_id") REFERENCES "avatars"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250603023156_user_avatar/migration.sql">
-- AlterTable
ALTER TABLE "avatars" ADD COLUMN     "user_id" TEXT;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  name         String
  email        String   @unique
  passwordHash String   @map("password_hash")
  role         Role     @default(OPERATOR)
  isActive     Boolean  @default(true) @map("is_active")
  avatarId     String?  @unique @map("avatar_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  avatar Avatar? @relation(fields: [avatarId], references: [id])

  @@map("users")
}

model Avatar {
  id     String  @id @default(uuid())
  title  String
  url    String
  userId String? @map("user_id")

  user User?

  @@map("avatars")
}

enum Role {
  ADMIN // Full access
  MANAGER // Manager
  SUPERVISOR // Reports and supervision
  OPERATOR // Basic operations
}
</file>

<file path="prisma/seed.ts">
import { PrismaClient } from "@prisma/client"
import { hash } from "bcryptjs"

const prisma = new PrismaClient()

async function main() {
  const adminEmail = 'fellipefreiire3@gmail.com'

  const existing = await prisma.user.findUnique({
    where: { email: adminEmail }
  })

  if (existing) {
    console.log('Admin user already exists.')
    return
  }

  const passwordHash = await hash('123456', 8)

  await prisma.user.create({
    data: {
      name: 'Felipe Freire',
      email: adminEmail,
      passwordHash,
      role: 'ADMIN',
      isActive: true,
    }
  })

  console.log('✅ Admin user created.')
}

main()
  .catch(e => {
    console.error(e)
    process.exit(1)
  })
  .finally(() => {
    prisma.$disconnect()
  })
</file>

<file path="src/core/entities/aggregate-root.ts">
import { DomainEvent } from '../events/domain-event'
import { DomainEvents } from '../events/domain-events'
import { Entity } from './entity'

export abstract class AggregateRoot<Props> extends Entity<Props> {
  private _domainEvents: DomainEvent[] = []

  get domainEvents(): DomainEvent[] {
    return this._domainEvents
  }

  protected addDomainEvent(domainEvent: DomainEvent): void {
    this._domainEvents.push(domainEvent)
    DomainEvents.markAggregateForDispatch(this)
  }

  public clearEvents(): void {
    this._domainEvents = []
  }
}
</file>

<file path="src/core/entities/entity.ts">
import { UniqueEntityID } from './unique-entity-id'

export abstract class Entity<Props> {
  private _id: UniqueEntityID
  protected props: Props

  get id() {
    return this._id
  }

  protected constructor(props: Props, id?: UniqueEntityID) {
    this.props = props
    this._id = id ?? new UniqueEntityID()
  }

  public equals(entity: Entity<unknown>) {
    if (entity === this) {
      return true
    }

    if (entity.id === this._id) {
      return true
    }

    return false
  }
}
</file>

<file path="src/core/entities/unique-entity-id.ts">
import { randomUUID } from 'crypto'

export class UniqueEntityID {
  private value: string

  toString() {
    return this.value
  }

  toValue() {
    return this.value
  }

  constructor(value?: string) {
    this.value = value ?? randomUUID()
  }

  public equals(id: UniqueEntityID) {
    return id.toValue() === this.value
  }
}
</file>

<file path="src/core/errors/generic-error/index.ts">
import { BaseError } from '../use-case-error'

export class GenericUseCaseError extends BaseError {
  constructor(message = 'An unexpected error occurred') {
    super(message, 'GenericUseCaseError')
  }
}
</file>

<file path="src/core/errors/not-allowed-error/index.ts">
import { BaseError } from '../use-case-error'

export class NotAllowedError extends BaseError {
  constructor(message = 'Not allowed') {
    super(message, 'NotAllowedError')
  }
}
</file>

<file path="src/core/errors/resource-not-found-error/index.ts">
import { BaseError } from '../use-case-error'

export class ResourceNotFoundError extends BaseError {
  constructor(message = 'Resource not found') {
    super(message, 'ResourceNotFoundError')
  }
}
</file>

<file path="src/core/errors/use-case-error.ts">
export interface UseCaseError {
  name: string
  message: string
}

export abstract class BaseError extends Error implements UseCaseError {
  constructor(message: string, name: string) {
    super(message)
    this.name = name
  }
}
</file>

<file path="src/core/events/domain-event.ts">
import { UniqueEntityID } from '../entities/unique-entity-id'

export interface DomainEvent {
  ocurredAt: Date
  getAggregateId(): UniqueEntityID
}
</file>

<file path="src/core/events/domain-events.spec.ts">
import { DomainEvent } from '../events/domain-event'
import { UniqueEntityID } from '../entities/unique-entity-id'
import { AggregateRoot } from '../entities/aggregate-root'
import { DomainEvents } from '@/core/events/domain-events'
import { vi } from 'vitest'

class CustomAggregateCreated implements DomainEvent {
  public ocurredAt: Date
  private aggregate: CustomAggregate // eslint-disable-line

  constructor(aggregate: CustomAggregate) {
    this.aggregate = aggregate
    this.ocurredAt = new Date()
  }

  public getAggregateId(): UniqueEntityID {
    return this.aggregate.id
  }
}

class CustomAggregate extends AggregateRoot<null> {
  static create() {
    const aggregate = new CustomAggregate(null)

    aggregate.addDomainEvent(new CustomAggregateCreated(aggregate))

    return aggregate
  }
}

describe('domain events', () => {
  it('should be able to dispatch and listen to events', async () => {
    const callbackSpy = vi.fn()

    // Subscriber cadastrado (ouvindo o evento de "resposta criada")
    DomainEvents.register(callbackSpy, CustomAggregateCreated.name)

    // Estou criando uma resposta porém SEM salvar no banco
    const aggregate = CustomAggregate.create()

    // Estou assegurando que o evento foi criado porém NÃO foi disparado
    expect(aggregate.domainEvents).toHaveLength(1)

    // Estou salvando a resposta no banco de dados e assim disparando o evento
    DomainEvents.dispatchEventsForAggregate(aggregate.id)

    // O subscriber ouve o evento e faz o que precisa ser feito com o dado
    expect(callbackSpy).toHaveBeenCalled()

    expect(aggregate.domainEvents).toHaveLength(0)
  })
})
</file>

<file path="src/core/events/domain-events.ts">
import { AggregateRoot } from '../entities/aggregate-root'
import { UniqueEntityID } from '../entities/unique-entity-id'
import { DomainEvent } from './domain-event'

type DomainEventCallback = (event: unknown) => void

export class DomainEvents {
  private static handlersMap: Record<string, DomainEventCallback[]> = {}
  private static markedAggregates: AggregateRoot<unknown>[] = []

  public static shouldRun = true

  public static markAggregateForDispatch(aggregate: AggregateRoot<unknown>) {
    const aggregateFound = !!this.findMarkedAggregateByID(aggregate.id)

    if (!aggregateFound) {
      this.markedAggregates.push(aggregate)
    }
  }

  private static dispatchAggregateEvents(aggregate: AggregateRoot<unknown>) {
    aggregate.domainEvents.forEach((event: DomainEvent) => this.dispatch(event))
  }

  private static removeAggregateFromMarkedDispatchList(
    aggregate: AggregateRoot<unknown>,
  ) {
    const index = this.markedAggregates.findIndex((a) => a.equals(aggregate))

    this.markedAggregates.splice(index, 1)
  }

  private static findMarkedAggregateByID(
    id: UniqueEntityID,
  ): AggregateRoot<unknown> | undefined {
    return this.markedAggregates.find((aggregate) => aggregate.id.equals(id))
  }

  public static dispatchEventsForAggregate(id: UniqueEntityID) {
    const aggregate = this.findMarkedAggregateByID(id)

    if (aggregate) {
      this.dispatchAggregateEvents(aggregate)
      aggregate.clearEvents()
      this.removeAggregateFromMarkedDispatchList(aggregate)
    }
  }

  public static register(
    callback: DomainEventCallback,
    eventClassName: string,
  ) {
    const wasEventRegisteredBefore = eventClassName in this.handlersMap

    if (!wasEventRegisteredBefore) {
      this.handlersMap[eventClassName] = []
    }

    this.handlersMap[eventClassName].push(callback)
  }

  public static clearHandlers() {
    this.handlersMap = {}
  }

  public static clearMarkedAggregates() {
    this.markedAggregates = []
  }

  private static dispatch(event: DomainEvent) {
    const eventClassName: string = event.constructor.name

    const isEventRegistered = eventClassName in this.handlersMap

    if (!this.shouldRun) {
      return
    }

    if (isEventRegistered) {
      const handlers = this.handlersMap[eventClassName]

      for (const handler of handlers) {
        handler(event)
      }
    }
  }
}
</file>

<file path="src/core/events/event-handler.ts">
export interface EventHandler {
  setupSubscriptions(): void
}
</file>

<file path="src/core/repositories/pagination-params.ts">
export interface PaginationParams {
  page: number
}
</file>

<file path="src/core/types/optional.ts">
/**
 * Make some property optional on type
 *
 * @example
 * ```typescript
 * type Post {
 *  id: string
 *  name: string
 *  email: string
 * }
 *
 * Optional<Post, 'id' | 'email'>
 * ```
 **/

export type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>
</file>

<file path="src/core/either.spec.ts">
import { Either, left, right } from './either'

function doSomething(shouldSuccess: boolean): Either<string, number> {
  if (shouldSuccess) {
    return right(10)
  }
  return left('error')
}

test('success', () => {
  const result = doSomething(true)

  if (result.isRight()) {
    console.log(result.value)
  }

  expect(result.isRight()).toBe(true)
  expect(result.isLeft()).toBe(false)
})

test('error', () => {
  const result = doSomething(false)

  expect(result.isRight()).toBe(false)
  expect(result.isLeft()).toBe(true)
})
</file>

<file path="src/core/either.ts">
// Error
export class Left<L, R> {
  readonly value: L
  constructor(value: L) {
    this.value = value
  }

  isRight(): this is Right<L, R> {
    return false
  }

  isLeft(): this is Left<L, R> {
    return true
  }
}

// Success
export class Right<L, R> {
  readonly value: R
  constructor(value: R) {
    this.value = value
  }

  isRight(): this is Right<L, R> {
    return true
  }

  isLeft(): this is Left<L, R> {
    return false
  }
}

export type Either<L, R> = Left<L, R> | Right<L, R>

export const left = <L, R>(value: L): Either<L, R> => {
  return new Left(value)
}

export const right = <L, R>(value: R): Either<L, R> => {
  return new Right(value)
}
</file>

<file path="src/domain/user/application/repositories/user-avatar-repository.ts">
import type { UserAvatar } from '../../enterprise/entities/user-avatar'

export abstract class UserAvatarRepository {
  abstract create(userAvatar: UserAvatar): Promise<void>
  abstract findByUserId(userId: string): Promise<UserAvatar | null>
  abstract delete(userAvatar: UserAvatar): Promise<void>
}
</file>

<file path="src/domain/user/application/repositories/user-repository.ts">
import { PaginationParams } from '@/core/repositories/pagination-params'
import { User } from '../../enterprise/entities/user'

export abstract class UsersRepository {
  abstract findById(id: string): Promise<User | null>
  abstract findByEmail(email: string): Promise<User | null>
  abstract list(params: PaginationParams): Promise<User[]>
  abstract save(user: User): Promise<void>
  abstract create(user: User): Promise<void>
  abstract delete(user: User): Promise<void>
}
</file>

<file path="src/domain/user/application/use-cases/__tests__/authenticate-user.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { FakeHasher } from 'test/cryptography/fake-hasher'
import { FakeEncrypter } from 'test/cryptography/fake-encrypter'
import { AuthenticateUserUseCase, expiresIn } from '../authenticate-user'

let inMemoryUsersRepository: InMemoryUsersRepository
let fakeHasher: FakeHasher
let fakeEncrypter: FakeEncrypter

let sut: AuthenticateUserUseCase

describe('Authenticate User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    fakeHasher = new FakeHasher()
    fakeEncrypter = new FakeEncrypter()

    sut = new AuthenticateUserUseCase(
      inMemoryUsersRepository,
      fakeHasher,
      fakeEncrypter,
    )
  })

  it('should be able to authenticate a user', async () => {
    const user = makeUser({
      email: 'johndoe@example.com',
      passwordHash: await fakeHasher.hash('123456'),
    })

    inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      email: 'johndoe@example.com',
      password: '123456',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toEqual({
      accessToken: expect.any(String),
      expiresIn: Math.floor(Date.now() / 1000) + expiresIn,
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/create-user.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { CreateUserUseCase } from '../create-user'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserAlreadyExistsError } from '../errors/user-already-exists-error'
import { FakeHasher } from 'test/cryptography/fake-hasher'

let inMemoryUsersRepository: InMemoryUsersRepository
let fakeHasher: FakeHasher

let sut: CreateUserUseCase

describe('Create User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()
    fakeHasher = new FakeHasher()

    sut = new CreateUserUseCase(inMemoryUsersRepository, fakeHasher)
  })

  it('should be able to create a new user', async () => {
    const result = await sut.execute({
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toEqual({
      data: inMemoryUsersRepository.items[0],
    })
  })

  it('should hash user password upon registration', async () => {
    const result = await sut.execute({
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
    })

    expect(result.isRight()).toBe(true)

    const passwordHash = inMemoryUsersRepository.items[0].passwordHash

    const isPasswordCorrectlyHashed = await fakeHasher.compare(
      '123456',
      passwordHash,
    )

    expect(result.isRight()).toBe(true)
    expect(isPasswordCorrectlyHashed).toBe(true)
  })

  it('should not be able to create a new user with already existing email', async () => {
    const alreadyExistingUser = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(alreadyExistingUser)

    const result = await sut.execute({
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: '123456',
      role: 'OPERATOR',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserAlreadyExistsError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user-role.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserRoleUseCase } from '../edit-user-role'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: EditUserRoleUseCase

describe('Edit User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new EditUserRoleUseCase(inMemoryUsersRepository)
  })

  it('should be able to edit a user', async () => {
    const user = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: user.id.toString(),
      role: 'SUPERVISOR',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        role: 'SUPERVISOR',
      }),
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user-status.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserStatusUseCase } from '../edit-user-status'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: EditUserStatusUseCase

describe('Activate User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new EditUserStatusUseCase(inMemoryUsersRepository)
  })

  it('should be able to activate a user', async () => {
    const user = makeUser(
      {
        email: 'johndoe@example.com',
        isActive: true,
      },
      new UniqueEntityID('user-1'),
    )

    const isActive = !user.isActive

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: user.id.toString(),
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        isActive,
      }),
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/edit-user.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { EditUserUseCase } from '../edit-user'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: EditUserUseCase

describe('Edit User', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new EditUserUseCase(inMemoryUsersRepository)
  })

  it('should be able to edit a user', async () => {
    const user = makeUser(
      {
        name: 'John Doe',
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: user.id.toString(),
      name: 'John Doe 2',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        name: 'John Doe 2',
      }),
    })
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/find-user-by-email.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserNotFoundError } from '../errors/user-not-found'
import { FindUserByEmailUseCase } from '../find-user-by-email'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: FindUserByEmailUseCase

describe('Find User By Id', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new FindUserByEmailUseCase(inMemoryUsersRepository)
  })

  it('should be able to find a user by id', async () => {
    const user = makeUser(
      {
        email: 'johndoe@example.com',
      },
      new UniqueEntityID('user-1'),
    )

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      email: 'johndoe@example.com',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        name: user.name,
        email: user.email,
      }),
    })
  })

  it('should not be able to find a non-existing user', async () => {
    const result = await sut.execute({
      email: 'johndoe2@example.com',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/find-user-by-id.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { FindUserByIdUseCase } from '../find-user-by-id'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserNotFoundError } from '../errors/user-not-found'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: FindUserByIdUseCase

describe('Find User By Id', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new FindUserByIdUseCase(inMemoryUsersRepository)
  })

  it('should be able to find a user by id', async () => {
    const user = makeUser({}, new UniqueEntityID('user-1'))

    await inMemoryUsersRepository.create(user)

    const result = await sut.execute({
      id: 'user-1',
    })

    expect(result.isRight()).toBe(true)
    expect(result.value).toMatchObject({
      data: expect.objectContaining({
        name: user.name,
        email: user.email,
      }),
    })
  })

  it('should not be able to find a non-existing user', async () => {
    const result = await sut.execute({
      id: 'user-2',
    })

    expect(result.isLeft()).toBe(true)
    expect(result.value).toBeInstanceOf(UserNotFoundError)
  })
})
</file>

<file path="src/domain/user/application/use-cases/__tests__/list-users.spec.ts">
import { InMemoryUsersRepository } from 'test/repositories/user/in-memory-users-repository'
import { makeUser } from 'test/factories/make-user'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { ListUsersUseCase } from '../list-users'

let inMemoryUsersRepository: InMemoryUsersRepository

let sut: ListUsersUseCase

describe('List User By Id', () => {
  beforeEach(() => {
    inMemoryUsersRepository = new InMemoryUsersRepository()

    sut = new ListUsersUseCase(inMemoryUsersRepository)
  })

  it('should be able to list a user by id', async () => {
    for (let i = 0; i < 22; i++) {
      const user = makeUser({}, new UniqueEntityID(`user-${i}`))
      await inMemoryUsersRepository.create(user)
    }
    const result = await sut.execute({ page: 2 })

    expect(result.isRight()).toBe(true)
    expect(result.value?.data).toHaveLength(2)
  })
})
</file>

<file path="src/domain/user/application/use-cases/errors/index.ts">
export * from './user-already-exists-error'
export * from './user-not-found'
</file>

<file path="src/domain/user/application/use-cases/errors/invalid-role-transition-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class InvalidRoleTransitionError extends BaseError {
  constructor(message = 'You cannot change roles') {
    super(message, 'InvalidRoleTransitionError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-already-exists-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserAlreadyExistsError extends BaseError {
  constructor(identifier: string) {
    super(`User ${identifier} already exists`, 'UserAlreadyExistsError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-inactive-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserInactiveError extends BaseError {
  constructor(message = 'User inactive') {
    super(message, 'UserInactiveError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/user-not-found.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class UserNotFoundError extends BaseError {
  constructor(message = 'User not found') {
    super(message, 'UserNotFoundError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/errors/wrong-credentials-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class WrongCredentialsError extends BaseError {
  constructor(message = 'Credentials are not valid.') {
    super(message, 'WrongCredentialsError')
  }
}
</file>

<file path="src/domain/user/application/use-cases/authenticate-user.ts">
import { left, right, type Either } from '@/core/either'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { Injectable } from '@nestjs/common'
import { Encrypter } from '../../../../shared/cryptography/encrypter'
import { WrongCredentialsError } from './errors/wrong-credentials-error'
import { HashComparer } from '../../../../shared/cryptography/hash-comparer'

type AuthenticateUserUseCaseRequest = {
  email: string
  password: string
}

type AuthenticateUserUseCaseResponse = Either<
  WrongCredentialsError,
  {
    accessToken: string
    expiresIn: number
  }
>

export const expiresIn = 60 * 60 // 1 hours

@Injectable()
export class AuthenticateUserUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private hashComparar: HashComparer,
    private encrypter: Encrypter,
  ) {}

  async execute({
    email,
    password,
  }: AuthenticateUserUseCaseRequest): Promise<AuthenticateUserUseCaseResponse> {
    const user = await this.usersRepository.findByEmail(email)

    if (!user) {
      return left(new WrongCredentialsError())
    }

    const isPasswordValid = await this.hashComparar.compare(
      password,
      user.passwordHash,
    )

    if (!isPasswordValid) {
      return left(new WrongCredentialsError())
    }

    const accessToken = await this.encrypter.encrypt({
      sub: user.id.toString(),
      role: user.role,
    })

    return right({
      accessToken,
      expiresIn: Math.floor(Date.now() / 1000) + expiresIn,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/create-user.ts">
import { left, right, type Either } from '@/core/either'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { User } from '@/domain/user/enterprise/entities/user'
import { UserAlreadyExistsError } from './errors/user-already-exists-error'
import { Injectable } from '@nestjs/common'
import { HashGenerator } from '../../../../shared/cryptography/hash-generator'
import type { Role } from '@prisma/client'

interface CreateUserUseCaseRequest {
  name: string
  email: string
  password: string
  role: Role
}

type CreateUserUseCaseResponse = Either<
  UserAlreadyExistsError,
  {
    data: User
  }
>

@Injectable()
export class CreateUserUseCase {
  constructor(
    private usersRepository: UsersRepository,
    private hashGenerator: HashGenerator,
  ) {}

  async execute({
    name,
    email,
    password,
    role,
  }: CreateUserUseCaseRequest): Promise<CreateUserUseCaseResponse> {
    const userAlreadyExists = await this.usersRepository.findByEmail(email)

    if (userAlreadyExists) {
      return left(new UserAlreadyExistsError(email))
    }

    const passwordHash = await this.hashGenerator.hash(password)

    const user = User.create({
      email,
      isActive: true,
      name,
      passwordHash,
      role,
    })

    await this.usersRepository.create(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user-role.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'
import type { Role } from '@prisma/client'

type EditUserRoleUseCaseRequest = {
  id: string
  role: Role
}

type EditUserRoleUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserRoleUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
    role,
  }: EditUserRoleUseCaseRequest): Promise<EditUserRoleUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    user.updateRole(role)

    await this.usersRepository.save(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user-status.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'

type EditUserStatusUseCaseRequest = {
  id: string
}

type EditUserStatusUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserStatusUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
  }: EditUserStatusUseCaseRequest): Promise<EditUserStatusUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    user.toggleActive()

    await this.usersRepository.save(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/edit-user.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { UserNotFoundError } from './errors/user-not-found'
import { User } from '../../enterprise/entities/user'

type EditUserUseCaseRequest = {
  id: string
  name: string
  avatarId?: string
}

type EditUserUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class EditUserUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
    name,
  }: EditUserUseCaseRequest): Promise<EditUserUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    user.updateName(name)

    await this.usersRepository.save(user)

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/find-user-by-email.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'
import { UserNotFoundError } from './errors/user-not-found'

type FindUserByEmailUseCaseRequest = {
  email: string
}

type FindUserByEmailUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class FindUserByEmailUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    email,
  }: FindUserByEmailUseCaseRequest): Promise<FindUserByEmailUseCaseResponse> {
    const user = await this.usersRepository.findByEmail(email)

    if (!user) {
      return left(new UserNotFoundError())
    }

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/find-user-by-id.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { left, right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'
import { UserNotFoundError } from './errors/user-not-found'

type FindUserByIdUseCaseRequest = {
  id: string
}

type FindUserByIdUseCaseResponse = Either<
  UserNotFoundError,
  {
    data: User
  }
>

@Injectable()
export class FindUserByIdUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    id,
  }: FindUserByIdUseCaseRequest): Promise<FindUserByIdUseCaseResponse> {
    const user = await this.usersRepository.findById(id)

    if (!user) {
      return left(new UserNotFoundError())
    }

    return right({
      data: user,
    })
  }
}
</file>

<file path="src/domain/user/application/use-cases/list-users.ts">
import { Injectable } from '@nestjs/common'
import { UsersRepository } from '../repositories/user-repository'
import { right, type Either } from '@/core/either'
import { User } from '../../enterprise/entities/user'

type ListUserUseCaseRequest = {
  page: number
}

type ListUserUseCaseResponse = Either<
  null,
  {
    data: User[]
  }
>

@Injectable()
export class ListUsersUseCase {
  constructor(private usersRepository: UsersRepository) {}

  async execute({
    page,
  }: ListUserUseCaseRequest): Promise<ListUserUseCaseResponse> {
    const users = await this.usersRepository.list({ page })

    return right({
      data: users,
    })
  }
}
</file>

<file path="src/domain/user/enterprise/entities/user-avatar.ts">
import { Entity } from '@/core/entities/entity'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export interface UserAvatarProps {
  userId: UniqueEntityID
  avatarId: UniqueEntityID
}

export class UserAvatar extends Entity<UserAvatarProps> {
  get userId() {
    return this.props.userId
  }

  get avatarId() {
    return this.props.avatarId
  }

  static create(props: UserAvatarProps, id?: UniqueEntityID) {
    const userAvatar = new UserAvatar(props, id)

    return userAvatar
  }
}
</file>

<file path="src/domain/user/enterprise/entities/user.ts">
import { AggregateRoot } from '@/core/entities/aggregate-root'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import type { Optional } from '@/core/types/optional'
import type { Role } from '@prisma/client'

export interface UserProps {
  name: string
  email: string
  passwordHash: string
  role: Role
  isActive: boolean
  avatarId?: UniqueEntityID | null
  createdAt: Date
  updatedAt?: Date
}

export class User extends AggregateRoot<UserProps> {
  get name() {
    return this.props.name
  }

  get email() {
    return this.props.email
  }

  get passwordHash() {
    return this.props.passwordHash
  }

  get role() {
    return this.props.role
  }

  get isActive() {
    return this.props.isActive
  }

  get avatarId() {
    return this.props.avatarId
  }

  get createdAt() {
    return this.props.createdAt
  }

  get updatedAt() {
    return this.props.updatedAt
  }

  updateName(value: string) {
    this.props.name = value
    this.touch()
  }

  updateRole(value: Role) {
    this.props.role = value
    this.touch()
  }

  toggleActive() {
    this.props.isActive = !this.props.isActive
    this.touch()
  }

  updateAvatar(value: UniqueEntityID | undefined | null) {
    this.props.avatarId = value
    this.touch()
  }

  private touch() {
    this.props.updatedAt = new Date()
  }

  static create(props: Optional<UserProps, 'createdAt'>, id?: UniqueEntityID) {
    const now = new Date()
    const user = new User(
      {
        ...props,
        role: props.role ?? 'OPERATOR',
        isActive: props.isActive ?? true,
        createdAt: props.createdAt ?? now,
        updatedAt: props.updatedAt ?? now,
      },
      id,
    )
    return user
  }
}
</file>

<file path="src/infra/auth/casl/models/user.ts">
import { z } from 'zod'

import { roleSchema } from '../roles'

export const userSchema = z.object({
  id: z.string(),
  sub: z.string(),
  role: roleSchema,
  __typename: z.literal('User').default('User'),
})

export type User = z.infer<typeof userSchema>
</file>

<file path="src/infra/auth/casl/subjects/user.ts">
import { z } from 'zod'
import { userSchema } from '../models/user'

export const userSubject = z.tuple([
  z.union([
    z.literal('manage'),
    z.literal('create'),
    z.literal('read'),
    z.literal('update'),
    z.literal('activate'),
    z.literal('deactivate'),
    z.literal('update-role'),
  ]),
  z.union([z.literal('User'), userSchema]),
])

export type UserSubject = z.infer<typeof userSubject>
</file>

<file path="src/infra/auth/casl/ability.factory.ts">
import {
  AbilityBuilder,
  createMongoAbility,
  type CreateAbility,
  type MongoAbility,
} from '@casl/ability'
import { ForbiddenException, Injectable } from '@nestjs/common'
import { z } from 'zod'
import { userSubject } from './subjects/user'
import { permissions } from './permissions'
import type { User } from './models/user'

export const appAbilitiesSchema = z.union([
  userSubject,
  z.tuple([z.literal('manage'), z.literal('all')]),
])
type AppAbilities = z.infer<typeof appAbilitiesSchema>

export type AppAbility = MongoAbility<AppAbilities>
export const createAppAbility = createMongoAbility as CreateAbility<AppAbility>

@Injectable()
export class CaslAbilityFactory {
  defineAbilityFor(user: User) {
    const builder = new AbilityBuilder(createAppAbility)

    if (typeof permissions[user.role] !== 'function') {
      throw new ForbiddenException(
        `Permissions for role ${user.role} not found.`,
      )
    }

    permissions[user.role](user, builder)

    const ability = builder.build({
      detectSubjectType(subject) {
        return subject.__typename
      },
    })

    ability.can = ability.can.bind(ability)
    ability.cannot = ability.cannot.bind(ability)
    return ability
  }
}
</file>

<file path="src/infra/auth/casl/casl-ability.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { CaslAbilityFactory } from './ability.factory'
import { CHECK_POLICIES_KEY, PolicyHandler } from './check-policies.decorator'

@Injectable()
export class CaslAbilityGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || []

    const request = context.switchToHttp().getRequest()
    const user = request.user
    const ability = this.caslAbilityFactory.defineAbilityFor(user)

    const isAllowed = policyHandlers.every((handler) => handler(ability))

    if (!isAllowed) {
      throw new ForbiddenException('Acesso negado')
    }

    return true
  }
}
</file>

<file path="src/infra/auth/casl/casl-ability.module.ts">
import { Module } from '@nestjs/common'
import { CaslAbilityFactory } from './ability.factory'

@Module({
  providers: [CaslAbilityFactory],
  exports: [CaslAbilityFactory],
})
export class CaslAbilityModule {}
</file>

<file path="src/infra/auth/casl/check-policies.decorator.ts">
import { SetMetadata } from '@nestjs/common'
import { AppAbility } from './ability.factory'

export type PolicyHandler = (ability: AppAbility) => boolean

export const CHECK_POLICIES_KEY = 'check_policies'
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers)
</file>

<file path="src/infra/auth/casl/permissions.ts">
import { AbilityBuilder } from '@casl/ability'
import { AppAbility } from './ability.factory'
import type { User } from './models/user'
import type { Role } from '@prisma/client'

type PermissionsByRole = (
  user: User,
  builder: AbilityBuilder<AppAbility>,
) => void

export const permissions: Record<Role, PermissionsByRole> = {
  ADMIN(user, { can, cannot }) {
    can('manage', 'all')
    cannot('update', 'User')
    can('update', 'User', {
      id: { $eq: user.sub },
    })
  },
  MANAGER(user, { can }) {
    can('read', 'User')
    can('create', 'User')
    can('activate', 'User')
    can('deactivate', 'User')
    can('update-role', 'User')
    can('update', 'User', {
      id: { $eq: user.sub },
    })
  },
  SUPERVISOR(user, { can }) {
    can('read', 'User')
    can('update', 'User', {
      id: { $eq: user.sub },
    })
  },
  OPERATOR(user, { can, cannot }) {
    cannot('read', 'User')
    can('read', 'User', {
      id: { $eq: user.sub },
    })
  },
}
</file>

<file path="src/infra/auth/casl/roles.ts">
import { z } from 'zod'

export const roleSchema = z.union([
  z.literal('ADMIN'),
  z.literal('MANAGER'),
  z.literal('SUPERVISOR'),
  z.literal('OPERATOR'),
])

export type Role = z.infer<typeof roleSchema>
</file>

<file path="src/infra/auth/auth.module.ts">
import { Module } from '@nestjs/common'
import { JwtModule } from '@nestjs/jwt'
import { PassportModule } from '@nestjs/passport'
import { JwtStrategy } from './jwt.strategy'
import { APP_GUARD } from '@nestjs/core'
import { JwtAuthGuard } from './jwt-auth.guard'
import { EnvService } from '../env/env.service'
import { EnvModule } from '../env/env.module'

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      imports: [EnvModule],
      inject: [EnvService],
      global: true,
      useFactory(env: EnvService) {
        const privateKey = env.get('JWT_PRIVATE_KEY')
        const publicKey = env.get('JWT_PUBLIC_KEY')

        return {
          signOptions: { algorithm: 'RS256', expiresIn: '1h' },
          privateKey: Buffer.from(privateKey, 'base64'),
          publicKey: Buffer.from(publicKey, 'base64'),
        }
      },
    }),
  ],
  providers: [
    JwtStrategy,
    EnvService,
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard,
    },
  ],
})
export class AuthModule {}
</file>

<file path="src/infra/auth/current-user.decorator.ts">
import { ExecutionContext, createParamDecorator } from '@nestjs/common'
import { UserPayload } from './jwt.strategy'

export const CurrentUser = createParamDecorator(
  (_: never, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest()

    return request.user as UserPayload
  },
)
</file>

<file path="src/infra/auth/jwt-auth.guard.ts">
import { Injectable, type ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { AuthGuard } from '@nestjs/passport'
import { IS_PUBLIC_KEY } from './public'

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super()
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    if (isPublic) {
      return true
    }

    return super.canActivate(context)
  }
}
</file>

<file path="src/infra/auth/jwt.strategy.ts">
import { Injectable } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { z } from 'zod'
import { EnvService } from '../env/env.service'
import { roleSchema } from './casl/roles'

const tokenPayloadSchema = z.object({
  sub: z.string().uuid(),
  role: roleSchema,
})

export type UserPayload = z.infer<typeof tokenPayloadSchema>

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(config: EnvService) {
    const publicKey = config.get('JWT_PUBLIC_KEY')

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: Buffer.from(publicKey, 'base64'),
      algorithms: ['RS256'],
    })
  }

  async validate(payload: UserPayload) {
    return tokenPayloadSchema.parse(payload)
  }
}
</file>

<file path="src/infra/auth/public.ts">
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)
</file>

<file path="src/infra/cache/redis/redis-cache-repository.ts">
import { Injectable } from '@nestjs/common'
import { CacheRepository } from '../cache-repository'
import { RedisService } from './redis.service'

@Injectable()
export class RedisCacheRepository implements CacheRepository {
  constructor(private redis: RedisService) {}

  async set(key: string, value: string): Promise<void> {
    await this.redis.set(key, value, 'EX', 60 * 10)
  }

  get(key: string): Promise<string | null> {
    return this.redis.get(key)
  }

  async delete(key: string): Promise<void> {
    await this.redis.del(key)
  }
}
</file>

<file path="src/infra/cache/redis/redis.service.ts">
import { EnvService } from '@/infra/env/env.service'
import { Injectable } from '@nestjs/common'
import { Redis } from 'ioredis'

@Injectable()
export class RedisService extends Redis {
  constructor(envService: EnvService) {
    super({
      host: envService.get('REDIS_HOST'),
      port: Number(envService.get('REDIS_PORT')),
      db: Number(envService.get('REDIS_DB')),
    })
  }

  onModuleDestroy() {
    return this.disconnect()
  }
}
</file>

<file path="src/infra/cache/cache-repository.ts">
export abstract class CacheRepository {
  abstract set(key: string, value: string): Promise<void>
  abstract get(key: string): Promise<string | null>
  abstract delete(key: string): Promise<void>
}
</file>

<file path="src/infra/cache/cache.module.ts">
import { Module } from '@nestjs/common'
import { EnvModule } from '../env/env.module'
import { CacheRepository } from './cache-repository'
import { RedisCacheRepository } from './redis/redis-cache-repository'
import { RedisService } from './redis/redis.service'

@Module({
  imports: [EnvModule],
  providers: [
    RedisService,
    {
      provide: CacheRepository,
      useClass: RedisCacheRepository,
    },
  ],
  exports: [CacheRepository],
})
export class CacheModule {}
</file>

<file path="src/infra/cryptography/bcrypt-hasher.ts">
import { HashComparer } from '@/shared/cryptography/hash-comparer'
import { HashGenerator } from '@/shared/cryptography/hash-generator'
import { hash, compare } from 'bcryptjs'

export class BcryptHasher implements HashGenerator, HashComparer {
  private HASH_SALT_LENGTH = 8

  hash(plain: string): Promise<string> {
    return hash(plain, this.HASH_SALT_LENGTH)
  }

  compare(plain: string, hash: string): Promise<boolean> {
    return compare(plain, hash)
  }
}
</file>

<file path="src/infra/cryptography/cryptography.module.ts">
import { Module } from '@nestjs/common'

import { JwtEncrypter } from './jwt-encrypter'
import { BcryptHasher } from './bcrypt-hasher'
import { Encrypter } from '@/shared/cryptography/encrypter'
import { HashComparer } from '@/shared/cryptography/hash-comparer'
import { HashGenerator } from '@/shared/cryptography/hash-generator'

@Module({
  providers: [
    { provide: Encrypter, useClass: JwtEncrypter },
    { provide: HashComparer, useClass: BcryptHasher },
    { provide: HashGenerator, useClass: BcryptHasher },
  ],
  exports: [Encrypter, HashComparer, HashGenerator],
})
export class CryptographyModule {}
</file>

<file path="src/infra/cryptography/jwt-encrypter.ts">
import { Encrypter } from '@/shared/cryptography/encrypter'
import { Injectable } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'

@Injectable()
export class JwtEncrypter implements Encrypter {
  constructor(private jwtService: JwtService) {}

  encrypt(payload: Record<string, unknown>): Promise<string> {
    return this.jwtService.signAsync(payload)
  }
}
</file>

<file path="src/infra/database/prisma/mappers/avatar/prisma-avatar.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'
import { Avatar as PrismaAvatar, Prisma } from '@prisma/client'

export class PrismaAvatarMapper {
  static toDomain(raw: PrismaAvatar): Avatar {
    return Avatar.create(
      {
        title: raw.title,
        url: raw.url,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(avatar: Avatar): Prisma.AvatarCreateInput {
    return {
      id: avatar.id.toString(),
      title: avatar.title,
      url: avatar.url,
    }
  }
}
</file>

<file path="src/infra/database/prisma/mappers/user/prisma-user-avatar.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { Prisma, type User } from '@prisma/client'

export class PrismaUserAvatarMapper {
  static toDomain(raw: User): UserAvatar {
    if (!raw.avatarId) {
      throw new Error('User has no avatar.')
    }

    return UserAvatar.create(
      {
        userId: new UniqueEntityID(raw.id),
        avatarId: new UniqueEntityID(raw.avatarId),
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(userAvatar: UserAvatar): Prisma.UserUpdateArgs {
    return {
      where: {
        id: userAvatar.userId.toString(),
      },
      data: {
        avatarId: userAvatar.avatarId.toString(),
      },
    }
  }
}
</file>

<file path="src/infra/database/prisma/mappers/user/prisma-user.mapper.ts">
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { User } from '@/domain/user/enterprise/entities/user'
import { User as PrismaUser, Prisma } from '@prisma/client'

export class PrismaUserMapper {
  static toDomain(raw: PrismaUser): User {
    return User.create(
      {
        name: raw.name,
        email: raw.email,
        passwordHash: raw.passwordHash,
        isActive: raw.isActive,
        role: raw.role,
        avatarId: raw.avatarId ? new UniqueEntityID(raw.avatarId) : undefined,
        createdAt: raw.createdAt,
        updatedAt: raw.updatedAt,
      },
      new UniqueEntityID(raw.id),
    )
  }

  static toPrisma(user: User): Prisma.UserCreateInput {
    const base: Prisma.UserCreateInput = {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      passwordHash: user.passwordHash,
      isActive: user.isActive,
      role: user.role,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    }

    if (user.avatarId) {
      base.avatar = {
        connect: {
          id: user.avatarId?.toString(),
        },
      }
    }
    return base
  }
}
</file>

<file path="src/infra/database/prisma/prisma.service.ts">
import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { PrismaClient } from '@prisma/client'

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    super({
      log: ['warn', 'error'],
    })
  }

  onModuleInit() {
    return this.$connect()
  }

  onModuleDestroy() {
    return this.$disconnect()
  }
}
</file>

<file path="src/infra/database/repositories/avatar/avatar-database.module.ts">
import { Module } from '@nestjs/common'
import { PrismaService } from '../../prisma/prisma.service'
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { PrismaAvatarRepository } from './prisma-avatar-repository'

@Module({
  providers: [
    PrismaService,
    {
      provide: AvatarRepository,
      useClass: PrismaAvatarRepository,
    },
  ],
  exports: [PrismaService, AvatarRepository],
})
export class AvatarDatabaseModule {}
</file>

<file path="src/infra/database/repositories/avatar/prisma-avatar-repository.ts">
import { Injectable } from '@nestjs/common'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { PrismaService } from '../../prisma/prisma.service'
import { PrismaAvatarMapper } from '../../prisma/mappers/avatar/prisma-avatar.mapper'

@Injectable()
export class PrismaAvatarRepository implements AvatarRepository {
  constructor(private prisma: PrismaService) {}

  async findById(id: string) {
    const data = await this.prisma.avatar.findUnique({
      where: { id },
    })

    if (!data) {
      return null
    }

    return PrismaAvatarMapper.toDomain(data)
  }

  async create(avatar: Avatar) {
    const data = PrismaAvatarMapper.toPrisma(avatar)

    await this.prisma.avatar.create({
      data,
    })
  }

  async delete(id: string) {
    await this.prisma.avatar.delete({
      where: {
        id,
      },
    })
  }
}
</file>

<file path="src/infra/database/repositories/user/tests/prisma-user-repository.e2e-spec.ts">
import { UserDatabaseModule } from './../user-database.module'
import { INestApplication, VersioningType } from '@nestjs/common'
import { UserFactory } from 'test/factories/make-user'
import { CacheRepository } from '@/infra/cache/cache-repository'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { CacheModule } from '@/infra/cache/cache.module'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'

describe('Prisma Users Repository (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let cacheRepository: CacheRepository
  let usersRepository: UsersRepository

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule, CacheModule],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    cacheRepository = moduleRef.get(CacheRepository)
    usersRepository = moduleRef.get(UsersRepository)

    await app.init()
  })

  it('should cache user details', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    const userDetails = await usersRepository.findById(id)

    const cached = await cacheRepository.get(`user:${id}:details`)

    if (!cached) {
      throw new Error()
    }

    expect(JSON.parse(cached)).toEqual(
      expect.objectContaining({
        id: userDetails?.id.toString(),
      }),
    )
  })

  it('should return cached user details on subsequent calls', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    let cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).toBeNull()

    await usersRepository.findById(id)

    cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).not.toBeNull()

    if (!cached) {
      throw new Error()
    }

    const userDetails = await usersRepository.findById(id)

    expect(JSON.parse(cached)).toEqual(
      expect.objectContaining({
        id: userDetails?.id.toString(),
      }),
    )
  })

  it('should reset user details cache when saving the user', async () => {
    const user = await userFactory.makePrismaUser({})

    const id = user.id.toString()

    await cacheRepository.set(
      `user:${id}:details`,
      JSON.stringify({ empty: true }),
    )

    await usersRepository.save(user)

    const cached = await cacheRepository.get(`user:${id}:details`)

    expect(cached).toBeNull()
  })
})
</file>

<file path="src/infra/database/repositories/user/prisma-user-avatar-repository.ts">
import { Injectable } from '@nestjs/common'
import { PrismaService } from '../../prisma/prisma.service'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import type { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { PrismaUserAvatarMapper } from '../../prisma/mappers/user/prisma-user-avatar.mapper'

@Injectable()
export class PrismaUserAvatarRepository implements UserAvatarRepository {
  constructor(private prisma: PrismaService) {}

  async create(userAvatar: UserAvatar) {
    const data = PrismaUserAvatarMapper.toPrisma(userAvatar)

    await this.prisma.user.update(data)
  }

  async findByUserId(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: {
        id: userId,
      },
    })

    if (!user || !user.avatarId) {
      return null
    }

    return PrismaUserAvatarMapper.toDomain(user)
  }

  async delete(userAvatar: UserAvatar) {
    await this.prisma.user.update({
      where: { id: userAvatar.userId.toString() },
      data: {
        avatarId: null,
      },
    })
  }
}
</file>

<file path="src/infra/database/repositories/user/prisma-users-repository.ts">
import type { PaginationParams } from '@/core/repositories/pagination-params'
import type { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import type { User } from '@/domain/user/enterprise/entities/user'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '../../prisma/prisma.service'
import { PrismaUserMapper } from '../../prisma/mappers/user/prisma-user.mapper'
import { CacheRepository } from '@/infra/cache/cache-repository'

@Injectable()
export class PrismaUsersRepository implements UsersRepository {
  constructor(
    private prisma: PrismaService,
    private cache: CacheRepository,
  ) {}

  async findById(id: string): Promise<User | null> {
    const cacheHit = await this.cache.get(`user:${id}:details`)

    if (cacheHit) {
      const cachedData = JSON.parse(cacheHit)

      return PrismaUserMapper.toDomain(cachedData)
    }

    const user = await this.prisma.user.findFirst({
      where: {
        id,
      },
    })

    if (!user) {
      return null
    }

    await this.cache.set(`user:${id}:details`, JSON.stringify(user))

    return PrismaUserMapper.toDomain(user)
  }

  async findByEmail(email: string): Promise<User | null> {
    const user = await this.prisma.user.findFirst({
      where: {
        email,
      },
    })

    if (!user) {
      return null
    }

    const userDetails = PrismaUserMapper.toDomain(user)

    return userDetails
  }

  async list({ page }: PaginationParams): Promise<User[]> {
    const cacheHit = await this.cache.get('users')

    if (cacheHit) {
      const cachedData = JSON.parse(cacheHit)

      return cachedData.map(PrismaUserMapper.toDomain)
    }

    const users = await this.prisma.user.findMany({
      orderBy: {
        createdAt: 'desc',
      },
      take: 20,
      skip: (page - 1) * 20,
    })

    await this.cache.set('users', JSON.stringify(users))

    return users.map(PrismaUserMapper.toDomain)
  }

  async save(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.update({
        where: { id: data.id },
        data,
      }),
      this.cache.delete(`user:${data.id}:details`),
    ])
  }

  async create(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.create({
        data,
      }),
      this.cache.delete('users'),
    ])
  }

  async delete(user: User): Promise<void> {
    const data = PrismaUserMapper.toPrisma(user)

    await Promise.all([
      this.prisma.user.delete({
        where: { id: data.id },
      }),
      this.cache.delete(`user:${data.id}:*`),
    ])
  }
}
</file>

<file path="src/infra/database/repositories/user/user-database.module.ts">
import { Module } from '@nestjs/common'
import { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import { CacheModule } from '@/infra/cache/cache.module'
import { PrismaService } from '../../prisma/prisma.service'
import { PrismaUsersRepository } from './prisma-users-repository'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import { PrismaUserAvatarRepository } from './prisma-user-avatar-repository'
import { UserFactory } from 'test/factories/make-user'

@Module({
  imports: [CacheModule],
  providers: [
    PrismaService,
    {
      provide: UsersRepository,
      useClass: PrismaUsersRepository,
    },
    {
      provide: UserAvatarRepository,
      useClass: PrismaUserAvatarRepository,
    },
    UserFactory,
  ],
  exports: [PrismaService, UsersRepository, UserAvatarRepository, UserFactory],
})
export class UserDatabaseModule {}
</file>

<file path="src/infra/decorators/service-tag.decorator.ts">
// src/infra/decorators/service-tag.decorator.ts
import { SetMetadata } from '@nestjs/common'
export const SERVICE_TAG = 'SERVICE_TAG'
export const ServiceTag = (tag: string) => SetMetadata(SERVICE_TAG, tag)
</file>

<file path="src/infra/env/env.module.ts">
import { Module } from '@nestjs/common'
import { EnvService } from './env.service'

@Module({
  providers: [EnvService],
  exports: [EnvService],
})
export class EnvModule {}
</file>

<file path="src/infra/env/env.service.ts">
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import type { Env } from './env'

@Injectable()
export class EnvService {
  constructor(private configService: ConfigService<Env, true>) {}

  get<T extends keyof Env>(key: T) {
    return this.configService.get(key, { infer: true })
  }
}
</file>

<file path="src/infra/env/env.ts">
import { z } from 'zod'

export const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  APP_PORT: z.coerce.number().optional().default(3333),
  JWT_PRIVATE_KEY: z.string(),
  JWT_PUBLIC_KEY: z.string(),
  NODE_ENV: z.string(),
  DATABASE_HOST: z.string(),
  DATABASE_PORT: z.string(),
  DATABASE_USERNAME: z.string(),
  DATABASE_PASSWORD: z.string(),
  DATABASE_NAME: z.string(),
  REDIS_HOST: z.string().optional().default('127.0.0.1'),
  REDIS_PORT: z.coerce.number().optional().default(6379),
  REDIS_DB: z.coerce.number().optional().default(0),
  CLOUDFLARE_ACCOUNT_ID: z.string(),
  AWS_ACCESS_KEY_ID: z.string(),
  AWS_SECRET_ACCESS_KEY: z.string(),
  AWS_BUCKET_NAME: z.string(),
})

export type Env = z.infer<typeof envSchema>
</file>

<file path="src/infra/http/controllers/avatar/__tests__/upload-avatar.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { JwtService } from '@nestjs/jwt'
import { AvatarDatabaseModule } from '@/infra/database/repositories/avatar/avatar-database.module'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('Upload Avatar (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, AvatarDatabaseModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  test('[POST] /v1/users/avatar', async () => {
    const user = await userFactory.makePrismaUser({})

    const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

    const response = await request(app.getHttpServer())
      .post('/v1/users/avatar')
      .set('Authorization', `Bearer ${accessToken}`)
      .attach('file', './test/e2e/sample-upload.png')

    expect(response.statusCode).toBe(201)
    expect(response.body).toEqual({
      data: expect.any(String),
    })
  })
})
</file>

<file path="src/infra/http/controllers/avatar/avatar-controllers.module.ts">
import { Module } from '@nestjs/common'
import { CaslAbilityModule } from '@/infra/auth/casl/casl-ability.module'
import { StorageModule } from '@/infra/storage/storage.module'
import { UploadAndCreateAvatarUseCase } from '@/shared/avatar/application/use-cases/upload-and-create-avatar'
import { UploadUserAvatarController } from './upload-avatar.controller'
import { AvatarDatabaseModule } from '@/infra/database/repositories/avatar/avatar-database.module'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

@Module({
  imports: [
    UserDatabaseModule,
    AvatarDatabaseModule,
    CaslAbilityModule,
    StorageModule,
  ],
  controllers: [UploadUserAvatarController],
  providers: [UploadAndCreateAvatarUseCase],
})
export class AvatarControllersModule {}
</file>

<file path="src/infra/http/controllers/avatar/upload-avatar.controller.ts">
import { UserPayload } from './../../../auth/jwt.strategy'
import {
  Controller,
  FileTypeValidator,
  MaxFileSizeValidator,
  ParseFilePipe,
  Post,
  UploadedFile,
  UseFilters,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common'
import { FileInterceptor } from '@nestjs/platform-express'
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger'
import { JwtAuthGuard } from '@/infra/auth/jwt-auth.guard'
import { UploadAndCreateAvatarUseCase } from '@/shared/avatar/application/use-cases/upload-and-create-avatar'
import { CurrentUser } from '@/infra/auth/current-user.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ApiBearerAuth()
@Controller({ path: 'users/avatar', version: '1' })
@UseGuards(JwtAuthGuard)
export class UploadUserAvatarController {
  constructor(private uploadAndCreateAvatar: UploadAndCreateAvatarUseCase) {}

  @Post()
  @UseInterceptors(FileInterceptor('file'))
  async handle(
    @CurrentUser() user: UserPayload,
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({
            maxSize: 1024 * 1024 * 2, // 2mb
          }),
          new FileTypeValidator({
            fileType: '.(png|jpg|jpeg)',
          }),
        ],
      }),
    )
    file: Express.Multer.File,
  ) {
    const result = await this.uploadAndCreateAvatar.execute({
      fileName: file.originalname,
      fileType: file.mimetype,
      body: file.buffer,
      userId: user.sub,
    })

    if (result.isLeft()) {
      throw result.value
    }

    return {
      data: result.value.data.id.toString(),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/__tests__/authenticate-user.controller.e2e-spec.ts">
import { UserFactory } from 'test/factories/make-user'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import { hash } from 'bcryptjs'
import request from 'supertest'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('Authenticate (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)

    await app.init()
  })

  test.only('[POST] /v1/users/login', async () => {
    await userFactory.makePrismaUser({
      email: 'johndoe@example.com',
      passwordHash: await hash('123456', 8),
    })

    const response = await request(app.getHttpServer())
      .post('/v1/users/login')
      .send({
        email: 'johndoe@example.com',
        password: '123456',
      })

    expect(response.statusCode).toBe(201)
    expect(response.body).toEqual({
      access_token: expect.any(String),
      expiresIn: expect.any(Number),
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/create-user.controller.e2e-spec.ts">
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { JwtService } from '@nestjs/jwt'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('Create user (E2E)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let userFactory: UserFactory
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    prisma = moduleRef.get(PrismaService)
    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  describe('[POST] /v1/users', async () => {
    it('should be able to create a new user for role ADMIN', async () => {
      const user = await userFactory.makePrismaUser({
        email: 'johndoe@example.com',
        role: 'ADMIN',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .post('/v1/users')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'Created John Doe',
          role: 'OPERATOR',
          password: '123456',
          email: 'createdjohndoe@example.com',
        })

      expect(response.statusCode).toBe(201)

      const userOnDatabase = await prisma.user.findFirst({
        where: {
          email: 'createdjohndoe@example.com',
        },
      })

      expect(userOnDatabase).toBeTruthy()
    })

    it('should be able to create a new user for role MANAGER', async () => {
      const user = await userFactory.makePrismaUser({
        email: 'johndoe2@example.com',
        role: 'MANAGER',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .post('/v1/users')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'Created John Doe 2',
          role: 'OPERATOR',
          password: '123456',
          email: 'createdjohndoe2@example.com',
        })

      expect(response.statusCode).toBe(201)

      const userOnDatabase = await prisma.user.findFirst({
        where: {
          email: 'createdjohndoe2@example.com',
        },
      })

      expect(userOnDatabase).toBeTruthy()
    })

    it('should block user creation for role SUPERVISOR', async () => {
      const user = await userFactory.makePrismaUser({
        email: 'johndoe3@example.com',
        role: 'SUPERVISOR',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .post('/v1/users')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'Created John Doe 3',
          role: 'OPERATOR',
          password: '123456',
          email: 'createdjohndoe3@gmail.com',
        })

      expect(response.statusCode).toBe(403)
    })

    it('should block user creation for role OPERATOR', async () => {
      const user = await userFactory.makePrismaUser({
        email: 'johndoe4@example.com',
        role: 'OPERATOR',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .post('/v1/users')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'Created John Doe 4',
          role: 'OPERATOR',
          password: '123456',
          email: 'createdjohndoe4@gmail.com',
        })

      expect(response.statusCode).toBe(403)
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('Edit user (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  describe('[PATCH] /v1/users/:id', async () => {
    it('should be able to edit user data', async () => {
      const user = await userFactory.makePrismaUser({
        name: 'John Doe',
        email: 'johndoe@example.com',
        role: 'ADMIN',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'John Doe 2',
        })

      expect(response.statusCode).toBe(200)
    })

    it.skip('should not be able to edit another user data', async () => {
      const user = await userFactory.makePrismaUser({
        name: 'John Doe 2',
        email: 'johndoe2@example.com',
        role: 'ADMIN',
      })

      const user2 = await userFactory.makePrismaUser({
        name: 'John Doe 3',
        email: 'johndoe3@example.com',
      })

      const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/${user2.id.toString()}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'John Doe 3',
        })

      expect(response.statusCode).toBe(403)
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-role.controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import type { User } from '@/domain/user/enterprise/entities/user'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('User role (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService
  let adminUser: User
  let managerUser: User
  let supervisorUser: User
  let operatorUser: User
  let user: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()

    adminUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe@example.com',
      role: 'ADMIN',
      isActive: true,
    })

    managerUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe2@example.com',
      role: 'MANAGER',
      isActive: true,
    })

    supervisorUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe3@example.com',
      role: 'SUPERVISOR',
      isActive: true,
    })

    operatorUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe4@example.com',
      role: 'OPERATOR',
      isActive: true,
    })

    user = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe5@example.com',
      isActive: true,
    })
  })

  describe('[PATCH] /v1/users/role/:id', async () => {
    it('should be able to edit user role with role ADMIN', async () => {
      const accessToken = jwt.sign({
        sub: adminUser.id.toString(),
        role: adminUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/role/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ role: 'SUPERVISOR' })

      expect(response.statusCode).toBe(200)
    })

    it('should be able to edit user role with role MANAGER', async () => {
      const accessToken = jwt.sign({
        sub: managerUser.id.toString(),
        role: managerUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/role/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ role: 'SUPERVISOR' })

      expect(response.statusCode).toBe(200)
    })
    it('should not be able to edit user role with role SUPERVISOR', async () => {
      const accessToken = jwt.sign({
        sub: supervisorUser.id.toString(),
        role: supervisorUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/role/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ role: 'SUPERVISOR' })

      expect(response.statusCode).toBe(403)
    })
    it('should not be able to edit user role with role OPERATOR', async () => {
      const accessToken = jwt.sign({
        sub: operatorUser.id.toString(),
        role: operatorUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/role/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ role: 'SUPERVISOR' })

      expect(response.statusCode).toBe(403)
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/edit-user-status.controller.e2e-spec.ts">
import { AppModule } from '@/infra/app.module'
import { VersioningType, type INestApplication } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { Test } from '@nestjs/testing'
import { UserFactory } from 'test/factories/make-user'
import request from 'supertest'
import type { User } from '@/domain/user/enterprise/entities/user'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('User status (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService
  let adminUser: User
  let managerUser: User
  let supervisorUser: User
  let operatorUser: User
  let user: User

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()

    adminUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe@example.com',
      role: 'ADMIN',
      isActive: true,
    })

    managerUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe2@example.com',
      role: 'MANAGER',
      isActive: true,
    })

    supervisorUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe3@example.com',
      role: 'SUPERVISOR',
      isActive: true,
    })

    operatorUser = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe4@example.com',
      role: 'OPERATOR',
      isActive: true,
    })

    user = await userFactory.makePrismaUser({
      name: 'John Doe',
      email: 'johndoe5@example.com',
      isActive: true,
    })
  })

  describe('[PATCH] /v1/users/status/:id', async () => {
    it('should be able to activate/deactivate user with role ADMIN', async () => {
      const accessToken = jwt.sign({
        sub: adminUser.id.toString(),
        role: adminUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/status/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)

      expect(response.statusCode).toBe(200)
    })

    it('should be able to activate/deactivate user with role MANAGER', async () => {
      const accessToken = jwt.sign({
        sub: managerUser.id.toString(),
        role: managerUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/status/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)

      expect(response.statusCode).toBe(200)
    })
    it('should not be able to activate/deactivate user with role SUPERVISOR', async () => {
      const accessToken = jwt.sign({
        sub: supervisorUser.id.toString(),
        role: supervisorUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/status/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)

      expect(response.statusCode).toBe(403)
    })
    it('should not be able to activate/deactivate user with role OPERATOR', async () => {
      const accessToken = jwt.sign({
        sub: operatorUser.id.toString(),
        role: operatorUser.role,
      })

      const response = await request(app.getHttpServer())
        .patch(`/v1/users/status/${user.id}`)
        .set('Authorization', `Bearer ${accessToken}`)

      expect(response.statusCode).toBe(403)
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/find-user-by-id.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { JwtService } from '@nestjs/jwt'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('Find user by id (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  test('[GET] /v1/users/:id', async () => {
    const user = await userFactory.makePrismaUser({})

    const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

    const response = await request(app.getHttpServer())
      .get(`/v1/users/${user.id.toString()}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send()

    expect(response.statusCode).toBe(200)
    expect(response.body).toEqual({
      data: expect.objectContaining({
        name: user.name,
        email: user.email,
      }),
    })
  })
})
</file>

<file path="src/infra/http/controllers/user/__tests__/list-users.controller.e2e-spec.ts">
import { INestApplication, VersioningType } from '@nestjs/common'
import { Test } from '@nestjs/testing'
import { AppModule } from '@/infra/app.module'
import request from 'supertest'
import { UserFactory } from 'test/factories/make-user'
import { JwtService } from '@nestjs/jwt'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

describe('List users (E2E)', () => {
  let app: INestApplication
  let userFactory: UserFactory
  let jwt: JwtService

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule, UserDatabaseModule],
      providers: [UserFactory],
    }).compile()

    app = moduleRef.createNestApplication()
    app.enableVersioning({
      type: VersioningType.URI,
    })

    userFactory = moduleRef.get(UserFactory)
    jwt = moduleRef.get(JwtService)

    await app.init()
  })

  test('[GET] /v1/users', async () => {
    const user = await userFactory.makePrismaUser({})

    const accessToken = jwt.sign({ sub: user.id.toString(), role: user.role })

    const response = await request(app.getHttpServer())
      .get('/v1/users')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        page: 1,
      })

    expect(response.statusCode).toBe(200)
    expect(response.body?.data).toHaveLength(1)
  })
})
</file>

<file path="src/infra/http/controllers/user/authenticate-user.controller.ts">
import { AuthenticateUserUseCase } from '@/domain/user/application/use-cases/authenticate-user'
import { Public } from '@/infra/auth/public'
import {
  Body,
  Controller,
  HttpCode,
  Post,
  UseFilters,
  UsePipes,
} from '@nestjs/common'
import { z } from 'zod'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { UserInactiveDto, WrongCredentialsDto } from '../../dtos/error/user'
import { AuthenticateUserRequestDto } from '../../dtos/requests/user'
import { AuthenticateUserResponseDto } from '../../dtos/response/user'

const authenticateBodySchema = z.object({
  email: z.string().email(),
  password: z.string(),
})

type AuthenticateBodySchema = z.infer<typeof authenticateBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users/login', version: '1' })
@Public()
export class AuthenticateUserController {
  constructor(private authenticateUser: AuthenticateUserUseCase) {}

  @Post()
  @HttpCode(200)
  @ApiBody({ type: AuthenticateUserRequestDto })
  @ApiOkResponse({
    description: 'Success',
    type: AuthenticateUserResponseDto,
  })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiUnauthorizedResponse({ type: WrongCredentialsDto })
  @ApiForbiddenResponse({ type: UserInactiveDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  @UsePipes(new ZodValidationPipe(authenticateBodySchema))
  async handle(@Body() body: AuthenticateBodySchema) {
    const { email, password } = body
    const result = await this.authenticateUser.execute({ email, password })

    if (result.isLeft()) throw result.value

    return {
      access_token: result.value.accessToken,
      expiresIn: result.value.expiresIn,
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/create-user.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Post,
  UseFilters,
  UseGuards,
  UsePipes,
} from '@nestjs/common'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { z } from 'zod'
import { CreateUserUseCase } from '@/domain/user/application/use-cases/create-user'
import { UserPresenter } from '../../presenters/user.presenter'
import { Role } from '@prisma/client'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiConflictResponse,
  ApiCreatedResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiTags,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'

import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { UserAlreadyExistsDto, UserForbiddenDto } from '../../dtos/error/user'
import { UserResponseDto } from '../../dtos/response/user'
import { CreateUserRequestDto } from '../../dtos/requests/user'

const createUserBodySchema = z.object({
  name: z.string(),
  email: z.string().email(),
  password: z.string(),
  role: z.nativeEnum(Role),
})

type CreateUserBodySchema = z.infer<typeof createUserBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class CreateUserController {
  constructor(private createUserUseCase: CreateUserUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('create', 'User'))
  @Post()
  @HttpCode(201)
  @ApiBody({ type: CreateUserRequestDto })
  @ApiCreatedResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiConflictResponse({ type: UserAlreadyExistsDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  @UsePipes(new ZodValidationPipe(createUserBodySchema))
  async handle(@Body() body: CreateUserBodySchema) {
    const result = await this.createUserUseCase.execute(body)

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/edit-user-role.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
  UsePipes,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { z } from 'zod'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { EditUserRoleUseCase } from '@/domain/user/application/use-cases/edit-user-role'
import { roleSchema } from '@/infra/auth/casl/roles'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import {
  InvalidRoleTransitionDto,
  UserNotFoundDto,
} from '../../dtos/error/user'
import { EditUserRoleRequestDto } from '../../dtos/requests/user'

const editUserRoleBodySchema = z.object({
  role: roleSchema,
})

type EditUserRoleBodySchema = z.infer<typeof editUserRoleBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users/role', version: '1' })
export class EditUserRoleController {
  constructor(private editUserRoleUseCase: EditUserRoleUseCase) {}

  @Patch(':id')
  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('update', 'User'))
  @HttpCode(200)
  @ApiBody({ type: EditUserRoleRequestDto })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiForbiddenResponse({ type: InvalidRoleTransitionDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  @UsePipes(new ZodValidationPipe(editUserRoleBodySchema))
  async handle(
    @Param('id', ParseUuidPipe) id: string,
    @Body() body: EditUserRoleBodySchema,
  ) {
    const { role } = body

    const result = await this.editUserRoleUseCase.execute({
      id,
      role,
    })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/edit-user-status.controller.ts">
import {
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiTags,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { EditUserStatusUseCase } from '@/domain/user/application/use-cases/edit-user-status'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import { UserForbiddenDto, UserNotFoundDto } from '../../dtos/error/user'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users/status', version: '1' })
export class EditUserStatusController {
  constructor(private editUserStatusUseCase: EditUserStatusUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies(
    (ability) =>
      ability.can('activate', 'User') && ability.can('deactivate', 'User'),
  )
  @Patch(':id')
  @HttpCode(200)
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(@Param('id', ParseUuidPipe) id: string) {
    const result = await this.editUserStatusUseCase.execute({
      id,
    })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/edit-user.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  Param,
  Patch,
  UseFilters,
  UseGuards,
  UsePipes,
} from '@nestjs/common'
import {
  ApiBadRequestResponse,
  ApiBody,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger'
import { EditUserUseCase } from '@/domain/user/application/use-cases/edit-user'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { UserPresenter } from '../../presenters/user.presenter'
import { z } from 'zod'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { EditUserRequestDto } from '../../dtos/requests/user'
import {
  BadRequestDto,
  InternalServerErrorDto,
  UnprocessableEntityDto,
} from '../../dtos/error/generic'
import { UserNotFoundDto, UserForbiddenDto } from '../../dtos/error/user'
import { UserResponseDto } from '../../dtos/response/user'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'

const editUserBodySchema = z.object({
  name: z.string().min(1),
  avatarId: z.string().uuid().optional(),
})

type EditUserBodySchema = z.infer<typeof editUserBodySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class EditUserController {
  constructor(private editUserUseCase: EditUserUseCase) {}

  @Patch(':id')
  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('update', 'User'))
  @HttpCode(200)
  @ApiBody({ type: EditUserRequestDto })
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiUnprocessableEntityResponse({ type: UnprocessableEntityDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  @UsePipes(new ZodValidationPipe(editUserBodySchema))
  async handle(
    @Param('id', new ParseUuidPipe()) id: string,
    @Body() body: EditUserBodySchema,
  ) {
    const result = await this.editUserUseCase.execute({ id, ...body })

    if (result.isLeft()) throw result.value

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/find-user-by-id.controller.ts">
import {
  Controller,
  Get,
  HttpCode,
  Param,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { UserPresenter } from '../../presenters/user.presenter'
import { FindUserByIdUseCase } from '@/domain/user/application/use-cases/find-user-by-id'
import {
  ApiBadRequestResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiTags,
} from '@nestjs/swagger'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { ParseUuidPipe } from '../../pipes/parse-uuid.pipe'
import { UserResponseDto } from '../../dtos/response/user'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import { UserForbiddenDto, UserNotFoundDto } from '../../dtos/error/user'

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class FindUserByIdController {
  constructor(private findUserByIdUseCase: FindUserByIdUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('read', 'User'))
  @Get(':id')
  @HttpCode(200)
  @ApiOkResponse({ type: UserResponseDto })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiNotFoundResponse({ type: UserNotFoundDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(@Param('id', ParseUuidPipe) id: string) {
    const result = await this.findUserByIdUseCase.execute({ id })

    if (result.isLeft()) {
      throw result.value
    }

    const user = result.value.data

    return {
      data: UserPresenter.toHTTP(user),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/list-users.controller.ts">
import {
  BadRequestException,
  Controller,
  Get,
  HttpCode,
  Query,
  UseFilters,
  UseGuards,
} from '@nestjs/common'
import { z } from 'zod'
import { UserPresenter } from '../../presenters/user.presenter'
import {
  ApiBadRequestResponse,
  ApiForbiddenResponse,
  ApiInternalServerErrorResponse,
  ApiOkResponse,
  ApiTags,
} from '@nestjs/swagger'
import { ZodValidationPipe } from '../../pipes/zod-validation.pipe'
import { ListUsersUseCase } from '@/domain/user/application/use-cases/list-users'
import { CaslAbilityGuard } from '@/infra/auth/casl/casl-ability.guard'
import { CheckPolicies } from '@/infra/auth/casl/check-policies.decorator'
import { ServiceTag } from '@/infra/decorators/service-tag.decorator'
import { UserErrorFilter } from '../../filters/user-error.filter'
import { BadRequestDto, InternalServerErrorDto } from '../../dtos/error/generic'
import { UserResponseDto } from '../../dtos/response/user'
import { UserForbiddenDto } from '../../dtos/error/user'

const querySchema = z.object({
  page: z.coerce.number().optional().default(1),
})
type QuerySchema = z.infer<typeof querySchema>

@UseFilters(UserErrorFilter)
@ApiTags('Users')
@ServiceTag('user')
@Controller({ path: 'users', version: '1' })
export class ListUsersController {
  constructor(private listUsersUseCase: ListUsersUseCase) {}

  @UseGuards(CaslAbilityGuard)
  @CheckPolicies((ability) => ability.can('read', 'User'))
  @Get()
  @HttpCode(200)
  @ApiOkResponse({ type: [UserResponseDto] })
  @ApiBadRequestResponse({ type: BadRequestDto })
  @ApiForbiddenResponse({ type: UserForbiddenDto })
  @ApiInternalServerErrorResponse({ type: InternalServerErrorDto })
  async handle(
    @Query(new ZodValidationPipe(querySchema)) { page }: QuerySchema,
  ) {
    const result = await this.listUsersUseCase.execute({ page })

    if (result.isLeft()) {
      throw new BadRequestException()
    }

    const user = result.value.data

    return {
      data: user.map(UserPresenter.toHTTP),
    }
  }
}
</file>

<file path="src/infra/http/controllers/user/user-controllers.module.ts">
import { Module } from '@nestjs/common'
import { CreateUserController } from './create-user.controller'
import { CreateUserUseCase } from '@/domain/user/application/use-cases/create-user'
import { FindUserByIdController } from './find-user-by-id.controller'
import { FindUserByIdUseCase } from '@/domain/user/application/use-cases/find-user-by-id'
import { CryptographyModule } from '@/infra/cryptography/cryptography.module'
import { AuthenticateUserController } from './authenticate-user.controller'
import { AuthenticateUserUseCase } from '@/domain/user/application/use-cases/authenticate-user'
import { CaslAbilityModule } from '@/infra/auth/casl/casl-ability.module'
import { EditUserController } from './edit-user.controller'
import { EditUserUseCase } from '@/domain/user/application/use-cases/edit-user'
import { EditUserStatusController } from './edit-user-status.controller'
import { EditUserStatusUseCase } from '@/domain/user/application/use-cases/edit-user-status'
import { EditUserRoleController } from './edit-user-role.controller'
import { EditUserRoleUseCase } from '@/domain/user/application/use-cases/edit-user-role'
import { ListUsersController } from './list-users.controller'
import { ListUsersUseCase } from '@/domain/user/application/use-cases/list-users'
import { StorageModule } from '@/infra/storage/storage.module'
import { UserDatabaseModule } from '@/infra/database/repositories/user/user-database.module'

@Module({
  imports: [
    UserDatabaseModule,
    CryptographyModule,
    CaslAbilityModule,
    StorageModule,
  ],
  controllers: [
    AuthenticateUserController,
    CreateUserController,
    EditUserRoleController,
    EditUserStatusController,
    EditUserController,
    FindUserByIdController,
    ListUsersController,
  ],
  providers: [
    AuthenticateUserUseCase,
    CreateUserUseCase,
    EditUserRoleUseCase,
    EditUserStatusUseCase,
    EditUserUseCase,
    FindUserByIdUseCase,
    ListUsersUseCase,
  ],
})
export class UserControllersModule {}
</file>

<file path="src/infra/http/dtos/error/generic/bad-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class BadRequestDto {
  @ApiProperty({ example: 400 })
  declare statusCode: number

  @ApiProperty({ example: 'Bad Request' })
  declare error: string

  @ApiProperty({ example: 'Invalid parameters' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/conflict.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ConflictDto {
  @ApiProperty({ example: 409 })
  declare statusCode: number

  @ApiProperty({ example: 'Conflict' })
  declare error: string

  @ApiProperty({ example: 'E-mail already in use' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/forbidden.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ForbiddenDto {
  @ApiProperty({ example: 403 })
  declare statusCode: number

  @ApiProperty({ example: 'Forbidden' })
  declare error: string

  @ApiProperty({ example: 'You do not have permission to perform this action' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/index.ts">
export * from './bad-request.dto'
export * from './unauthorized.dto'
export * from './forbidden.dto'
export * from './not-found.dto'
export * from './conflict.dto'
export * from './too-many-requests.dto'
export * from './validation.dto'
export * from './internal-server.dto'
export * from './unprocessable-entity.dto'
</file>

<file path="src/infra/http/dtos/error/generic/internal-server.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class InternalServerErrorDto {
  @ApiProperty({ example: 500 })
  declare statusCode: number

  @ApiProperty({ example: 'Internal server error' })
  declare error: string

  @ApiProperty({ example: 'Internal server error' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/not-found.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class NotFoundDto {
  @ApiProperty({ example: 404 })
  declare statusCode: number

  @ApiProperty({ example: 'Not Found' })
  declare error: string

  @ApiProperty({ example: 'Resource not found' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/too-many-requests.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class TooManyRequestsDto {
  @ApiProperty({ example: 429 })
  declare statusCode: number

  @ApiProperty({ example: 'Too Many Requests' })
  declare error: string

  @ApiProperty({ example: 'Rate limit exceeded' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/unauthorized.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UnauthorizedDto {
  @ApiProperty({ example: 401 })
  declare statusCode: number

  @ApiProperty({ example: 'Unauthorized' })
  declare error: string

  @ApiProperty({ example: 'Invalid credentials' })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/unprocessable-entity.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class UnprocessableEntityDto {
  @ApiProperty({ example: 422 })
  declare statusCode: number

  @ApiProperty({ example: 'Unprocessable Entity' })
  declare error: string

  @ApiProperty({ example: [{ path: 'email', message: 'Invalid e-mail' }] })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/generic/validation.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class ValidationErrorDto {
  @ApiProperty({ example: 400 })
  declare statusCode: number

  @ApiProperty({ example: 'BadRequest' })
  declare error: string

  @ApiProperty({
    example: [
      { path: 'email', message: 'E-mail must be valid' },
      { path: 'password', message: 'Minimum length is 6' },
    ],
  })
  declare message: string | string[]
}
</file>

<file path="src/infra/http/dtos/error/user/index.ts">
export * from './user-inactive.dto'
export * from './wrong-credentials.dto'
export * from './user-already-exists.dto'
export * from './invalid-role-transition.dto'
export * from './user-not-found.dto'
export * from './user-forbidden.dto'
</file>

<file path="src/infra/http/dtos/error/user/invalid-role-transition.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic/forbidden.dto'

export class InvalidRoleTransitionDto extends ForbiddenDto {
  @ApiProperty({ example: 'Cannot change role from OPERATOR to ADMIN' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-already-exists.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ConflictDto } from '../generic/conflict.dto'

export class UserAlreadyExistsDto extends ConflictDto {
  @ApiProperty({ example: 'User already exists.' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-forbidden.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic'

export class UserForbiddenDto extends ForbiddenDto {
  @ApiProperty({ example: 'Access Denied' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-inactive.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { ForbiddenDto } from '../generic/forbidden.dto'

export class UserInactiveDto extends ForbiddenDto {
  @ApiProperty({ example: 'User is inactive' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/user-not-found.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { NotFoundDto } from '../generic/not-found.dto'

export class UserNotFoundDto extends NotFoundDto {
  @ApiProperty({ example: 'User not found' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/error/user/wrong-credentials.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { UnauthorizedDto } from '../generic'

export class WrongCredentialsDto extends UnauthorizedDto {
  @ApiProperty({ example: 'Credentials are not valid.' })
  declare message: string
}
</file>

<file path="src/infra/http/dtos/requests/user/authenticate-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class AuthenticateUserRequestDto {
  @ApiProperty({ example: 'john@email.com' })
  email!: string

  @ApiProperty({ example: 'mySecurePass123' })
  password!: string
}
</file>

<file path="src/infra/http/dtos/requests/user/create-user-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class CreateUserRequestDto {
  @ApiProperty({ example: 'John Doe' })
  name!: string

  @ApiProperty({ example: 'john.doe@email.com' })
  email!: string

  @ApiProperty({ example: 'MySecurePass123!' })
  password!: string

  @ApiProperty({ enum: Role, example: Role.ADMIN })
  role!: Role
}
</file>

<file path="src/infra/http/dtos/requests/user/edit-user-request.dto.ts">
// edit-user-request.dto.ts
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger'

export class EditUserRequestDto {
  @ApiProperty({ example: 'John Updated' })
  name!: string

  @ApiPropertyOptional({
    example: '6be7aab9-30a7-4fc8-b22a-4a25e3d7d4b4',
    description: 'Avatar ID existente',
  })
  avatarId?: string
}
</file>

<file path="src/infra/http/dtos/requests/user/edit-user-role-request.dto.ts">
import { ApiProperty } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class EditUserRoleRequestDto {
  @ApiProperty({
    enum: Role,
    example: Role.ADMIN,
    description: 'Novo cargo do usuário',
  })
  role!: Role
}
</file>

<file path="src/infra/http/dtos/requests/user/index.ts">
export * from './authenticate-request.dto'
export * from './create-user-request.dto'
export * from './edit-user-request.dto'
export * from './edit-user-role-request.dto'
</file>

<file path="src/infra/http/dtos/response/user/authenticate-response.dto.ts">
import { ApiProperty } from '@nestjs/swagger'

export class AuthenticateUserResponseDto {
  @ApiProperty({ example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6...' })
  access_token!: string

  @ApiProperty({ example: 3600 })
  expiresIn!: number
}
</file>

<file path="src/infra/http/dtos/response/user/index.ts">
export * from './authenticate-response.dto'
export * from './user-response.dto'
</file>

<file path="src/infra/http/dtos/response/user/user-response.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger'
import { Role } from '@prisma/client'

export class UserResponseDto {
  @ApiProperty({ example: '855c4f19-38e5-4b73-932e-9e3fb6eafe30' })
  id!: string

  @ApiProperty({ example: 'John Doe' })
  name!: string

  @ApiProperty({ example: 'john.doe@email.com' })
  email!: string

  @ApiProperty({ enum: Role, example: Role.ADMIN })
  role!: Role

  @ApiProperty({ example: true })
  isActive!: boolean

  @ApiPropertyOptional({
    example: 'https://cdn.powerbrake.io/avatars/855c4f19.png',
  })
  avatarUrl?: string | null

  @ApiProperty({ example: '2025-06-04T01:42:11.123Z' })
  createdAt!: string

  @ApiPropertyOptional({ example: '2025-06-04T01:42:11.123Z' })
  updatedAt?: string | null
}
</file>

<file path="src/infra/http/filters/app-error.filter.ts">
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  Logger,
} from '@nestjs/common'
import { Response } from 'express'
import { ZodError } from 'zod'
import { BaseError } from '@/core/errors/use-case-error'

@Catch()
export class AppErrorFilter implements ExceptionFilter {
  private readonly logger = new Logger(AppErrorFilter.name)

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp()
    const res = ctx.getResponse<Response>()

    if (exception instanceof ZodError) {
      res.status(422).json({
        statusCode: 422,
        error: 'Unprocessable Entity',
        message: exception.errors.map((e) => ({
          path: e.path.join('.'),
          message: e.message,
        })),
      })
      return
    }

    if (exception instanceof BaseError) {
      const status = this.mapDomainErrorToStatus(exception.name)
      res.status(status).json({
        statusCode: status,
        error: this.statusToText(status),
        message: exception.message,
      })
      return
    }

    if (exception instanceof HttpException) {
      const status = exception.getStatus()
      const body = exception.getResponse()
      res.status(status).json({
        statusCode: status,
        error: this.statusToText(status),
        ...(typeof body === 'string' ? { message: body } : body),
      })
      return
    }

    this.logger.error(exception)
    res.status(500).json({
      statusCode: 500,
      error: 'Internal Server Error',
      message: 'Internal server error',
    })
  }

  protected mapDomainErrorToStatus(name: string): number {
    return (
      {
        UserAlreadyExistsError: 409,
        UserNotFoundError: 404,
        InvalidAvatarTypeError: 400,
        WrongCredentialsError: 401,
      }[name] ?? 400
    )
  }

  private statusToText(code: number): string {
    return (
      (
        {
          400: 'Bad Request',
          401: 'Unauthorized',
          403: 'Forbidden',
          404: 'Not Found',
          409: 'Conflict',
          422: 'Unprocessable Entity',
          429: 'Too Many Requests',
          500: 'Internal Server Error',
        } as const
      )[code] ?? 'Error'
    )
  }
}
</file>

<file path="src/infra/http/filters/user-error.filter.ts">
import { Catch } from '@nestjs/common'
import { AppErrorFilter } from './app-error.filter'
import {
  UserAlreadyExistsError,
  UserNotFoundError,
} from '@/domain/user/application/use-cases/errors'
import { WrongCredentialsError } from '@/domain/user/application/use-cases/errors/wrong-credentials-error'
import { UserInactiveError } from '@/domain/user/application/use-cases/errors/user-inactive-error'
import { InvalidRoleTransitionError } from '@/domain/user/application/use-cases/errors/invalid-role-transition-error'

@Catch()
export class UserErrorFilter extends AppErrorFilter {
  protected override mapDomainErrorToStatus(name: string): number {
    switch (name) {
      case WrongCredentialsError.name:
        return 401
      case UserInactiveError.name:
      case InvalidRoleTransitionError.name:
        return 403
      case UserNotFoundError.name:
        return 404
      case UserAlreadyExistsError.name:
        return 409
      default:
        return super.mapDomainErrorToStatus(name)
    }
  }
}
</file>

<file path="src/infra/http/pipes/parse-uuid.pipe.ts">
import {
  PipeTransform,
  Injectable,
  BadRequestException,
  ArgumentMetadata,
} from '@nestjs/common'
import { isUUID } from 'class-validator'

@Injectable()
export class ParseUuidPipe implements PipeTransform<string> {
  transform(value: string, meta: ArgumentMetadata) {
    if (!isUUID(value, '4')) {
      throw new BadRequestException({
        statusCode: 400,
        error: 'Bad Request',
        message: `Param ${meta.data ?? 'id'} must be a valid UUID`,
      })
    }
    return value
  }
}
</file>

<file path="src/infra/http/pipes/zod-validation.pipe.ts">
import {
  PipeTransform,
  BadRequestException,
  UnprocessableEntityException,
} from '@nestjs/common'
import { ZodError, ZodSchema } from 'zod'
import { fromZodError } from 'zod-validation-error'

export class ZodValidationPipe implements PipeTransform {
  constructor(private readonly schema: ZodSchema) {}

  transform(value: unknown) {
    try {
      return this.schema.parse(value)
    } catch (error) {
      if (error instanceof ZodError) {
        const issues = error.errors

        const hasMissing = issues.some(
          (i) => i.code === 'invalid_type' && i.received === 'undefined',
        )

        const formatted = fromZodError(error)

        if (hasMissing) {
          throw new BadRequestException({
            statusCode: 400,
            message: 'Missing required fields',
            errors: formatted,
          })
        }

        throw new UnprocessableEntityException({
          statusCode: 422,
          message: 'Validation failed',
          errors: formatted,
        })
      }

      throw new BadRequestException('Validation failed')
    }
  }
}
</file>

<file path="src/infra/http/presenters/user.presenter.ts">
import type { User } from '@/domain/user/enterprise/entities/user'

export class UserPresenter {
  static toHTTP(user: User) {
    return {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isActive: user.isActive,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    }
  }
}
</file>

<file path="src/infra/http/http.module.ts">
import { Module } from '@nestjs/common'
import { UserControllersModule } from './controllers/user/user-controllers.module'
import { AvatarControllersModule } from './controllers/avatar/avatar-controllers.module'

@Module({
  imports: [UserControllersModule, AvatarControllersModule],
})
export class HttpModule {}
</file>

<file path="src/infra/logger/logger.interceptor.ts">
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  HttpException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { Observable, tap, catchError, throwError } from 'rxjs'

import { SERVICE_TAG } from '@/infra/decorators/service-tag.decorator'
import { AppLogger } from './logger.service'

@Injectable()
export class RequestLoggingInterceptor
  implements NestInterceptor<unknown, unknown>
{
  constructor(
    private readonly logger: AppLogger,
    private readonly reflector: Reflector,
  ) {}

  intercept(
    context: ExecutionContext,
    next: CallHandler<unknown>,
  ): Observable<unknown> {
    const http = context.switchToHttp()
    const req = http.getRequest()
    const res = http.getResponse()
    const start = Date.now()

    const service =
      this.reflector.get<string>(SERVICE_TAG, context.getClass()) ?? 'api'

    const baseMeta = {
      service,
      route: req.originalUrl,
      httpMethod: req.method,
    }

    return next.handle().pipe(
      tap(() => {
        const status = res.statusCode
        this.logger.info(`[${status}] Request handled`, {
          ...baseMeta,
          timeToComplete: Date.now() - start,
        })
      }),

      catchError((err) => {
        const status = err instanceof HttpException ? err.getStatus() : 500

        this.logger.error(`[${status}] ${err.message ?? 'Unhandled error'}`, {
          ...baseMeta,
          timeToComplete: Date.now() - start,
        })

        return throwError(() => err)
      }),
    )
  }
}
</file>

<file path="src/infra/logger/logger.module.ts">
import { Module, Global } from '@nestjs/common'
import { WinstonLoggerProvider } from './winston.provider'
import { APP_INTERCEPTOR } from '@nestjs/core'
import { AppLogger } from './logger.service'
import { RequestLoggingInterceptor } from './logger.interceptor'

@Global()
@Module({
  providers: [
    WinstonLoggerProvider,
    AppLogger,
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLoggingInterceptor,
    },
  ],
  exports: [AppLogger],
})
export class LoggerModule {}
</file>

<file path="src/infra/logger/logger.service.ts">
import { Injectable, Inject } from '@nestjs/common'
import { Logger } from 'winston'
import { WINSTON_LOGGER } from './winston.token'

@Injectable()
export class AppLogger {
  constructor(@Inject(WINSTON_LOGGER) private readonly logger: Logger) {}

  info(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.info(msg, meta)
  }

  warn(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.warn(msg, meta)
  }

  error(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.error(msg, meta)
  }

  debug(msg: string, meta: Record<string, unknown> = {}) {
    this.logger.debug(msg, meta)
  }
}
</file>

<file path="src/infra/logger/winston.config.ts">
import { createLogger, format, transports } from 'winston'
import kleur from 'kleur'

const isDev = process.env.NODE_ENV === 'production'

function colorTime(time: number) {
  if (typeof time !== 'number' || isNaN(time)) return kleur.yellow(`${time}ms`)
  if (time < 300) return kleur.yellow(`${time}ms`)
  if (time < 1000) return kleur.yellow().bold(`${time}ms`)
  return kleur.red().bold(`${time}ms`)
}

function colorLevel(level: string) {
  switch (level.toLowerCase()) {
    case 'info':
      return kleur.blue(level.toUpperCase())
    case 'warn':
      return kleur.yellow(level.toUpperCase())
    case 'error':
      return kleur.red(level.toUpperCase())
    case 'debug':
      return kleur.magenta(level.toUpperCase())
    default:
      return level.toUpperCase()
  }
}

function formatDate(dateISO: string): string {
  if (!dateISO) return ''
  const date = new Date(dateISO)
  if (isNaN(date.getTime())) return ''
  return date.toLocaleString('pt-BR', {
    timeZone: 'UTC',
    year: '2-digit',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

const coloredProdFormat = format.combine(
  format.timestamp(),
  format.printf((info) => {
    try {
      const timestamp = typeof info.timestamp === 'string' ? info.timestamp : ''
      const dateTime = formatDate(timestamp)
      const service = kleur.yellow(String(info.service ?? ''))
      const level = colorLevel(String(info.level ?? 'info'))
      const route = kleur.green(
        `{${String(info.route ?? '')}, ${String(info.httpMethod ?? '')}} route`,
      )
      const message = kleur.yellow(String(info.message ?? ''))
      const time =
        typeof info.timeToComplete === 'number'
          ? colorTime(info.timeToComplete)
          : kleur.yellow(String(info.timeToComplete ?? '') + 'ms')
      return `${dateTime} - service: ${service} - [${level}] - ${route} - ${message}: ${time}`
    } catch (err) {
      return `[LOGGER ERROR] ${err}\nRAW: ${JSON.stringify(info)}`
    }
  }),
)

const devFormat = format.combine(
  format.colorize(),
  format.timestamp(),
  format.printf(({ timestamp, level, message, ...meta }) =>
    [
      `[${timestamp}]`,
      level,
      message,
      Object.keys(meta).length ? JSON.stringify(meta, null, 2) : '',
    ]
      .filter(Boolean)
      .join(' '),
  ),
)

export function createDomainLogger(service: string) {
  return createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: isDev ? devFormat : coloredProdFormat,
    defaultMeta: { service },
    transports: [new transports.Console()],
  })
}
</file>

<file path="src/infra/logger/winston.provider.ts">
import { Provider } from '@nestjs/common'
import { createDomainLogger } from './winston.config'
import { WINSTON_LOGGER } from './winston.token'

export const WinstonLoggerProvider: Provider = {
  provide: WINSTON_LOGGER,
  useFactory: () => createDomainLogger('api'),
}
</file>

<file path="src/infra/logger/winston.token.ts">
export const WINSTON_LOGGER = Symbol('WINSTON_LOGGER')
</file>

<file path="src/infra/storage/r2-storage.ts">
import {
  Uploader,
  type UploadParams,
} from '@/shared/avatar/application/storage/uploader'
import { EnvService } from '../env/env.service'
import {
  DeleteObjectCommand,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3'
import { randomUUID } from 'node:crypto'
import { Injectable } from '@nestjs/common'

@Injectable()
export class R2Storage implements Uploader {
  private client: S3Client
  private bucketName: string

  constructor(envService: EnvService) {
    const accountId = envService.get('CLOUDFLARE_ACCOUNT_ID')
    this.bucketName = envService.get('AWS_BUCKET_NAME')

    this.client = new S3Client({
      endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
      region: 'auto',
      credentials: {
        accessKeyId: envService.get('AWS_ACCESS_KEY_ID'),
        secretAccessKey: envService.get('AWS_SECRET_ACCESS_KEY'),
      },
    })
  }

  async upload({
    body,
    fileName,
    fileType,
  }: UploadParams): Promise<{ url: string }> {
    const uploadId = randomUUID()
    const uniqueFileName = `${uploadId}-${fileName}`

    await this.client.send(
      new PutObjectCommand({
        Bucket: this.bucketName,
        Key: uniqueFileName,
        ContentType: fileType,
        Body: body,
      }),
    )

    return {
      url: uniqueFileName,
    }
  }

  async delete(fileName: string): Promise<void> {
    await this.client.send(
      new DeleteObjectCommand({
        Bucket: this.bucketName,
        Key: fileName,
      }),
    )
  }
}
</file>

<file path="src/infra/storage/storage.module.ts">
import { Uploader } from '@/shared/avatar/application/storage/uploader'
import { Module } from '@nestjs/common'
import { R2Storage } from './r2-storage'
import { EnvModule } from '../env/env.module'

@Module({
  imports: [EnvModule],
  providers: [
    {
      provide: Uploader,
      useClass: R2Storage,
    },
  ],
  exports: [Uploader],
})
export class StorageModule {}
</file>

<file path="src/infra/app.module.ts">
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { envSchema } from './env/env'
import { HttpModule } from './http/http.module'
import { AuthModule } from './auth/auth.module'
import { EnvModule } from './env/env.module'
import { LoggerModule } from './logger/logger.module'

@Module({
  imports: [
    ConfigModule.forRoot({
      validate: (env) => envSchema.parse(env),
      isGlobal: true,
    }),
    LoggerModule,
    AuthModule,
    HttpModule,
    EnvModule,
  ],
})
export class AppModule {}
</file>

<file path="src/infra/main.ts">
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { EnvService } from './env/env.service'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import { VersioningType } from '@nestjs/common'
import { AppErrorFilter } from './http/filters/app-error.filter'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.enableVersioning({
    type: VersioningType.URI,
  })

  app.useGlobalFilters(new AppErrorFilter())

  const swaggerConfig = new DocumentBuilder()
    .setTitle('Powerbrake API')
    .setDescription('Documentação da API do projeto')
    .setVersion('1.0')
    .addBearerAuth()
    .build()

  const document = SwaggerModule.createDocument(app, swaggerConfig)
  SwaggerModule.setup('docs', app, document)

  const envService = app.get(EnvService)
  const port = envService.get('APP_PORT')

  await app.listen(port)
}
bootstrap()
</file>

<file path="src/shared/avatar/application/repositories/avatar-repository.ts">
import type { Avatar } from '../../enterprise/entities/avatar'

export abstract class AvatarRepository {
  abstract findById(id: string): Promise<Avatar | null>
  abstract create(avatar: Avatar): Promise<void>
  abstract delete(id: string): Promise<void>
}
</file>

<file path="src/shared/avatar/application/storage/uploader.ts">
export interface UploadParams {
  fileName: string
  fileType: string
  body: Buffer
}

export abstract class Uploader {
  abstract upload(params: UploadParams): Promise<{ url: string }>
  abstract delete(fileName: string): Promise<void>
}
</file>

<file path="src/shared/avatar/application/use-cases/errors/avatar-not-found-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class AvatarNotFoundError extends BaseError {
  constructor(message = 'Avatar not found') {
    super(message, 'AvatarNotFoundError')
  }
}
</file>

<file path="src/shared/avatar/application/use-cases/errors/avatar-upload-failed-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class AvatarUploadFailedError extends BaseError {
  constructor(message = 'Failed to upload avatar') {
    super(message, 'AvatarUploadFailedError')
  }
}
</file>

<file path="src/shared/avatar/application/use-cases/errors/invalid-avatar-type-error.ts">
import { BaseError } from '@/core/errors/use-case-error'

export class InvalidAvatarTypeError extends BaseError {
  constructor(type: string) {
    super(`File type "${type}" is not valid.`, 'InvalidAvatarTypeError')
  }
}
</file>

<file path="src/shared/avatar/application/use-cases/tests/upload-and-create-avatar.spec.ts">
import { InMemoryAvatarRepository } from 'test/repositories/avatar/in-memory-avatar-repository'
import { UploadAndCreateAvatarUseCase } from '../upload-and-create-avatar'
import { FakeUploader } from 'test/storage/fake-uploader'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { makeAvatar } from 'test/factories/make-avatar'
import { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { InMemoryUserAvatarRepository } from 'test/repositories/user/in-memory-user-avatar-repository'

let inMemoryAvatarRepository: InMemoryAvatarRepository
let inMemoryUserAvatarRepository: InMemoryUserAvatarRepository
let fakeUploader: FakeUploader
let sut: UploadAndCreateAvatarUseCase

describe('Upload and Create Avatar', () => {
  beforeEach(() => {
    inMemoryAvatarRepository = new InMemoryAvatarRepository()
    inMemoryUserAvatarRepository = new InMemoryUserAvatarRepository()
    fakeUploader = new FakeUploader()

    sut = new UploadAndCreateAvatarUseCase(
      inMemoryAvatarRepository,
      inMemoryUserAvatarRepository,
      fakeUploader,
    )
  })

  it('should upload and create a new avatar for user without avatar', async () => {
    const userId = 'user-1'
    // Simula um usuário sem avatar
    await inMemoryUserAvatarRepository.create(
      UserAvatar.create({
        userId: new UniqueEntityID(userId),
        avatarId: new UniqueEntityID(), // sem avatar real ainda
      }),
    )

    const result = await sut.execute({
      userId,
      fileName: 'profile.png',
      fileType: 'image/png',
      body: Buffer.from(''),
    })

    expect(result.isRight()).toBe(true)
    expect(inMemoryAvatarRepository.items).toHaveLength(1)
    expect(fakeUploader.uploads).toHaveLength(1)
  })

  it('should replace existing avatar', async () => {
    const userId = 'user-1'
    const oldAvatar = makeAvatar(
      {
        title: 'old_profile.png',
        url: 'old-key.png',
      },
      new UniqueEntityID('avatar-1'),
    )

    await inMemoryAvatarRepository.create(oldAvatar)
    await inMemoryUserAvatarRepository.create(
      UserAvatar.create({
        userId: new UniqueEntityID(userId),
        avatarId: oldAvatar.id,
      }),
    )

    fakeUploader.uploads.push({
      fileName: oldAvatar.title,
      url: oldAvatar.url,
    })

    const avatarRepoDeleteSpy = vi.spyOn(inMemoryAvatarRepository, 'delete')

    const result = await sut.execute({
      userId,
      fileName: 'new_profile.png',
      fileType: 'image/jpeg',
      body: Buffer.from('new-image-data'),
    })

    expect(result.isRight()).toBe(true)

    if (result.isRight()) {
      const newAvatar = result.value.data

      expect(avatarRepoDeleteSpy).toHaveBeenCalledWith(oldAvatar.id.toString())
      expect(fakeUploader.uploads).toHaveLength(1)
      expect(fakeUploader.uploads[0].fileName).toBe('new_profile.png')
      expect(
        inMemoryAvatarRepository.items.find((av) => av.id.equals(oldAvatar.id)),
      ).toBeUndefined()
      expect(
        inMemoryAvatarRepository.items.find((av) => av.id.equals(newAvatar.id)),
      ).toBeTruthy()
    }
  })
})
</file>

<file path="src/shared/avatar/application/use-cases/upload-and-create-avatar.ts">
import { left, right, type Either } from '@/core/either'
import { Avatar } from '../../enterprise/entities/avatar'
import { Injectable } from '@nestjs/common'
import { AvatarRepository } from '../repositories/avatar-repository'
import { Uploader } from '@/shared/avatar/application/storage/uploader'
import { InvalidAvatarTypeError } from './errors/invalid-avatar-type-error'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'
import { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'

type UploadAndCreateAvatarUseCaseRequest = {
  userId: string
  fileName: string
  fileType: string
  body: Buffer
}

type UploadAndCreateAvatarUseCaseResponse = Either<
  InvalidAvatarTypeError,
  {
    data: Avatar
  }
>

@Injectable()
export class UploadAndCreateAvatarUseCase {
  constructor(
    private avatarRepository: AvatarRepository,
    private userAvatarRepository: UserAvatarRepository,
    private uploader: Uploader,
  ) {}

  async execute({
    userId,
    fileName,
    fileType,
    body,
  }: UploadAndCreateAvatarUseCaseRequest): Promise<UploadAndCreateAvatarUseCaseResponse> {
    if (!/^(image\/(jpeg|jpg|png))$/.test(fileType)) {
      return left(new InvalidAvatarTypeError(fileType))
    }

    const userAvatar = await this.userAvatarRepository.findByUserId(userId)

    if (userAvatar?.avatarId) {
      const existingAvatar = await this.avatarRepository.findById(
        userAvatar.avatarId.toString(),
      )

      if (existingAvatar) {
        await this.avatarRepository.delete(existingAvatar.id.toString())
        await this.uploader.delete(existingAvatar.url)
      }
    }

    const { url } = await this.uploader.upload({ fileName, fileType, body })

    const avatar = Avatar.create({
      title: fileName,
      url,
    })

    await this.avatarRepository.create(avatar)

    const newUserAvatar = UserAvatar.create({
      userId: new UniqueEntityID(userId),
      avatarId: avatar.id,
    })

    await this.userAvatarRepository.create(newUserAvatar)

    return right({
      data: avatar,
    })
  }
}
</file>

<file path="src/shared/avatar/enterprise/entities/avatar.ts">
import { Entity } from '@/core/entities/entity'
import type { UniqueEntityID } from '@/core/entities/unique-entity-id'

export interface AvatarProps {
  title: string
  url: string
}

export class Avatar extends Entity<AvatarProps> {
  get title() {
    return this.props.title
  }

  get url() {
    return this.props.url
  }

  static create(props: AvatarProps, id?: UniqueEntityID) {
    const avatar = new Avatar(props, id)

    return avatar
  }
}
</file>

<file path="src/shared/cryptography/encrypter.ts">
export abstract class Encrypter {
  abstract encrypt(payload: Record<string, unknown>): Promise<string>
}
</file>

<file path="src/shared/cryptography/hash-comparer.ts">
export abstract class HashComparer {
  abstract compare(plain: string, hash: string): Promise<boolean>
}
</file>

<file path="src/shared/cryptography/hash-generator.ts">
export abstract class HashGenerator {
  abstract hash(plain: string): Promise<string>
}
</file>

<file path="test/cryptography/fake-encrypter.ts">
import type { Encrypter } from '@/shared/cryptography/encrypter'

export class FakeEncrypter implements Encrypter {
  async encrypt(payload: Record<string, unknown>): Promise<string> {
    return JSON.stringify(payload)
  }
}
</file>

<file path="test/cryptography/fake-hasher.ts">
import type { HashComparer } from '@/shared/cryptography/hash-comparer'
import type { HashGenerator } from '@/shared/cryptography/hash-generator'

export class FakeHasher implements HashGenerator, HashComparer {
  async hash(plain: string): Promise<string> {
    return plain.concat('-hashed')
  }

  async compare(plain: string, hash: string): Promise<boolean> {
    return plain.concat('-hashed') === hash
  }
}
</file>

<file path="test/factories/make-avatar.ts">
import { faker } from '@faker-js/faker'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaAvatarMapper } from '@/infra/database/prisma/mappers/avatar/prisma-avatar.mapper'
import {
  Avatar,
  type AvatarProps,
} from '@/shared/avatar/enterprise/entities/avatar'

export function makeAvatar(
  override: Partial<AvatarProps> = {},
  id?: UniqueEntityID,
) {
  const avatar = Avatar.create(
    {
      title: faker.lorem.word(),
      url: faker.image.url(),
      ...override,
    },
    id,
  )

  return avatar
}

@Injectable()
export class AvatarFactory {
  constructor(private prisma: PrismaService) {}

  async makePrismaAvatar(data: Partial<AvatarProps> = {}): Promise<Avatar> {
    const avatar = makeAvatar(data)

    await this.prisma.avatar.create({
      data: PrismaAvatarMapper.toPrisma(avatar),
    })

    return avatar
  }
}
</file>

<file path="test/factories/make-user.ts">
import { faker } from '@faker-js/faker'
import { UniqueEntityID } from '@/core/entities/unique-entity-id'
import { User, type UserProps } from '@/domain/user/enterprise/entities/user'
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@/infra/database/prisma/prisma.service'
import { PrismaUserMapper } from '@/infra/database/prisma/mappers/user/prisma-user.mapper'

export function makeUser(
  override: Partial<UserProps> = {},
  id?: UniqueEntityID,
) {
  const user = User.create(
    {
      name: faker.person.fullName(),
      email: faker.internet.email(),
      passwordHash: faker.internet.password(),
      role: 'OPERATOR',
      isActive: true,
      ...override,
    },
    id,
  )

  return user
}

@Injectable()
export class UserFactory {
  constructor(private prisma: PrismaService) {}

  async makePrismaUser(data: Partial<UserProps> = {}): Promise<User> {
    const user = makeUser(data)

    await this.prisma.user.create({
      data: PrismaUserMapper.toPrisma(user),
    })

    return user
  }
}
</file>

<file path="test/repositories/avatar/in-memory-avatar-repository.ts">
import { AvatarRepository } from '@/shared/avatar/application/repositories/avatar-repository'
import { Avatar } from '@/shared/avatar/enterprise/entities/avatar'

export class InMemoryAvatarRepository implements AvatarRepository {
  public items: Avatar[] = []

  async create(avatar: Avatar): Promise<void> {
    this.items.push(avatar)
  }

  async findById(id: string): Promise<Avatar | null> {
    const avatar = this.items.find((item) => item.id.toString() === id)
    return avatar || null
  }

  async delete(id: string): Promise<void> {
    const index = this.items.findIndex((item) => item.id.toString() === id)

    if (index > -1) {
      this.items.splice(index, 1)
    }
  }

  // Método auxiliar opcional para debug ou testes
  async list(): Promise<Avatar[]> {
    return this.items
  }
}
</file>

<file path="test/repositories/user/in-memory-user-avatar-repository.ts">
import { UserAvatar } from '@/domain/user/enterprise/entities/user-avatar'
import { UserAvatarRepository } from '@/domain/user/application/repositories/user-avatar-repository'

export class InMemoryUserAvatarRepository implements UserAvatarRepository {
  public items: UserAvatar[] = []

  async create(userAvatar: UserAvatar): Promise<void> {
    const existingIndex = this.items.findIndex((item) =>
      item.userId.equals(userAvatar.userId),
    )

    if (existingIndex >= 0) {
      this.items[existingIndex] = userAvatar
    } else {
      this.items.push(userAvatar)
    }
  }

  async findByUserId(userId: string): Promise<UserAvatar | null> {
    const found = this.items.find((item) => item.userId.toString() === userId)
    return found ?? null
  }

  async delete(userAvatar: UserAvatar): Promise<void> {
    const index = this.items.findIndex(
      (item) =>
        item.userId.equals(userAvatar.userId) &&
        item.avatarId.equals(userAvatar.avatarId),
    )

    if (index !== -1) {
      this.items.splice(index, 1)
    }
  }
}
</file>

<file path="test/repositories/user/in-memory-users-repository.ts">
import type { PaginationParams } from '@/core/repositories/pagination-params'
import type { UsersRepository } from '@/domain/user/application/repositories/user-repository'
import type { User } from '@/domain/user/enterprise/entities/user'

export class InMemoryUsersRepository implements UsersRepository {
  public items: User[] = []

  async findById(id: string) {
    const user = this.items.find((item) => item.id.toString() === id)

    return user || null
  }

  async findByEmail(email: string) {
    const user = this.items.find((item) => item.email === email)

    return user || null
  }

  async list({ page }: PaginationParams) {
    const users = this.items
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice((page - 1) * 20, page * 20)

    return users
  }

  async create(user: User) {
    this.items.push(user)
  }

  async save(user: User) {
    const itemIndex = this.items.findIndex((item) => item.id === user.id)

    this.items[itemIndex] = user
  }

  async delete(user: User) {
    const itemIndex = this.items.findIndex((item) => item.id === user.id)

    this.items.splice(itemIndex, 1)
  }
}
</file>

<file path="test/storage/fake-uploader.ts">
import {
  Uploader,
  UploadParams,
} from '@/shared/avatar/application/storage/uploader'
import { randomUUID } from 'node:crypto'

type Upload = {
  fileName: string
  url: string
}

export class FakeUploader implements Uploader {
  public uploads: Upload[] = []

  async upload({ fileName }: UploadParams): Promise<{ url: string }> {
    const url = randomUUID()

    this.uploads.push({
      fileName,
      url,
    })

    return { url }
  }

  async delete(url: string): Promise<void> {
    const uploadIndex = this.uploads.findIndex((upload) => upload.url === url)

    if (uploadIndex > -1) {
      this.uploads.splice(uploadIndex, 1)
    }
  }
}
</file>

<file path="test/utils/wait-for.ts">
/**
 * This function loops through a function rerunning all assertions
 * inside of it until it gets a truthy result.
 *
 * If the maximum duration is reached, it then rejects.
 *
 * @param expectations A function containing all tests assertions
 * @param maxDuration Maximum wait time before rejecting
 */
export async function waitFor(
  assertions: () => void,
  maxDuration = 1000,
): Promise<void> {
  return new Promise((resolve, reject) => {
    let elapsedTime = 0

    const interval = setInterval(() => {
      elapsedTime += 10

      try {
        assertions()
        clearInterval(interval)
        resolve()
      } catch (err) {
        if (elapsedTime >= maxDuration) {
          reject(err)
        }
      }
    }, 10)
  })
}
</file>

<file path="test/setup-e2e.ts">
import { config } from 'dotenv'

import { PrismaClient } from '@prisma/client'
import { randomUUID } from 'node:crypto'
import { execSync } from 'node:child_process'
import { DomainEvents } from '@/core/events/domain-events'
import { Redis } from 'ioredis'
import { envSchema } from '@/infra/env/env'

config({ path: '.env', override: true })
config({ path: '.env.test', override: true })

const env = envSchema.parse(process.env)

const prisma = new PrismaClient()
const redis = new Redis({
  host: env.REDIS_HOST,
  port: env.REDIS_PORT,
  db: env.REDIS_DB,
})

function generateUniqueDatabaseURL(schemaId: string) {
  if (!env.DATABASE_URL) {
    throw new Error('Please provider a DATABASE_URL environment variable')
  }

  const url = new URL(env.DATABASE_URL)

  url.searchParams.set('schema', schemaId)

  return url.toString()
}

const schemaId = randomUUID()

beforeAll(async () => {
  const databaseURL = generateUniqueDatabaseURL(schemaId)

  process.env.DATABASE_URL = databaseURL

  DomainEvents.shouldRun = false

  await redis.flushdb()

  execSync('npx prisma migrate deploy')
})

afterAll(async () => {
  await prisma.$executeRawUnsafe(`DROP SCHEMA IF EXISTS "${schemaId}" CASCADE`)
  await prisma.$disconnect()
})
</file>

<file path=".env.example">
DATABASE_URL=
NODE_ENV=dev
APP_PORT="3333"
DATABASE_HOST="database"
DATABASE_PORT="5432"
DATABASE_USERNAME="postgres"
DATABASE_PASSWORD="postgres"
DATABASE_NAME="app"
REDIS_TTL=600
JWT_PRIVATE_KEY=
JWT_PUBLIC_KEY=
</file>

<file path=".eslintrc.json">
{
  "extends": "@rocketseat/eslint-config/node",
  "parserOptions": {
    "project": "./tsconfig.eslint.json"
  },
  "rules": {
    "no-useless-constructor": "off",
    "no-new": "off",
    "dot-notation": "off"
  },
  "settings": {
    "import/resolver": {
      "typescript": {
        "project": "./tsconfig.json"
      }
    }
  }
}
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local
.env.test

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma

private_key.pem
public_key.pem
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  database:
    image: postgres:latest
    container_name: powerbrake-database
    environment:
      POSTGRES_USER: ${DATABASE_USERNAME}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
    ports:
      - '5432:5432'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U $${POSTGRES_USER}']
      interval: 5s
      retries: 5

  redis:
    image: redis:7.2-alpine
    container_name: powerbrake-redis
    ports:
      - '6379:6379'
    command: ['redis-server', '--appendonly', 'yes']
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 3s
      retries: 5
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "entryFile": "infra/main",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:cov": "vitest run --coverage",
    "test:debug": "vitest --inspect-brk -- inspect --logHeapUsage --threads=false",
    "test:e2e": "vitest run --config ./vitest.config.e2e.mjs",
    "test:e2e:watch": "vitest --config ./vitest.config.e2e.mjs",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:migrate:prod": "prisma migrate deploy && prisma generate",
    "prisma:studio": "prisma studio",
    "prisma:seed": "prisma db seed"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.821.0",
    "@casl/ability": "^6.7.3",
    "@nestjs-modules/ioredis": "^2.0.2",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/swagger": "^11.2.0",
    "@prisma/client": "^6.8.2",
    "bcryptjs": "^3.0.2",
    "dayjs": "^1.11.13",
    "ioredis": "^5.6.1",
    "kleur": "^4.1.5",
    "nest-winston": "^1.10.2",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0",
    "zod": "^3.25.28",
    "zod-validation-error": "^3.4.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@faker-js/faker": "^9.8.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@rocketseat/eslint-config": "^2.2.2",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/bcryptjs": "^2.4.6",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "@vitest/coverage-v8": "^3.1.4",
    "dotenv": "^16.5.0",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^10.0.1",
    "eslint-import-resolver-typescript": "^4.4.2",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "multer": "^2.0.0",
    "prettier": "^3.4.2",
    "prisma": "^6.8.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.20.0",
    "unplugin-swc": "^1.5.3",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^3.1.4"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "packageManager": "yarn@1.22.22+sha256.c17d3797fb9a9115bf375e31bfd30058cac6bc9c3b8807a3d8cb2094794b51ca"
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.eslint.json">
{
  "extends": "./tsconfig.json",
  "include": [
    "src/**/*.ts",
    "test/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "esModuleInterop": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false,
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "types": [
      "vitest/globals",
      "multer"
    ]
  }
}
</file>

<file path="vitest.config.e2e.mjs">
import swc from 'unplugin-swc'
import { defineConfig, configDefaults } from 'vitest/config'
import tsConfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  test: {
    include: ['**/*.e2e-spec.ts'],
    globals: true,
    root: './',
    exclude: [...configDefaults.exclude, '**/data/pg/**'],
    setupFiles: ['./test/setup-e2e.ts'],
  },
  plugins: [
    tsConfigPaths(),
    swc.vite({
      module: { type: 'es6' },
    }),
  ],
})
</file>

<file path="vitest.config.mjs">
import swc from 'unplugin-swc'
import { defineConfig } from 'vitest/config'
import tsConfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  test: {
    globals: true,
    root: './',
  },
  plugins: [
    tsConfigPaths(),
    swc.vite({
      module: { type: 'es6' },
    }),
  ],
})
</file>

</files>
